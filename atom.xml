<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Holmes He</title>
  
  <subtitle>Holmes&#39; Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://holmeshe.me/"/>
  <updated>2020-12-22T10:48:38.121Z</updated>
  <id>https://holmeshe.me/</id>
  
  <author>
    <name>Holmes He</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Understanding The Memcached Source Code-Event Driven III</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-IX/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-IX/</id>
    <published>2019-06-01T22:30:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="#"><text style="color:black;font-weight:bold;">, III - this article)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>We continue examining the other two operations, i.e., create and delete, in the <strong>event driven</strong> context. Now it’s a good chance to revisit the <a href="/understanding-memcached-source-code-VIII/#Core-data-structure-conn">core data structure</a> and look at the</p><h1 id="Properties-in-discussion"><a href="#Properties-in-discussion" class="headerlink" title="Properties in discussion"></a>Properties in discussion</h1><a id="more"></a><p><code>wbuf</code> - the address for <em>write buffer</em> for simple response output (e.g., STORED). used by <a href="#out-string">out_string</a></p><p><code>wcurr</code> - not very useful as it points to the same address as <code>wbuf</code>. used by <a href="#conn-write">conn_write</a></p><p><code>wsize</code> - the total size of <em>write buffer</em>. used by <a href="#out-string">out_string</a> to determine buff overflow</p><p><code>wbytes</code> - the length of data populated in <em>write buffer</em>. value is set in <a href="#out-string">out_string</a>; used by <a href="#conn-write">conn_write</a> when writing it to the “real” output buffer <a href="/understanding-memcached-source-code-VIII/#add-iov">iov</a></p><p><code>write_and_go</code> - set to <code>conn_new_cmd</code> in the <a href="#out-string">very last step</a> to form a “state loop”</p><p><code>ritem</code> - one of the essential properties for <a href="#conn-nread">data reading</a>. it is set to the address of the data portion of the actual <strong>item</strong> created by <a href="#process-update-command">create command</a></p><p><code>rlbytes</code> - one of the essential properties for <a href="#conn-nread">data reading</a>. it is set to the length of the data in need</p><p><code>item</code> - record of the actual <strong>item</strong> created by <a href="#process-update-command">create command</a></p><p><code>noreply</code> - determined by the command. we assume it is set to <code>false</code></p><h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><p>As usual, we start with a command sent to a <strong>Memcached</strong> server.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; add test 0 60 11 (\r\n)</span><br><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure><p>As mentioned in <a href="/understanding-memcached-source-code-VI/#Create">LRU III</a>, two passes are involved in the command processing, the first pass creates an empty object after reading the first line, and the second populates the object with the concrete value contained in the second line. Such division is for the multiple <em>I/O</em> triggered by line breaks in <em>telnet</em>.</p><p class="back"><br>In fact, most of the logic involved in this post has been discussed before such as in <a href="/understanding-memcached-source-code-VI">LRU III</a> and <a href="/understanding-memcached-source-code-VIII">Event Driven II</a>. Hence this post will only resolve the missing parts and linking points.<br></p><p>For the first command,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; add test 0 60 11 (\r\n)</span><br></pre></td></tr></table></figure><p>The <strong>Memcached</strong> instance outputs the following lines. This time we omit the output for accepting the new connection</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27: going from conn_new_cmd to conn_waiting</span><br><span class="line">27: going from conn_waiting to conn_read</span><br><span class="line">27: going from conn_read to conn_parse_cmd</span><br><span class="line">27: Client using the ascii protocol</span><br><span class="line">&lt;27 add test 0 60 11</span><br><span class="line">27: going from conn_parse_cmd to conn_nread</span><br></pre></td></tr></table></figure><p>The logic for command reading and parsing (<code>conn_new_cmd</code> to <code>conn_parse_cmd</code>) are the same as what described in <a href="/understanding-memcached-source-code-VIII/#conn-new-cmd">Event Driven II</a>. The difference is that </p><h2 id="process-update-command"><a href="#process-update-command" class="headerlink" title="process_update_command"></a>process_update_command</h2><p>is invoked after the command parsing. Though the method has been examined in <a href="/understanding-memcached-source-code-VI/#process-update-command">LRU III</a>, it is worth reminding that the last step is to update the <em>session context</em> for the next <strong>state</strong> (<code>conn_nread</code>) which handles the actual data reading.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_update_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">const</span> <span class="keyword">size_t</span> ntokens, <span class="keyword">int</span> comm, <span class="keyword">bool</span> handle_cas)</span> </span>&#123;</span><br><span class="line">... <span class="comment">// LRU III</span></span><br><span class="line">    c-&gt;item = it;</span><br><span class="line">    c-&gt;ritem = ITEM_data(it);</span><br><span class="line">    c-&gt;rlbytes = it-&gt;nbytes;</span><br><span class="line">    c-&gt;cmd = comm;</span><br><span class="line">    conn_set_state(c, conn_nread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_update_command@memcached.c</text></center><p>Next we look at the second command</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure><p>and its associated output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; NOT FOUND test</span><br><span class="line">&gt;27 STORED</span><br><span class="line">27: going from conn_nread to conn_write</span><br><span class="line">27: going from conn_write to conn_new_cmd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>The key code fragment for the <strong>state</strong> switching above is</p><h2 id="conn-nread"><a href="#conn-nread" class="headerlink" title="conn_nread"></a>conn_nread</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_nread:</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;rlbytes == <span class="number">0</span>) &#123; <span class="comment">// scr: ---------------------------&gt; 5)</span></span><br><span class="line">                complete_nread(c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* first check if we have leftovers in the conn_read buffer */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;rbytes &gt; <span class="number">0</span>) &#123; <span class="comment">// scr: -----------------------------&gt; 1)</span></span><br><span class="line">                <span class="keyword">int</span> tocopy = c-&gt;rbytes &gt; c-&gt;rlbytes ? c-&gt;rlbytes : c-&gt;rbytes;</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;ritem != c-&gt;rcurr) &#123;</span><br><span class="line">                    memmove(c-&gt;ritem, c-&gt;rcurr, tocopy);</span><br><span class="line">                &#125;</span><br><span class="line">                c-&gt;ritem += tocopy;</span><br><span class="line">                c-&gt;rlbytes -= tocopy;</span><br><span class="line">                c-&gt;rcurr += tocopy;</span><br><span class="line">                c-&gt;rbytes -= tocopy;</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;rlbytes == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*  now try reading from the socket */</span></span><br><span class="line">            res = read(c-&gt;sfd, c-&gt;ritem, c-&gt;rlbytes); <span class="comment">// scr: --------&gt; 2)</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                <span class="keyword">if</span> (c-&gt;rcurr == c-&gt;ritem) &#123;</span><br><span class="line">                    c-&gt;rcurr += res;</span><br><span class="line">                &#125;</span><br><span class="line">                c-&gt;ritem += res;</span><br><span class="line">                c-&gt;rlbytes -= res;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">0</span>) &#123; <span class="comment">/* end of stream */</span> <span class="comment">// scr: --------------&gt; 3)</span></span><br><span class="line">                conn_set_state(c, conn_closing);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">// scr: ------------------------------------------------&gt; 4)</span></span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">-1</span> &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!update_event(c, EV_READ | EV_PERSIST)) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">                &#125;</span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_update_command@memcached.c</text></center><p>1) Check if there are some leftover data (from the <a href="/understanding-memcached-source-code-VIII/#try-read-network">command read</a> phase). If so, read directly.</p><p class="back"><br>More specific, say, if you can enter the command above fast enough (maybe copy paste it directly to <em>telnet</em>), the data portion will be coalesced in with the command by <a href="/understanding-memcached-source-code-VIII/#try-read-network">read</a>.<br></p><p>2) Read the data to the memory pointed by <code>ritem</code>.</p><p>3) If the connection is closed (<em>FIN</em>) in the middle of the read, close the session.</p><p>4) If the data is separated into multiple <code>read</code>s, then set the <em>drive machine</em> to listen to more data and suspend.</p><p>5) Normal termination - <code>read</code> finished, call <a href="/understanding-memcached-source-code-VI/#complete-nread-ascii">complete_nread</a> which is covered in <a href="/understanding-memcached-source-code-VI">LRU III</a>.</p><p>The missing part in <a href="/understanding-memcached-source-code-VI">LRU III</a> is <code>out_string</code>. Combined with <code>conn_write</code>, it functions as a simpler version of <a href="/understanding-memcached-source-code-VIII/#process-get-command">process_get_command</a> for “simple response”, and the actual data writing is handled by <a href="/understanding-memcached-source-code-VIII/#conn-mwrite">conn_mwrite</a> (note the <code>fall through...</code> in the <code>switch case</code>) block which, as discussed, changes the <strong>state</strong> back to <code>conn_new_cmd</code>. Next we discuss the process in detail.</p><h2 id="out-string"><a href="#out-string" class="headerlink" title="out_string"></a>out_string</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">out_string</span><span class="params">(conn *c, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    </span><br><span class="line">...<span class="comment">//scr: not applicable</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"&gt;%d %s\n"</span>, c-&gt;sfd, str);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* Nuke a partial output... */</span></span><br><span class="line">    c-&gt;msgcurr = <span class="number">0</span>; <span class="comment">// scr: ---------------------------&gt; 1)</span></span><br><span class="line">    c-&gt;msgused = <span class="number">0</span>;</span><br><span class="line">    c-&gt;iovused = <span class="number">0</span>;</span><br><span class="line">    add_msghdr(c);</span><br><span class="line">    </span><br><span class="line">    len = <span class="built_in">strlen</span>(str); <span class="comment">// scr: ------------------------&gt; 2)</span></span><br><span class="line">    <span class="keyword">if</span> ((len + <span class="number">2</span>) &gt; c-&gt;wsize) &#123;</span><br><span class="line">        <span class="comment">/* ought to be always enough. just fail for simplicity */</span></span><br><span class="line">        str = <span class="string">"SERVER_ERROR output line too long"</span>;</span><br><span class="line">        len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;wbuf, str, len); <span class="comment">// scr: ----------------&gt; 3)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;wbuf + len, <span class="string">"\r\n"</span>, <span class="number">2</span>);</span><br><span class="line">    c-&gt;wbytes = len + <span class="number">2</span>;</span><br><span class="line">    c-&gt;wcurr = c-&gt;wbuf;</span><br><span class="line">    </span><br><span class="line">    conn_set_state(c, conn_write); <span class="comment">// scr: ------------&gt; 4)</span></span><br><span class="line">    c-&gt;write_and_go = conn_new_cmd; <span class="comment">// scr: -----------&gt; 5)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:out_string</text></center><p>1) Initialize the <code>iov</code>. the mechanism and <a href="/understanding-memcached-source-code-VIII/#add-msghdr">add_msghdr</a> has been discussed in the <a href="/understanding-memcached-source-code-VIII/">last post</a></p><p>2) Calculate string length, and be paranoid for survival.</p><p>3) Populate <code>wbuf</code> with the output string and point <code>wcurr</code> to <code>wbuf</code>.</p><p>4) Indicate the next <strong>state</strong> <code>conn_write</code>.</p><p>5) Set the last <strong>state</strong> to <code>conn_new_cmd</code> and form the “loop”.</p><h2 id="conn-write"><a href="#conn-write" class="headerlink" title="conn_write"></a>conn_write</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_write:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * We want to write out a simple response. If we haven't already,</span></span><br><span class="line"><span class="comment">             * assemble it into a msgbuf list (this will be a single-entry</span></span><br><span class="line"><span class="comment">             * list for TCP or a two-entry list for UDP).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;iovused == <span class="number">0</span> || (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;iovused == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (add_iov(c, c-&gt;wcurr, c-&gt;wbytes) != <span class="number">0</span>) &#123; <span class="comment">// scr: ---&gt; 1)</span></span><br><span class="line">                    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Couldn't build response\n"</span>);</span><br><span class="line">                    conn_set_state(c, conn_closing);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* fall through... */</span></span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">...<span class="comment">// scr: discussed</span></span><br><span class="line">            <span class="keyword">switch</span> (transmit(c)) &#123;</span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_COMPLETE:</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;state == conn_mwrite) &#123;</span><br><span class="line">...<span class="comment">// scr: discussed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;state == conn_write) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c-&gt;write_and_free) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    conn_set_state(c, c-&gt;write_and_go); <span class="comment">// scr: -------&gt; 2)</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: discussed</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4507</text></center><p>1) Add the content of “write buffer” to the actual <code>iov</code>.</p><p>2) Pick up the <code>write_and_go</code> (i.e., conn_new_cmd) and set it to the next <strong>state</strong>.</p><p>Next, we send the</p><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>command to delete the entry we just added.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; delete test</span><br></pre></td></tr></table></figure><p>And the output this time is</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">28: going from conn_read to conn_parse_cmd</span><br><span class="line">&lt;28 delete test</span><br><span class="line">&gt; FOUND KEY test</span><br><span class="line">&gt;28 DELETED</span><br><span class="line">28: going from conn_parse_cmd to conn_write</span><br><span class="line">28: going from conn_write to conn_new_cmd</span><br><span class="line">28: going from conn_new_cmd to conn_waiting</span><br><span class="line">28: going from conn_waiting to conn_read</span><br></pre></td></tr></table></figure><p>Like <a href="#create">add</a> the entry point of this command (after parsed) is <a href="/understanding-memcached-source-code-VI/#process-delete-command">process_delete_command</a> which has been fully covered in <a href="/understanding-memcached-source-code-VI">LRU III</a>. Furthermore, <code>out_string</code> is called within <code>process_delete_command</code> to trigger the <strong>state</strong> switches from <code>conn_write</code>, and back to <code>conn_new_cmd</code>.</p><h1 id="To-go"><a href="#To-go" class="headerlink" title="To go"></a>To go</h1><p><img src="/gallery/memcached-state-machine.png" alt="Memcached state machine"></p>]]></content>
    
    <summary type="html">
    
      We continue examining the other two operations, i.e., create and delete, in the event driven context. As usual, we start with a command sent to a Memcached server. In fact, most of the logic involved in this post has been discussed before such as in LRU III and Event Driven II. Hence this post will only resolve the missing parts and linking points.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="socket" scheme="https://holmeshe.me/tags/socket/"/>
    
      <category term="event driven" scheme="https://holmeshe.me/tags/event-driven/"/>
    
      <category term="state machine" scheme="https://holmeshe.me/tags/state-machine/"/>
    
      <category term="memecached" scheme="https://holmeshe.me/tags/memecached/"/>
    
  </entry>
  
  <entry>
    <title>理解 Memcached 源码 - LRU I</title>
    <link href="https://holmeshe.me/cn/understanding-memcached-source-code-IV/"/>
    <id>https://holmeshe.me/cn/understanding-memcached-source-code-IV/</id>
    <published>2019-05-17T22:28:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<p>多半情况下，<strong>LRU</strong> 会和 哈希表一起使用，然后我们把这个组合称为</p><h1 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h1><p>在 <strong>LRU缓存</strong> 中，哈希表提供了快速随机访问对象的能力；而<strong>LRU</strong>（算法）则用于淘汰<strong>很久没用</strong> (<strong>least recently used</strong>) 的对象，来避免缓存无限增加。我们先大致看下 <strong>LRU</strong> 组成。</p><a id="more"></a><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>从技术上来说，<strong>LRU</strong> 算法是在链表上完成的 - 当一个表项被使用（访问或更新），<strong>LRU</strong> 会先做移除，然后把它重新插入到表头。这样，越接近表尾的对象就是 <strong>越久没使用</strong> (<strong>least recently used</strong>)，淘汰起来比较简单。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>链表是不支持快速的随机访问的，所以需要和 <strong>哈希表</strong> 一起使用。之前我们之前已经读过，<strong>板</strong> 子系统的空闲列表是通过链表把 <strong>板</strong> 里的 <strong>块</strong> (chuck) 串起来形成的。在 <strong>LRU缓存</strong> 里也差不多，而这次用链表串起来的是表项。大致看起来是这样：</p><p><img src="/gallery/lru.png" alt="hash map perspective"></p><p>从另外一个维度看起来可能会更直观一点：</p><p><img src="/gallery/lru-linked-list.png" alt="linked list perspective"></p><h1 id="核心数据结构-item"><a href="#核心数据结构-item" class="headerlink" title="核心数据结构 - item"></a>核心数据结构 - item</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protected by LRU locks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">/* Rest are protected by an item lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">h_next</span>;</span>    <span class="comment">/* hash chain next */</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      time;       <span class="comment">/* least recent access */</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      exptime;    <span class="comment">/* expire time */</span></span><br><span class="line">    <span class="keyword">int</span>             nbytes;     <span class="comment">/* size of data */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  refcount;</span><br><span class="line">    <span class="keyword">uint8_t</span>         nsuffix;    <span class="comment">/* length of flags-and-length string */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         nkey;       <span class="comment">/* key length, w/terminating null and padding */</span></span><br><span class="line">    <span class="comment">/* this odd type prevents type-punning issues when we do</span></span><br><span class="line"><span class="comment">     * the little shuffle to save space when not using CAS. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">        <span class="keyword">char</span> end; <span class="comment">// scr: flexible array member indicating the item header "end"</span></span><br><span class="line">    &#125; data[];</span><br><span class="line">    <span class="comment">/* if it_flags &amp; ITEM_CAS we have 8 bytes CAS */</span></span><br><span class="line">    <span class="comment">/* then null-terminated key */</span></span><br><span class="line">    <span class="comment">/* then " flags length\r\n" (no terminating null) */</span></span><br><span class="line">    <span class="comment">/* then data with terminating \r\n (no terminating null; it's binary!) */</span></span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@item.c</text></center><h2 id="使用到的字段"><a href="#使用到的字段" class="headerlink" title="使用到的字段"></a>使用到的字段</h2><p><code>next</code>, <code>prev</code> - <strong>LRU 链表</strong> 指针, 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 初始化, 被 <a href="#item-link-q-add-to-linked-list">item_link_q</a>, <a href="#item-unlink-q-remove-from-linked-list">item_unlink_q</a> 使用。</p><p><code>h_next</code> - <em>hash 冲突链表</em> 的指针, 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 初始化, 被 <a href="#assoc-insert-add-to-hash-map">assoc_insert</a>, <a href="#assoc-delete-remove-from-hash-map">assoc_delete</a>, <a href="/understanding-memcached-source-code-II">多个模块 (LRU II)</a> 使用。</p><p><code>time</code> - 最后访问时间, 在 <a href="#do-item-link">do_item_link</a> 中设置, 被 <a href="/understanding-memcached-source-code-VI/#lru-pull-tail">lru_pull_tail (LRU III)</a> 使用。</p><p><code>exptime</code> - 超时时间（由请求参数指定）, 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 初始化, 被 <a href="/understanding-memcached-source-code-VI/#lru-pull-tail">lru_pull_tail (LRU III)</a> 使用。</p><p><code>nbytes</code> - 数据大小（由请求参数指定），在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>  初始化。</p><p><code>refcount</code> - 引用计数, 在 <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc (Slab III)</a> 初始化, 被 <a href="#do-item-link">do_item_link</a> 使用。</p><p><code>nsuffix</code> - 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 用 <code>item_make_header</code> 初始化。</p><p><code>it_flags</code> - 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 初始化, 被 <a href="#do-item-link">do_item_link</a>, <a href="#do-item-unlink">do_item_unlink</a> 使用。</p><p><code>slabs_clsid</code> - 当前对象存在的具体的 <strong>LRU 链表</strong> , 被 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 初始化, 在 <a href="#item-link-q-add-to-linked-list">item_link_q</a>, <a href="#item-unlink-q-remove-from-linked-list">item_unlink_q</a> 使用。</p><p><code>nkey</code> - 键大小, 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 中计算, 被 <a href="#assoc-delete-remove-from-hash-map">assoc_delete</a> 使用。</p><h2 id="块的内存布局"><a href="#块的内存布局" class="headerlink" title="块的内存布局"></a>块的内存布局</h2><p>我们在 <a href="/understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a> 提到过 <strong>块</strong>。这次我们直接通过数据结构来看下它的构造。</p><p><img src="/gallery/item-chunk.png" alt="item chunk"></p><p>下面我们来读直接操作 <strong>LRU</strong> 的相关代码。</p><h1 id="do-item-link"><a href="#do-item-link" class="headerlink" title="do_item_link"></a>do_item_link</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_item_link</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123; <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">    it-&gt;it_flags |= ITEM_LINKED;                <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">    it-&gt;time = current_time;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate a new CAS ID on link. */</span></span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">    assoc_insert(it, hv);                       <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    item_link_q(it);                            <span class="comment">// scr: -------------------&gt; 4)</span></span><br><span class="line">    refcount_incr(&amp;it-&gt;refcount);               <span class="comment">// scr: -------------------&gt; 5)</span></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_link@item.c</text></center><p>1) 正常理解， <code>hv</code> 应该就是哈希值 “hashed value” 的缩写。</p><p>2) 设置 <code>it-&gt;it_flags</code> 的 <code>ITEM_LINKED</code> 标志, 然后将当前时间赋值给 <code>it-&gt;time</code>。</p><p class="back"><br>The field <code>it_flags</code> is used in <a href="/understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a> and <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc</a><br></p><p>3) 将 <strong>对象</strong> 添加到哈系表。</p><p>4) 将 <strong>对象</strong> 添加到链表。</p><p>5) 递增 <em>reference count</em>。</p><p class="back"><br>这个字段的初始值是 <code>1</code>，<a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc</a><br></p><p>要注意 <em>引用计数</em> 代表了有几个子模块同时在使用该资源。这个字段是决定是否回收该资源的关键参考 （在这里，<strong>对象</strong> 同时被 <strong>板</strong> 和 <strong>LRU</strong> 在使用）。我在 <a href="/cpp-pointers/">另一篇文章</a> 里详细讨论了C++里相似的机制。</p><h2 id="item-link-q-添加至链表"><a href="#item-link-q-添加至链表" class="headerlink" title="item_link_q - 添加至链表"></a>item_link_q - 添加至链表</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_link_q">item_link_q</a> 是主力函数 <code>do_item_link_q</code> 的线程安全的简单包装。<br><br><div id="item_link_q" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">item_link_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">    do_item_link_q(it);</span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_link_q@item.c</text></center><p></p></div><p></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_item_link_q</span><span class="params">(item *it)</span> </span>&#123; <span class="comment">/* item is the new head */</span></span><br><span class="line">    item **head, **tail;</span><br><span class="line">    assert((it-&gt;it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    head = &amp;heads[it-&gt;slabs_clsid];           <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">    tail = &amp;tails[it-&gt;slabs_clsid];</span><br><span class="line">    assert(it != *head);</span><br><span class="line">    assert((*head &amp;&amp; *tail) || (*head == <span class="number">0</span> &amp;&amp; *tail == <span class="number">0</span>));</span><br><span class="line">    it-&gt;prev = <span class="number">0</span>;                             <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">    it-&gt;next = *head;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it;</span><br><span class="line">    *head = it;</span><br><span class="line">    <span class="keyword">if</span> (*tail == <span class="number">0</span>) *tail = it;</span><br><span class="line">    sizes[it-&gt;slabs_clsid]++;                 <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_link_q@item.c</text></center><p>1) 从对应的 <strong>LRU 链表</strong> （由<code>slabs_clsid</code>指定）获取 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">head</a> 和 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">tail</a>。注意 <code>slabs_clsid</code> 是用队列类型加过盐的，所以每个 <strong>板组</strong> 可能会包含复数个列表。</p><p>2) 标准动作，”添加表头项”。</p><p>3) 增加全局的数组 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">大小</a>。</p><div id="globals" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item *heads[LARGEST_ID];</span><br><span class="line"><span class="keyword">static</span> item *tails[LARGEST_ID];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> sizes[LARGEST_ID];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item.c:59</text></center><br></div><h2 id="assoc-insert-添加至哈希表"><a href="#assoc-insert-添加至哈希表" class="headerlink" title="assoc_insert - 添加至哈希表"></a>assoc_insert - 添加至哈希表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">assoc_insert</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123; <span class="comment">// scr: again, hv -&gt; hash value</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;h_next = primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr:  1)</span></span><br><span class="line">        primary_hashtable[hv &amp; hashmask(hashpower)] = it;         // scr:  2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_insert@assoc.c</text></center><p>1) 冲突处理。没冲突？将 <code>h_next</code> 直接设置为 <code>null</code>。</p><p>2) 将 <strong>对象</strong> 添加到 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#primary_hashtable">primary_hashtable</a> 的桶。</p><div id="primary_hashtable" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> item** primary_hashtable = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc.c:42</text></center><br></div><p>扩容的逻辑先留个坑，<a href="/understanding-memcached-source-code-V/#Scale-up-amp-entry-migration">下篇</a> 再来讲。</p><h1 id="do-item-unlink"><a href="#do-item-unlink" class="headerlink" title="do_item_unlink"></a>do_item_unlink</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_unlink</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it-&gt;nkey, it-&gt;nbytes);</span><br><span class="line">    <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_LINKED;         <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">        assoc_delete(ITEM_key(it), it-&gt;nkey, hv); <span class="comment">// scr: ---------------&gt; 2)</span></span><br><span class="line">        item_unlink_q(it);                    <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">        do_item_remove(it);                   <span class="comment">// scr: -------------------&gt; *)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@item.c</text></center><p>1) 清除 <code>it-&gt;it_flags</code> 的 <code>ITEM_LINKED</code> 位。</p><p>2) 从哈希表移除 <strong>对象</strong>。</p><p>3) 从链表移除 <strong>对象</strong>。</p><p>*) 实际释放 <strong>对象</strong> 的逻辑后面会讲。</p><h2 id="item-unlink-q-从链表移除"><a href="#item-unlink-q-从链表移除" class="headerlink" title="item_unlink_q - 从链表移除"></a>item_unlink_q - 从链表移除</h2><p>同上，<a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_unlink_q">item_unlink_q</a> 只是一个对于实调函数 <code>do_item_unlink_q</code> 线程安全的简单封装。</p><div id="item_unlink_q" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">item_link_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">    do_item_link_q(it);</span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_unlink_q@item.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_item_unlink_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    item **head, **tail;</span><br><span class="line">    head = &amp;heads[it-&gt;slabs_clsid];           <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">    tail = &amp;tails[it-&gt;slabs_clsid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*head == it) &#123;                        <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">        assert(it-&gt;prev == <span class="number">0</span>);</span><br><span class="line">        *head = it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*tail == it) &#123;</span><br><span class="line">        assert(it-&gt;next == <span class="number">0</span>);</span><br><span class="line">        *tail = it-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(it-&gt;next != it);</span><br><span class="line">    assert(it-&gt;prev != it);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;prev) it-&gt;prev-&gt;next = it-&gt;next;</span><br><span class="line">    sizes[it-&gt;slabs_clsid]--;                 <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink_q@item.c</text></center><p>1) 同样, 获取 由 <code>slabs_clsid</code> 指定的 <strong>LUR 链表</strong> 的 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">head</a> 和 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">tail</a>。 </p><p>2) 标准的 “移除链表项” 操作。</p><p>3) 减少全局的数组 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">大小</a>。</p><div id="globals1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item *heads[LARGEST_ID];</span><br><span class="line"><span class="keyword">static</span> item *tails[LARGEST_ID];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> sizes[LARGEST_ID];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item.c:59</text></center><br></div><h2 id="assoc-delete-从哈希表移除"><a href="#assoc-delete-从哈希表移除" class="headerlink" title="assoc_delete - 从哈希表移除"></a>assoc_delete - 从哈希表移除</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item** _hashitem_before (<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv) &#123;</span><br><span class="line">    item **pos;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = &amp;primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr: -----&gt; 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*pos &amp;&amp; ((nkey != (*pos)-&gt;nkey) || <span class="built_in">memcmp</span>(key, ITEM_key(*pos), nkey))) &#123;</span><br><span class="line">        pos = &amp;(*pos)-&gt;h_next; <span class="comment">// scr: ----------------------------------&gt; 2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assoc_delete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    item **before = _hashitem_before(key, nkey, hv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*before) &#123;</span><br><span class="line">        item *nxt;</span><br><span class="line">...</span><br><span class="line">        nxt = (*before)-&gt;h_next; <span class="comment">// scr: --------------------------------&gt; 3)</span></span><br><span class="line">        (*before)-&gt;h_next = <span class="number">0</span>;   <span class="comment">/* probably pointless, but whatever. */</span></span><br><span class="line">        *before = nxt; <span class="comment">// scr: ------------------------------------------&gt; 4)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Note:  we never actually get here.  the callers don't delete things</span></span><br><span class="line"><span class="comment">       they can't find. */</span></span><br><span class="line">    assert(*before != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_delete@assoc.c</text></center><p>1) 通过 <code>hv</code> 获取桶。</p><p>2) 遍历冲突链表并比较 <code>key</code>。注意这里的返回值是 <strong>指定元素上一个元素的 <code>next</code> 字段的地址</strong>。而当没有冲突时，这个地址就是桶本身。</p><p>3) 将找到的下一个元素赋值给 <code>nxt</code>。</p><p>4) 更新 <strong>指定元素上一个元素的 <code>next</code> 字段</strong>。</p><h1 id="打包带走"><a href="#打包带走" class="headerlink" title="打包带走"></a>打包带走</h1><p>试下<a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">这个</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多半情况下，&lt;strong&gt;LRU&lt;/strong&gt; 会和 哈希表一起使用，然后我们把这个组合称为&lt;/p&gt;
&lt;h1 id=&quot;LRU-缓存&quot;&gt;&lt;a href=&quot;#LRU-缓存&quot; class=&quot;headerlink&quot; title=&quot;LRU 缓存&quot;&gt;&lt;/a&gt;LRU 缓存&lt;/h1&gt;&lt;p&gt;在 &lt;strong&gt;LRU缓存&lt;/strong&gt; 中，哈希表提供了快速随机访问对象的能力；而&lt;strong&gt;LRU&lt;/strong&gt;（算法）则用于淘汰&lt;strong&gt;很久没用&lt;/strong&gt; (&lt;strong&gt;least recently used&lt;/strong&gt;) 的对象，来避免缓存无限增加。我们先大致看下 &lt;strong&gt;LRU&lt;/strong&gt; 组成。&lt;/p&gt;
    
    </summary>
    
      <category term="Memcached 源码分析" scheme="https://holmeshe.me/categories/Memcached-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="LRU" scheme="https://holmeshe.me/tags/LRU/"/>
    
      <category term="源码" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码分析" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="缓存" scheme="https://holmeshe.me/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>理解 Memcached 源码 - Slab III</title>
    <link href="https://holmeshe.me/cn/understanding-memcached-source-code-III/"/>
    <id>https://holmeshe.me/cn/understanding-memcached-source-code-III/</id>
    <published>2019-03-24T02:30:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<p>上次我们看完了内存分配，以及形成待分配列表（<em>free list</em>，即<code>slots</code>）的过程。本篇我们继续查看如何使用建立好的数据结构来分配/回收块内存，并将它们用于存储<strong>对象</strong>。</p><h1 id="板配给"><a href="#板配给" class="headerlink" title="板配给"></a>板配给</h1><p>首先，我们来看</p><h2 id="do-slabs-alloc"><a href="#do-slabs-alloc" class="headerlink" title="do_slabs_alloc"></a>do_slabs_alloc</h2><a id="more"></a><p class="back"><br>这个函数对应讨论过的<a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>.<br></p><p>这里<code>do_slabs_alloc</code>的“公有”接口是<a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_alloc">slabs_alloc</a>。<a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_alloc">slabs_alloc</a>除了提供了对外接口外，还对核心数据结构加了线程锁以保证此函数（在<strong>Memcached</strong>被配置为多线程时，<a href="#" onclick="return false;" data-toggle="collapse" data-target="#multithreaded">multithreaded</a>）线程安全。</p><div id="slabs_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">slabs_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">int</span> *total_chunks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;slabs_lock);</span><br><span class="line">    ret = do_slabs_alloc(size, id, total_chunks, flags);</span><br><span class="line">    pthread_mutex_unlock(&amp;slabs_lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_alloc@slabs.c</text></center><br></div><div id="multithreaded" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            settings.num_threads = atoi(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Number of threads must be greater than 0\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* There're other problems when you get above 64 threads.</span></span><br><span class="line"><span class="comment">             * In the future we should portably detect # of cores for the</span></span><br><span class="line"><span class="comment">             * default.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &gt; <span class="number">64</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting a high number of worker"</span></span><br><span class="line">                                <span class="string">"threads is not recommended.\n"</span></span><br><span class="line">                                <span class="string">" Set this value to the number of cores in"</span></span><br><span class="line">                                <span class="string">" your machine or less.\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5572</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">do_slabs_alloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">int</span> *total_chunks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p;</span><br><span class="line">    <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br><span class="line">    p = &amp;slabclass[id]; <span class="comment">// scr: ----------------------------------------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (total_chunks != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *total_chunks = p-&gt;slabs * p-&gt;perslab; <span class="comment">// scr: -----------------&gt; 2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* fail unless we have space at the end of a recently allocated page,</span></span><br><span class="line"><span class="comment">       we have something on our freelist, or we could allocate a new page */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sl_curr == <span class="number">0</span> &amp;&amp; flags != SLABS_ALLOC_NO_NEWPAGE) &#123; <span class="comment">// scr: --&gt; *)</span></span><br><span class="line">        do_slabs_newslab(id); <span class="comment">// scr: ----------------------------------&gt; 3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sl_curr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* return off our freelist */</span></span><br><span class="line">        it = (item *)p-&gt;slots; <span class="comment">// scr: ---------------------------------&gt; 4)</span></span><br><span class="line">        p-&gt;slots = it-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Kill flag and initialize refcount here for lock safety in slab</span></span><br><span class="line"><span class="comment">         * mover's freeness detection. */</span></span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_SLABBED; <span class="comment">// scr: -------------------------&gt; 5)</span></span><br><span class="line">        it-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">        p-&gt;sl_curr--;</span><br><span class="line">        ret = (<span class="keyword">void</span> *)it; <span class="comment">// scr: --------------------------------------&gt; 6)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_alloc@slabs.c</text></center><p>1）<code>id</code>代表 <strong>板组</strong>。之前提到过，不同大小的对象会用不同的 <strong>板组</strong> 来存储。换句话说，<code>id</code> 的值由<em>对象大小</em>决定。这个过程后面会讨论。</p><p>2）<code>total_chunks</code> 是出参，用于存储当前 <strong>板组</strong> 的空闲<em>内存块</em>（<em>memory chunk</em>），或者说是待分配列表里还有多少空位。<code>if (total_chunks != NULL)</code> 则说明这个是可选参数。</p><p>*）和字面意思一样，<code>SLABS_ALLOC_NO_NEWPAGE</code>（<code>flags</code>）即使在没有空闲内存块时也不会额外分配新的 <strong>板</strong> 来满足后续分配需要。这个选项并不属于<em>对象分配</em>的通常路径，所以暂时忽略。</p><p>3）没有空闲内存块时分配新 <strong>板</strong>。这里很容易看到<code>p-&gt;sl_curr</code> 表示空闲<em>内存块</em>的数量。这个变量的值会在每次调用这个函数时递减（看第5步）。</p><p class="back"><br>另一方面, 这个字段在<a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>里自增。 注意 <em>new slab</em> 在<a href="../understanding-memcached-source-code-II/#New-slab">这篇</a>也提到过。<br></p><p>4）从待分配列表（<em>free list</em>，即<em>slots</em>）表头干掉一个元素（<strong>f</strong>），并将其赋值给<code>it</code>。</p><p class="back"><br>在<a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>, 内存块也是从表头加入的。<br></p><p>5) 清除对应<em>内存块</em>(<strong>f</strong>)的<code>ITEM_SLABBED</code>标志，将引用次数设置为1，并且内存块的数量<code>p-&gt;sl_curr</code> 减少<code>1</code>。</p><p class="back"><br>同样，这个标志在<a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>中被设置。<br></p><p>6) 返回(<strong>f</strong>).</p><p>下面我们来看如何通过对象大小来决定id，对应的函数是</p><h2 id="slabs-clsid"><a href="#slabs-clsid" class="headerlink" title="slabs_clsid"></a>slabs_clsid</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">slabs_clsid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = POWER_SMALLEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; slabclass[res].size)</span><br><span class="line">        <span class="keyword">if</span> (res++ == power_largest)     <span class="comment">/* won't fit in the biggest slab */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_alloc@slabs.c</text></center><p><code>slabs_clsid</code> 主要由一个 <code>while</code> 循环组成，这个循环会渐次找到最小的 <strong>板组</strong> 来刚好达到申请对象的大小要求。这个函数是在 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_alloc">do_item_alloc</a> 中先于 <code>slabs_alloc</code> 被调用。 我们会在后面的文章中讨论 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_alloc">do_item_alloc</a>。</p><div id="do_item_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">do_item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">rel_time_t</span> exptime, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id = slabs_clsid(ntotal);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">        it = slabs_alloc(ntotal, id, &amp;total_chunks, <span class="number">0</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_alloc@items.c</text></center><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次我们看完了内存分配，以及形成待分配列表（&lt;em&gt;free list&lt;/em&gt;，即&lt;code&gt;slots&lt;/code&gt;）的过程。本篇我们继续查看如何使用建立好的数据结构来分配/回收块内存，并将它们用于存储&lt;strong&gt;对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;板配给&quot;&gt;&lt;a href=&quot;#板配给&quot; class=&quot;headerlink&quot; title=&quot;板配给&quot;&gt;&lt;/a&gt;板配给&lt;/h1&gt;&lt;p&gt;首先，我们来看&lt;/p&gt;
&lt;h2 id=&quot;do-slabs-alloc&quot;&gt;&lt;a href=&quot;#do-slabs-alloc&quot; class=&quot;headerlink&quot; title=&quot;do_slabs_alloc&quot;&gt;&lt;/a&gt;do_slabs_alloc&lt;/h2&gt;
    
    </summary>
    
      <category term="Memcached 源码分析" scheme="https://holmeshe.me/categories/Memcached-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="源码" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码分析" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>理解 Memcached 源码- Slab II</title>
    <link href="https://holmeshe.me/cn/understanding-memcached-source-code-II/"/>
    <id>https://holmeshe.me/cn/understanding-memcached-source-code-II/</id>
    <published>2019-03-23T22:23:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们继续看用于 <strong>板</strong> 的内存是如何分配的。</p><p>首先我们继续看 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init">slabs_init</a> 的两个实参。第一个是 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_maxbytes">settings.maxbytes</a> - 控制这个 <strong>Memcached</strong> 实例可以使用的总内存大小。在传入 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init">slabs_init</a> 之前，这个参数被赋值为全局变量 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#mem_limit">mem_limit</a>。</p><a id="more"></a><div id="slabs_init" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    mem_limit = limit; <span class="comment">// scr: here</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@memcached.c</text></center><br></div><div id="settings_maxbytes" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">  settings.maxbytes = <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">/* default is 64MB */</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">            settings.maxbytes = ((<span class="keyword">size_t</span>)atoi(optarg)) * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:210,5493</text></center><br></div><div id="mem_limit" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> mem_limit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:43</text></center><br></div><p>另外一个怎是 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#preallocate">preallocate</a>。它决定了是否为（各个）<strong>板组</strong> 预分配 内存。这个参数的值由 <code>L</code> 命令行参数来决定。</p><div id="preallocate" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="keyword">bool</span> preallocate = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span> :</span><br><span class="line">            <span class="keyword">if</span> (enable_large_pages() == <span class="number">0</span>) &#123;</span><br><span class="line">                preallocate = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot enable large pages on this system\n"</span></span><br><span class="line">                    <span class="string">"(There is no Linux support as of this version)\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5350,5597</text></center><br></div><p>下面我们来看 slabs 的内存分配函数。</p><h1 id="新建板"><a href="#新建板" class="headerlink" title="新建板"></a>新建板</h1><h2 id="do-slabs-newslab"><a href="#do-slabs-newslab" class="headerlink" title="do_slabs_newslab"></a>do_slabs_newslab</h2><p>具体来说，这个函数用于给 <strong>板组</strong> 分配大小为1M的内存块。而 <strong>板组</strong> 由参数 <code>id</code> 指定。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_slabs_newslab</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id]; <span class="comment">// scr: ----------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">slabclass_t</span> *g = &amp;slabclass[SLAB_GLOBAL_PAGE_POOL]; <span class="comment">// scr: ---------&gt; *)</span></span><br><span class="line">    <span class="keyword">int</span> len = settings.slab_reassign ? settings.item_size_max <span class="comment">// scr: ---&gt; 2)</span></span><br><span class="line">        : p-&gt;size * p-&gt;perslab;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mem_limit &amp;&amp; mem_malloced + len &gt; mem_limit &amp;&amp; p-&gt;slabs &gt; <span class="number">0</span> <span class="comment">// -&gt; 3)</span></span><br><span class="line">         &amp;&amp; g-&gt;slabs == <span class="number">0</span>)) &#123;</span><br><span class="line">        mem_limit_reached = <span class="literal">true</span>;</span><br><span class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((grow_slab_list(id) == <span class="number">0</span>) || <span class="comment">// scr: ----------------------------&gt; 4)</span></span><br><span class="line">        (((ptr = get_page_from_global_pool()) == <span class="literal">NULL</span>) &amp;&amp; <span class="comment">// scr: -------&gt; *)</span></span><br><span class="line">        ((ptr = memory_allocate((<span class="keyword">size_t</span>)len)) == <span class="number">0</span>))) &#123; <span class="comment">// scr: ---------&gt; 5)</span></span><br><span class="line"></span><br><span class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ptr, <span class="number">0</span>, (<span class="keyword">size_t</span>)len);</span><br><span class="line">    split_slab_page_into_freelist(ptr, id); <span class="comment">// scr: ---------------------&gt; 6)</span></span><br><span class="line"></span><br><span class="line">    p-&gt;slab_list[p-&gt;slabs++] = ptr; <span class="comment">// scr: -----------------------------&gt; 7)</span></span><br><span class="line">    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_newslab@slabs.c</text></center><p>1）<code>slabclass[id]</code> 是 <strong>板组</strong> 的数据结构。<a href="../understanding-memcached-source-code-I/#Module-initialization">上篇</a>讨论了这个数组的初始化。</p><p>2）<a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_slab_reassign">settings.slab_reassign</a> 决定是否启用 再平衡 策略。如果启用，未使用的 <strong>板</strong> 不会被立即释放，而是分配给其他 <strong>板组</strong> 使用，这就产生了一个问题，即所有 <strong>板组</strong> 都需要使用统一大小的 <strong>板</strong>。所以这个设置同时也决定了是否使用 <em>同种板</em> （大小为 <code>settings.item_size_max</code>，或者上述的1M），还是 <em>异种板</em> （<code>p-&gt;size * p-&gt;perslab</code>）。除了用命令行参数 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_slab_reassign">"slab_reassign"</a> 以外，<a href="#" onclick="return false;" data-toggle="collapse" data-target="#modern">"modern"</a> 也会设置这个值，而本文也会用1M作为 <strong>板</strong> 的大小。</p><div id="settings_slab_reassign" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    settings.slab_reassign = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> SLAB_REASSIGN:</span><br><span class="line">                settings.slab_reassign = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:238,5694</text></center><br></div><div id="modern" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> MODERN:</span><br><span class="line">                <span class="comment">/* Modernized defaults. Need to add equivalent no_* flags</span></span><br><span class="line"><span class="comment">                 * before making truly default. */</span></span><br><span class="line">                settings.slab_reassign = <span class="literal">true</span>;</span><br><span class="line">                settings.slab_automove = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5820</text></center><br></div><a href="#" id="nb_rebalancing" style="visibility: hidden"></a><p>N.b. *, <em>rebalancing mechanism</em> will be discussed later when we have a better understanding of the LRU module. </p><a href="#" id="do_slabs_newslab_mem_limit" style="visibility: hidden"></a><p>3）检查内存使用是否超出上线。</p><p>4）<a href="#" onclick="return false;" data-toggle="collapse" data-target="#grow_slab_list">grow_slab_list</a> 检查是否增长 <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slab_list</a>，如果需要，则增长之。</p><div id="grow_slab_list" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">grow_slab_list</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id];</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;slabs == p-&gt;list_size) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> new_size =  (p-&gt;list_size != <span class="number">0</span>) ? p-&gt;list_size * <span class="number">2</span> : <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">void</span> *new_list = <span class="built_in">realloc</span>(p-&gt;slab_list, new_size * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">        <span class="keyword">if</span> (new_list == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p-&gt;list_size = new_size;</span><br><span class="line">        p-&gt;slab_list = new_list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">grow_slab_list@slabs.c</text></center><br></div><p>5）<a href="#" onclick="return false;" data-toggle="collapse" data-target="#memory_allocate">memory_allocate</a> 是真正分配 <strong>板</strong> 内存的函数。如上述，这里的 <code>len</code> 是1M。</p><div id="memory_allocate" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">memory_allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* We are not using a preallocated large memory chunk */</span></span><br><span class="line">        ret = <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: when preallocate is set to true</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memory_allocate@slabs.c</text></center><br></div><p>6）<code>split_slab_page_into_freelist</code> 初始化 （或者是 free）刚刚分配的 <strong>板</strong> 内存用作对象存储。这个函数会在下一节讨论。</p><p>7) 将刚刚分配的 <strong>板</strong> 加入到 <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slab_list</a>.</p><p>下图总结了这个过程（我们想象 <code>do_slabs_newslab(n)</code> 被调用了两次）</p><p><img src="../../gallery/slab_alloc.png" alt="new slabs"></p><p>接下来我们来看在第6）步中一块 <strong>板</strong> 是如何被初始化的。</p><h2 id="split-slab-page-into-freelist"><a href="#split-slab-page-into-freelist" class="headerlink" title="split_slab_page_into_freelist"></a>split_slab_page_into_freelist</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_slab_page_into_freelist</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id];</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; p-&gt;perslab; x++) &#123;</span><br><span class="line">        do_slabs_free(ptr, <span class="number">0</span>, id);</span><br><span class="line">        ptr += p-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">split_slab_page_into_freelist@slabs.c</text></center><p>这个函数会遍历 <strong>板</strong> 里的所有 <strong>块</strong>（<a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.size</a>），然后调用 <code>do_slabs_free</code> 来初始化每个 <strong>块</strong> 的元数据。换一个说法，就是 “拆分 slab到待分配列表”-“split a slab into item free list”。你也许已经猜到了，这个 <em>待分配列表</em> 会被直接用于 <strong>对象</strong>分配，这个过程后面会详细讨论。</p><h2 id="do-slabs-free"><a href="#do-slabs-free" class="headerlink" title="do_slabs_free"></a>do_slabs_free</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_slabs_free</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p;</span><br><span class="line">    item *it;</span><br><span class="line">...</span><br><span class="line">    p = &amp;slabclass[id];</span><br><span class="line"></span><br><span class="line">    it = (item *)ptr;</span><br><span class="line">    it-&gt;it_flags = ITEM_SLABBED; <span class="comment">// scr: ---------------&gt; 1)</span></span><br><span class="line">    it-&gt;slabs_clsid = <span class="number">0</span>;</span><br><span class="line">    it-&gt;prev = <span class="number">0</span>; <span class="comment">// scr: ------------------------------&gt; 2)</span></span><br><span class="line">    it-&gt;next = p-&gt;slots;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it;</span><br><span class="line">    p-&gt;slots = it;</span><br><span class="line"></span><br><span class="line">    p-&gt;sl_curr++; <span class="comment">// scr: ------------------------------&gt; 3)</span></span><br><span class="line">    p-&gt;requested -= size;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_free@slabs.c</text></center><p>技术上讲，这个函数处理的 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item">元数据</a> 元数据存在于每个 <strong>块</strong>的开始。</p><div id="item" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protected by LRU locks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></span><br><span class="line">...</span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5820</text></center><br></div><p>1）初始化一些域。这里 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item">item</a> 是另一个核心数据结构，后续会讨论。</p><p>2）将 <strong>item</strong> 加入到上述的 待分配列表 ，并且更新链表表头，<a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slots</a>。</p><p>3）更新可分配项目数量，<a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.sl_curr</a>；并且更新 <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.requested</a> 负责统计。注意这里并没有真正的释放对象，所以传入的 <code>size</code> 是<code>0</code>。</p><p><img src="../../gallery/slab_free_list.png" alt="free list"></p><h1 id="板预分配"><a href="#板预分配" class="headerlink" title="板预分配"></a>板预分配</h1><p>下面我们来看 <code>do_slabs_newslab</code> 怎么使用。其中一个地方是之前看到过的 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init_1">slabs_init</a>（<code>preallocate</code> 设置为 <code>true</code>），</p><div id="slabs_init_1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (prealloc) &#123;</span><br><span class="line">        slabs_preallocate(power_largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@slabs.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slabs_preallocate</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> maxslabs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prealloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pre-allocate a 1MB slab in every size class so people don't get</span></span><br><span class="line"><span class="comment">       confused by non-intuitive "SERVER_ERROR out of memory"</span></span><br><span class="line"><span class="comment">       messages.  this is the most common question on the mailing</span></span><br><span class="line"><span class="comment">       list.  if you really don't want this, you can rebuild without</span></span><br><span class="line"><span class="comment">       these three lines.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = POWER_SMALLEST <span class="comment">/* scr: 1 */</span>; i &lt; MAX_NUMBER_OF_SLAB_CLASSES; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++prealloc &gt; maxslabs)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (do_slabs_newslab(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error while preallocating slab memory!\n"</span></span><br><span class="line">                <span class="string">"If using -L or other prealloc options, max memory must be "</span></span><br><span class="line">                <span class="string">"at least %d megabytes.\n"</span>, power_largest);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_preallocate@slabs.c</text></center><p>这个方法从<a href="#" onclick="return false;" data-toggle="collapse" data-target="#defines">POWER_SMALLEST</a>（1）开始遍历所有的  <a href="../understanding-memcached-source-code-I/#core_ds">slabclass</a>，然后给每个 <strong>板组</strong> 预分配一个 <strong>板</strong>。（下标为<a href="#" onclick="return false;" data-toggle="collapse" data-target="#defines">0th</a> 的 <strong>板组</strong> 是一个特殊的组，存储空闲的 <strong>板</strong> 用于上面提到的 <em>再平衡</em> 策略）。</p><div id="defines" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_SMALLEST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_LARGEST 256 <span class="comment">/* actual cap is 255 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLAB_GLOBAL_PAGE_POOL 0 <span class="comment">/* magic slab class for storing pages for reassignment */</span></span></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.h:88</text></center><br></div><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>和<a href="../understanding-memcached-source-code-I/#References">上文</a>一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们继续看用于 &lt;strong&gt;板&lt;/strong&gt; 的内存是如何分配的。&lt;/p&gt;
&lt;p&gt;首先我们继续看 &lt;a href=&quot;#&quot; onclick=&quot;return false;&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#slabs_init&quot;&gt;slabs_init&lt;/a&gt; 的两个实参。第一个是 &lt;a href=&quot;#&quot; onclick=&quot;return false;&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#settings_maxbytes&quot;&gt;settings.maxbytes&lt;/a&gt; - 控制这个 &lt;strong&gt;Memcached&lt;/strong&gt; 实例可以使用的总内存大小。在传入 &lt;a href=&quot;#&quot; onclick=&quot;return false;&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#slabs_init&quot;&gt;slabs_init&lt;/a&gt; 之前，这个参数被赋值为全局变量 &lt;a href=&quot;#&quot; onclick=&quot;return false;&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#mem_limit&quot;&gt;mem_limit&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Memcached 源码分析" scheme="https://holmeshe.me/categories/Memcached-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="source code analysis" scheme="https://holmeshe.me/tags/source-code-analysis/"/>
    
      <category term="源码" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码分析" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>理解 Memcached 源码- Slab I</title>
    <link href="https://holmeshe.me/cn/understanding-memcached-source-code-I/"/>
    <id>https://holmeshe.me/cn/understanding-memcached-source-code-I/</id>
    <published>2019-03-22T23:30:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<p>Slab分配器是这个缓存系统的核心，并在很大程度上决定了核心资源 - 内存 - 的利用效率。其它的三个部分，用来淘汰（超时）对象的LRU算法；和基于libevent的事件驱动；以及用于分布数据的一致性哈希，可以看作是围绕Slab来开发的。</p><p>在其他系统，比如内核，都能看到 Slab 分配器 的身影。无论它出现在哪里，都是为了对抗同一个性能问题，内存碎片。而本文就主要讨论 Slab 分配器 在memcached 中的实现（废话）。</p><p><strong>memcached version: 1.4.28</strong></p><p>首先我们来回答一些问题。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="啥是Slab"><a href="#啥是Slab" class="headerlink" title="啥是Slab"></a>啥是Slab</h2><p><strong>Slab</strong>翻译过来就是（一块）<strong>板</strong>，具体来说，它是是被预先分配好的，大小为1M的内存块。这些 <strong>板</strong> 可以被进一步分割成一些相同大小的 <strong>块</strong> (<strong>chunk</strong>)，对象就存写在每一个 <strong>块</strong> 上面。所有的 <strong>板</strong> 会根据所存储对象的大小分成 <strong>板组</strong>（<strong>slab class</strong>）。</p><h2 id="刚刚提到的内存碎片是啥"><a href="#刚刚提到的内存碎片是啥" class="headerlink" title="刚刚提到的内存碎片是啥"></a>刚刚提到的内存碎片是啥</h2><p>具体来说，<strong>板分配器</strong> 解决的其实是 内在碎片 （internal memory fragmentation）。这种碎片存在于分配的内存单元的内部。拿内核来说，内存的分配单元叫页（page），所有的内存分配的请求本质上都是在页里面拿走一块，同时产生的碎片也就自然产生于每页的内部了。</p><blockquote><p>和内在碎片不一样，外在碎片（external memory fragmentation）则存在于分配的内存单元之间。解决外在碎片的一般做法则是用buddy，就不在本文范围内了。</p></blockquote><p>我们再看下制造内存碎片过程，</p><p>1）malloc一堆小对象，</p><p>2）随机free一些上述小对象。</p><p>于是本来是整片的内存就会出现很多空洞，这些空洞，或者说碎片，因为太小而且分散，大概率永远无法被后续的malloc利用。</p><h2 id="内存碎片引起的问题"><a href="#内存碎片引起的问题" class="headerlink" title="内存碎片引起的问题"></a>内存碎片引起的问题</h2><p>继续往后说。这些碎片由于不能被 malloc 使用，基本也就和 内存泄漏 差不多了。引发的具体问题也差不多 - 定期重启。</p><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h2><p><strong>板分配器</strong> 并不消除内存碎片，而是将它们收敛起来，并锁定在某个固定的内存区域。具体来说，1）将大小相近的对象分<strong>组</strong>；2）同一<strong>组</strong>的的对象只会用对应的<strong>板组</strong>（<strong>slab class</strong>）来分配内存。</p><p>接下来看代码。</p><p><strong>reminder: memcached version is 1.4.28</strong></p><p>核心数据结构：</p><a href="#" id="core_ds" style="visibility: hidden"></a><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;      <span class="comment">/* sizes of items */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> perslab;   <span class="comment">/* how many items per slab */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *slots;           <span class="comment">/* list of item ptrs */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sl_curr;   <span class="comment">/* total free items in list */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> slabs;     <span class="comment">/* how many slabs were allocated for this class */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> **slab_list;       <span class="comment">/* array of slab pointers */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> list_size; <span class="comment">/* size of prev array */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> requested; <span class="comment">/* The number of requested bytes */</span></span><br><span class="line">&#125; <span class="keyword">slabclass_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">slabclass_t</span> slabclass[MAX_NUMBER_OF_SLAB_CLASSES];</span><br><span class="line"></span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabclass_t@slabs.c</text></center><h1 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h1><p>本节我们来看<code>slabs_init</code>，和 <code>slabclass[MAX_NUMBER_OF_SLAB_CLASSES]</code> 的初始化。 这个函数主要给 <code>slabclass_t.size ，和 slabclass_t.perslab</code> 赋值。第一个域表示 <code>Slab</code> 组 所对应的对象大小，第二个域则表示一个 <code>Slab</code> 上可以放多少个该类的对象。最后，<code>slabs_init</code> 是在系统初始化的过程被调用（如以下代码），</p><div id="snippet1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    assoc_init(settings.hashpower_init);</span><br><span class="line">    conn_init();</span><br><span class="line">    slabs_init(settings.maxbytes, settings.factor, preallocate,</span><br><span class="line">               use_slab_sizes ? slab_sizes : <span class="literal">NULL</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5977</text></center><br></div><p>在这个阶段，<a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_sizes">slab_sizes</a> 和 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_factor">settings.factor</a> 共同决定了后续逻辑的走向，并且确定各个 <strong>板组</strong> 所存储的对象大小，</p><div id="slab_sizes" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5372</text></center><br></div><div id="settings_factor" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.factor = <span class="number">1.25</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">settings_init@memcached.c:217</text></center><br></div><p>如果 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_sizes">slab_sizes</a> 不是 <code>NULL</code>, 用此数组的里面的值直接初始化各 <strong>板组</strong> 所对应的对象大小（支线a）；</p><p>反之，则用base size×n×settings.factor 来初始化上述的目标。这里 n 是 slabclass 的下标（支线b）。</p><p>除了写死的默认值，上述两个变量也能用 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet2">命令行参数赋值</a> 。</p><div id="snippet2" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">            settings.factor = atof(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.factor &lt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Factor must be greater than 1\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'o'</span>: <span class="comment">/* It's sub-opts time! */</span></span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> SLAB_SIZES:</span><br><span class="line">                <span class="keyword">if</span> (_parse_slab_sizes(subopts_value, slab_sizes)) &#123;</span><br><span class="line">                    use_slab_sizes = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5558, 5810</text></center><br></div><p>本函数的另外两个参数 <code>settings.maxbytes</code> 和 <code>preallocate</code> ，会在 <a href="../understanding-memcached-source-code-II">后续</a> 讨论。这里我们假设 <code>preallocate</code> 为 <code>false</code>，并忽略其对应的逻辑。</p><p>下面我们来看 <code>slabs_init</code> 本身。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = POWER_SMALLEST <span class="comment">/* scr: 1 */</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(item) + settings.chunk_size; <span class="comment">// scr: ---------&gt; b 1)</span></span><br><span class="line">...</span><br><span class="line">    <span class="built_in">memset</span>(slabclass, <span class="number">0</span>, <span class="keyword">sizeof</span>(slabclass));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (++i &lt; MAX_NUMBER_OF_SLAB_CLASSES<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slab_sizes != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: -----------------------------------&gt; a 1)</span></span><br><span class="line">            <span class="keyword">if</span> (slab_sizes[i<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            size = slab_sizes[i<span class="number">-1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt;= settings.item_size_max / factor) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Make sure items are always n-byte aligned */</span></span><br><span class="line">        <span class="keyword">if</span> (size % CHUNK_ALIGN_BYTES) <span class="comment">// scr: ---------------------------------&gt; 2)</span></span><br><span class="line">            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);</span><br><span class="line"></span><br><span class="line">        slabclass[i].size = size;</span><br><span class="line">        slabclass[i].perslab = settings.item_size_max / slabclass[i].size; <span class="comment">// -&gt; 3)</span></span><br><span class="line">        <span class="keyword">if</span> (slab_sizes == <span class="literal">NULL</span>)</span><br><span class="line">            size *= factor; <span class="comment">// scr: -----------------------------------------&gt; b 4)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"slab class %3d: chunk size %9u perslab %7u\n"</span>,</span><br><span class="line">                    i, slabclass[i].size, slabclass[i].perslab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scr: -------------------------------------------------------------------&gt; 5)</span></span><br><span class="line">    power_largest = i;</span><br><span class="line">    slabclass[power_largest].size = settings.item_size_max;</span><br><span class="line">    slabclass[power_largest].perslab = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@slabs.c</text></center><h2 id="支线-a"><a href="#支线-a" class="headerlink" title="支线 a"></a>支线 a</h2><p>1) 使用 <code>slab_sizes</code> 里面的值；</p><p>2) 将 <code>size</code> 用 <code>CHUNK_ALIGN_BYTES</code> 对其，并赋值给 <code>slabclass[i].size</code>；</p><p>3) 计算 <code>slabclass[i].perslab</code>;</p><p>5) 用 <code>settings.item_size_max</code> 初始化最后一个 <strong>板组</strong>。</p><p>这里要注意 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_item_size_max">settings.item_size_max</a> 是 <strong>slab</strong> 本身的大小，也即是 <strong>memcached</strong> 能存的最大对象。类似的，<a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_item_size_max">settings.item_size_max</a> 也可以在 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet3">运行时</a> 确定</p><div id="settings_item_size_max" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.item_size_max = <span class="number">1024</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">settings_init@memcached.c:226</text></center><br></div><div id="snippet3" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">    buf = strdup(optarg);</span><br><span class="line">    unit = buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="string">'k'</span> || unit == <span class="string">'m'</span> ||</span><br><span class="line">        unit == <span class="string">'K'</span> || unit == <span class="string">'M'</span>) &#123;</span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        size_max = atoi(buf);</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="string">'k'</span> || unit == <span class="string">'K'</span>)</span><br><span class="line">            size_max *= <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="string">'m'</span> || unit == <span class="string">'M'</span>)</span><br><span class="line">            size_max *= <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        settings.item_size_max = size_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        settings.item_size_max = atoi(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Item max size cannot be less than 1024 bytes.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &gt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">128</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot set item size limit higher than 128 mb.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &gt; <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting item max size above 1MB is not"</span></span><br><span class="line">            <span class="string">" recommended!\n"</span></span><br><span class="line">            <span class="string">" Raising this limit increases the minimum memory requirements\n"</span></span><br><span class="line">            <span class="string">" and will decrease your memory efficiency.\n"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5626</text></center><br></div><h2 id="支线-b"><a href="#支线-b" class="headerlink" title="支线 b"></a>支线 b</h2><p>1) 用 <code>settings.chunk_size</code> 加上给每个对象附着的元数据（meta data）来计算基础大小（对象 <code>item</code> 会在后面讨论）；</p><p>2) 将 <code>size</code> 用 <code>CHUNK_ALIGN_BYTES</code> 对其，并赋值给 <code>slabclass[i].size</code>（同支线a）；</p><p>3) 计算 <code>slabclass[i].perslab</code>（同支线a）；</p><p>4) 用 <code>factor(settings.factor)</code> 计算下一个 <strong>板组</strong> 的大小；</p><p>5) 用 <code>settings.item_size_max</code> 初始化最后一个 <strong>板组</strong>。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://github.com/memcached/memcached/wiki" target="_blank" rel="noopener">memcached wiki</a></p><p><a href="http://gihyo.jp/dev/feature/01/memcached/0002" target="_blank" rel="noopener">第2回　memcachedのメモリストレージを理解する</a></p><p><a href="https://blog.csdn.net/initphp/article/details/44888555" target="_blank" rel="noopener">Memcached源码分析之存储机制Slabs（7）</a></p><p><a href="https://gokulvasanblog.wordpress.com/2016/07/11/understanding-malloc-part1/" target="_blank" rel="noopener">Understanding Malloc</a></p><p><a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html" target="_blank" rel="noopener">Ch8 - Slab Allocator</a></p><p><a href="https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a" target="_blank" rel="noopener">The Slab Allocator:An Object-Caching Kernel Memory Allocator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Slab分配器是这个缓存系统的核心，并在很大程度上决定了核心资源 - 内存 - 的利用效率。其它的三个部分，用来淘汰（超时）对象的LRU算法；和基于libevent的事件驱动；以及用于分布数据的一致性哈希，可以看作是围绕Slab来开发的。&lt;/p&gt;
&lt;p&gt;在其他系统，比如内核，都能看到 Slab 分配器 的身影。无论它出现在哪里，都是为了对抗同一个性能问题，内存碎片。而本文就主要讨论 Slab 分配器 在memcached 中的实现（废话）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;memcached version: 1.4.28&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们来回答一些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Memcached 源码分析" scheme="https://holmeshe.me/categories/Memcached-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="源码" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码分析" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code-Event Driven II</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-VIII/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-VIII/</id>
    <published>2019-01-27T20:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="#"><text style="color:black;font-weight:bold;">, II - this article</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>In classic <em>multithreading</em>, blocking I/O operations constrain the maximum number of requests a server can handle. Hence asynchronous <strong>event driven</strong> model is used to eliminate the throughput bottleneck. As such, the synchronous and potentially slow process is divided into logic segments that are free of I/O, and are executed asynchronously.</p><p>When it comes to asynchronization, extra space is required to store <em>context</em>s. This is because the logic segments, that could be associated with different <em>session</em>s, are executed in an interleaved way. For instance, in the case when asynchronization is implemented (emulated) using synchronous <em>multithreading</em>, the “extra space” is in the form of thread stack. Whilst <em>context</em>s are maintained in user land in <strong>event driven</strong>.</p><p><code>conn</code> is the representative of those <em>context</em>s in <strong>Memcached</strong>.</p><a id="more"></a><h1 id="Core-data-structure-conn"><a href="#Core-data-structure-conn" class="headerlink" title="Core data structure - conn"></a>Core data structure - conn</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> <span class="title">conn</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>    sfd;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> conn_states  state;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">event</span>;</span></span><br><span class="line">    short  ev_flags;</span><br><span class="line">    short  which;   <span class="comment">/** which events were just triggered */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>   *rbuf;   <span class="comment">/** buffer to read commands into */</span></span><br><span class="line">    <span class="keyword">char</span>   *rcurr;  <span class="comment">/** but if we parsed some already, this is where we stopped */</span></span><br><span class="line">    <span class="keyword">int</span>    rsize;   <span class="comment">/** total allocated size of rbuf */</span></span><br><span class="line">    <span class="keyword">int</span>    rbytes;  <span class="comment">/** how much data, starting from rcur, do we have unparsed */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>   *wbuf;</span><br><span class="line">    <span class="keyword">char</span>   *wcurr;</span><br><span class="line">    <span class="keyword">int</span>    wsize;</span><br><span class="line">    <span class="keyword">int</span>    wbytes;</span><br><span class="line">    <span class="comment">/** which state to go into after finishing current write */</span></span><br><span class="line">    <span class="keyword">enum</span> conn_states  write_and_go;</span><br><span class="line">    <span class="keyword">void</span>   *write_and_free; <span class="comment">/** free this memory after finishing writing */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>   *ritem;  <span class="comment">/** when we read in an item's value, it goes here */</span></span><br><span class="line">    <span class="keyword">int</span>    rlbytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data for the nread state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * item is used to hold an item structure created after reading the command</span></span><br><span class="line"><span class="comment">     * line of set/add/replace commands, but before we finished reading the actual</span></span><br><span class="line"><span class="comment">     * data. The data is read into ITEM_data(item) to avoid extra copying.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>   *item;     <span class="comment">/* for commands set/add/replace  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data for the swallow state */</span></span><br><span class="line">    <span class="keyword">int</span>    sbytes;    <span class="comment">/* how many bytes to swallow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data for the mwrite state */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line">    <span class="keyword">int</span>    iovsize;   <span class="comment">/* number of elements allocated in iov[] */</span></span><br><span class="line">    <span class="keyword">int</span>    iovused;   <span class="comment">/* number of elements used in iov[] */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">msglist</span>;</span></span><br><span class="line">    <span class="keyword">int</span>    msgsize;   <span class="comment">/* number of elements allocated in msglist[] */</span></span><br><span class="line">    <span class="keyword">int</span>    msgused;   <span class="comment">/* number of elements used in msglist[] */</span></span><br><span class="line">    <span class="keyword">int</span>    msgcurr;   <span class="comment">/* element in msglist[] being transmitted now */</span></span><br><span class="line">    <span class="keyword">int</span>    msgbytes;  <span class="comment">/* number of bytes in current msg */</span></span><br><span class="line"></span><br><span class="line">    item   **ilist;   <span class="comment">/* list of items to write out */</span></span><br><span class="line">    <span class="keyword">int</span>    isize;</span><br><span class="line">    item   **icurr;</span><br><span class="line">    <span class="keyword">int</span>    ileft;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> protocol protocol;   <span class="comment">/* which protocol this connection speaks */</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> request_addr_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *hdrbuf; <span class="comment">/* udp packet headers */</span></span><br><span class="line">    <span class="keyword">int</span>    hdrsize;   <span class="comment">/* number of headers' worth of space is allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>   noreply;   <span class="comment">/* True if the reply should not be sent. */</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    short cmd; <span class="comment">/* current command being processed */</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> keylen;</span><br><span class="line">    conn   *next;     <span class="comment">/* Used for generating a list of conn structures */</span></span><br><span class="line">    LIBEVENT_THREAD *thread; <span class="comment">/* Pointer to the thread object serving this connection */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Properties-in-discussion"><a href="#Properties-in-discussion" class="headerlink" title="Properties in discussion"></a>Properties in discussion</h2><p><code>fd</code> - the file descriptor a <strong>event</strong> is rooted. used by <a href="../understanding-memcached-source-code-VII/">last post</a></p><p><code>state</code> - the main focus of this post</p><p><code>rbuf</code> - <em>read buffer</em> address. used by <a href="#try-read-network">try_read_network</a></p><p><code>rcurr</code> - address of unprocessed data. used by <a href="#try-read-network">try_read_network</a></p><p><code>rsize</code> - current size of the <em>read buffer</em>. used by <a href="#try-read-network">try_read_network</a></p><p><code>rbytes</code> - size of data to be processed (it is also used as an indicator for leftover data in various places). initialised by <a href="#try-read-network">try_read_network</a>, updated by <a href="#process-get-command">process_get_command</a>, used by <a href="#try-read-command">try_read_command</a></p><p><code>last_cmd_time</code> - updated when start processing a command. used by <a href="#try-read-network">try_read_network</a></p><p><code>ilist</code> - the <strong>item</strong> list that is associated with the context; <code>icurr</code> and <code>ileft</code> indicate the current entry and number of entries left. used by <a href="#process-get-command">process_get_command</a>, <a href="#Finish-read">conn_release_items</a></p><p><code>iov</code> - the actual storage for pointers of output data, which is used by <code>msglist</code>; <code>iovsize</code>, and <code>iovused</code> are its allocated size and used size respectively. initialised by <a href="#try-read-command">process_command</a>, used by <a href="#add-iov">add_iov</a>, <a href="#add-iov">ensure_iov_space</a></p><p class="back"><br>Here the data structures (<code>struct msghdr</code> and <code>struct iovec</code>) is required by <a href="http://man7.org/linux/man-pages/man3/sendmsg.3p.html" target="_blank" rel="noopener">sendmsg</a>. The relevant text about the API is pasted bellow.<br></p><blockquote><p>The msg_iov and msg_iovlen fields of message specify zero or more buffers containing the data to be sent.  msg_iov points to an array of iovec structures; msg_iovlen shall be set to the dimension of this array. In each iovec structure, the iov_base field specifies a storage area and the iov_len field gives its size in bytes. Some of these sizes can be zero. The data from each storage area indicated by msg_iov is sent in turn.<br>…</p></blockquote><p><code>msglist</code> - the list that stores the <code>struct msghdr</code> themselves; <code>msgsize</code> and <code>msgused</code> are its allocated size and used size respectively; <code>msgbytes</code> indicates totall size of the output data size; <code>msgcurr</code> points to the index that has been processed (written).</p><blockquote><p>Yet nothing is bette than a chart to demonstrate the data structures and the layout in memory.</p></blockquote><a href="#" id="fig_core_ds" style="visibility: hidden"></a><p><img src="/gallery/msglist.png" alt="msglist &amp; iov"></p><h2 id="State-switch"><a href="#State-switch" class="headerlink" title="State switch"></a>State switch</h2><p>An <strong>event</strong> triggers cascading changes of <code>state</code>s which in turn invokes various procedures, before <strong>drive machine</strong> relinquishes control and waits for a new <strong>event</strong> arrival. In <a href="../understanding-memcached-source-code-VII/">last post</a>, we have seen this process on <em>dispatch thread</em>, in which </p><p>1) <code>conn_listening</code> is triggered by a new connection;</p><p>2) <a href="/understanding-memcached-source-code-VII/#dispatch-conn-new">dispatch_conn_new</a> is invoked, which transfer the new accepted <code>fd</code>, as well as succeeding <strong>event</strong>s to one of the <em>worker thread</em>s;</p><p>3) <em>dispatch thread</em> gives up CPU and waits for new “new connection” <strong>event</strong>s.</p><p>In this post, we are going to see more complex <em>state switch</em>es that effectively link together the procedures we discussed in <a href="/understanding-memcached-source-code-VI/">LRU III</a>,</p><p class="back"><br>The <strong>state</strong> of a given session is represented by <code>conn.state</code> of its associated <em>context</em>.<br></p><p>and this time we are going to adopt a similar approach as <a href="/understanding-memcached-source-code-VI/">LRU III</a>, i.e., sending <em>telnet commands</em> to a <strong>Memcached</strong> instance, to navigate the outermost layer of the <strong>Memcached</strong> application.</p><p class="back"><br>We will also switch ON the convenient <a href="#" onclick="return false;" data-toggle="collapse" data-target="#verbose">verbose</a> with <code>-vvv</code> to better observe the internal state transitions.<br></p><div id="verbose" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">    settings.verbose++;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5518</text></center><br></div><h1 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h1><p>Firstly (as usual) we <em>telnet</em> to the <strong>Memcached</strong> instance, and add some <strong>item</strong>s</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...<span class="comment">// add some items</span></span><br><span class="line">~telnet localhost <span class="number">11211</span></span><br><span class="line">Trying <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is '^]'.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Telnet input</text></center><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;<span class="number">36</span> <span class="keyword">new</span> <span class="keyword">auto</span>-negotiating client connection</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Server verbose</text></center><p class="back"><br>Here <code>36</code> is the accepted <code>fd</code>. As mentioned, the following operations will be on this <code>fd</code>.<br></p><p>Next we send the exact same read command to the <strong>Memcached</strong> instance as in <a href="/understanding-memcached-source-code-VI/#Read">LRU III</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; get test</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Telnet input</text></center><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">36</span>: going from conn_new_cmd to conn_waiting</span><br><span class="line"><span class="number">36</span>: going from conn_waiting to conn_read</span><br><span class="line"><span class="number">36</span>: going from conn_read to conn_parse_cmd</span><br><span class="line"><span class="number">36</span>: Client <span class="keyword">using</span> the ascii protocol</span><br><span class="line">&lt;<span class="number">36</span> get test</span><br><span class="line">&gt; FOUND KEY test</span><br><span class="line">&gt;<span class="number">36</span> sending key test</span><br><span class="line">&gt;<span class="number">36</span> END</span><br><span class="line"><span class="number">36</span>: going from conn_parse_cmd to conn_mwrite</span><br><span class="line"><span class="number">36</span>: going from conn_mwrite to conn_new_cmd</span><br><span class="line"><span class="number">36</span>: going from conn_new_cmd to conn_waiting</span><br><span class="line"><span class="number">36</span>: going from conn_waiting to conn_read</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Server verbose</text></center><p>As mentioned in <a href="/understanding-memcached-source-code-VII/#event-handler">last post</a>, the initial state of <em>worker thread</em>s is</p><h2 id="conn-new-cmd"><a href="#conn-new-cmd" class="headerlink" title="conn_new_cmd"></a>conn_new_cmd</h2><p>so we get started from here.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nreqs = settings.reqs_per_event; <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_new_cmd:</span><br><span class="line">            <span class="comment">/* Only process nreqs at a time to avoid starving other</span></span><br><span class="line"><span class="comment">               connections */</span></span><br><span class="line">            --nreqs; <span class="comment">// scr: ----------------------------&gt; 1)</span></span><br><span class="line">            <span class="keyword">if</span> (nreqs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                reset_cmd_handler(c); <span class="comment">// scr: -----------&gt; 2)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;c-&gt;thread-&gt;stats.mutex);</span><br><span class="line">                c-&gt;thread-&gt;stats.conn_yields++;</span><br><span class="line">                pthread_mutex_unlock(&amp;c-&gt;thread-&gt;stats.mutex);</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;rbytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">                &#125;</span><br><span class="line">                stop = <span class="literal">true</span>; <span class="comment">// scr: --------------------&gt; 3)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset_cmd_handler</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;cmd = <span class="number">-1</span>;</span><br><span class="line">    c-&gt;substate = bin_no_state;</span><br><span class="line">    <span class="keyword">if</span>(c-&gt;item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        item_remove(c-&gt;item);</span><br><span class="line">        c-&gt;item = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    conn_shrink(c);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;rbytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        conn_set_state(c, conn_parse_cmd); <span class="comment">// scr: -----&gt; 2a)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        conn_set_state(c, conn_waiting); <span class="comment">// scr: -------&gt; 2b)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4361 & reset_cmd_handler</text></center><p>1) <code>nreqs</code> (<a href="#" onclick="return false;" data-toggle="collapse" data-target="#reqs_per_event">settings.reqs_per_event</a>) is the maximum requests one <em>event loop</em> iteration should handle. Note that the threshold is needed because new connections will not be handled if one <em>event loop</em> iteration takes too long to complete. Note also that the connection being interrupted will be fired again and get the chance to enter the <strong>drive machine</strong> with a “read” event since the descriptor is set with <code>EV_PERSIST</code> in the <a href="/understanding-memcached-source-code-VII/#event-handler">last post</a>.</p><div id="reqs_per_event" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.reqs_per_event = <span class="number">20</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">    settings.reqs_per_event = atoi(optarg);</span><br><span class="line">    <span class="keyword">if</span> (settings.reqs_per_event == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Number of requests per event must be greater than 0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5545, 6112</text></center><br></div><p>2) Initializes the relevant properties in the <em>context</em> for a new command.</p><p>2a) If there are leftover data, then switch to <code>conn_parse_cmd</code> directly.</p><p>2b) If it is a fresh <em>session</em>, then switch to <code>conn_waiting</code>.</p><p>3) Yield the current iteration when the threshold is reached.</p><h2 id="conn-waiting"><a href="#conn-waiting" class="headerlink" title="conn_waiting"></a>conn_waiting</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_waiting:</span><br><span class="line">            <span class="keyword">if</span> (!update_event(c, EV_READ | EV_PERSIST)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Couldn't update event\n"</span>);</span><br><span class="line">                conn_set_state(c, conn_closing);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            conn_set_state(c, conn_read);</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4322</text></center><p>Simply reset the descriptor with the original flags (i.e., <code>EV_READ</code>, <code>EV_PERSIST</code>), update the state of the <em>context</em> to the next hop (<code>conn_read</code>), and relinquish the CPU.</p><h2 id="conn-read"><a href="#conn-read" class="headerlink" title="conn_read"></a>conn_read</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> conn_read:</span><br><span class="line">    res = IS_UDP(c-&gt;transport) ? try_read_udp(c) : try_read_network(c); <span class="comment">//1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">    <span class="keyword">case</span> READ_NO_DATA_RECEIVED:</span><br><span class="line">        conn_set_state(c, conn_waiting);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ_DATA_RECEIVED:</span><br><span class="line">        conn_set_state(c, conn_parse_cmd); <span class="comment">// scr: ---------------------&gt; 2)</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ_ERROR:</span><br><span class="line">        conn_set_state(c, conn_closing);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ_MEMORY_ERROR: <span class="comment">/* Failed to allocate more memory */</span></span><br><span class="line">        <span class="comment">/* State already set by try_read_network */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4334</text></center><p>1) Read from the file descriptor and save the data to the <em>context</em>.</p><p>2) Switch to the next state, <code>conn_parse_cmd</code>.</p><h3 id="try-read-network"><a href="#try-read-network" class="headerlink" title="try_read_network"></a>try_read_network</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> try_read_result <span class="title">try_read_network</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> try_read_result gotdata = READ_NO_DATA_RECEIVED;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span> num_allocs = <span class="number">0</span>;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;rcurr != c-&gt;rbuf) &#123; <span class="comment">// scr: -------------------------&gt; 1)</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;rbytes != <span class="number">0</span>) <span class="comment">/* otherwise there's nothing to copy */</span></span><br><span class="line">            memmove(c-&gt;rbuf, c-&gt;rcurr, c-&gt;rbytes);</span><br><span class="line">        c-&gt;rcurr = c-&gt;rbuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;rbytes &gt;= c-&gt;rsize) &#123; <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">            <span class="keyword">if</span> (num_allocs == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> gotdata;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num_allocs;</span><br><span class="line">            <span class="keyword">char</span> *new_rbuf = <span class="built_in">realloc</span>(c-&gt;rbuf, c-&gt;rsize * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (!new_rbuf) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            c-&gt;rcurr = c-&gt;rbuf = new_rbuf;</span><br><span class="line">            c-&gt;rsize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> avail = c-&gt;rsize - c-&gt;rbytes; <span class="comment">// scr: --------------&gt; 3)</span></span><br><span class="line">        res = read(c-&gt;sfd, c-&gt;rbuf + c-&gt;rbytes, avail);</span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">            gotdata = READ_DATA_RECEIVED;</span><br><span class="line">            c-&gt;rbytes += res;</span><br><span class="line">            <span class="keyword">if</span> (res == avail) &#123; <span class="comment">// scr: -----------------------&gt; 3a)</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// scr: --------------------------------&gt; 3b)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> READ_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123; <span class="comment">//src:3b)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> READ_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotdata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:try_read_network</text></center><p>Here the <code>while (1)</code> is used to handle logic flow for buffer expanding instead of loop.</p><p>1) Move <code>rcurr</code> to the beginning of the <em>read buffer</em>.</p><p>2) If the data size exceeds the <em>read buffer</em> size, try expanding the buffer (for at most 4 times).</p><p>3) Calculate the available buffer space for <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener">read</a>ing from the socket, and update <code>rbytes</code> accordingly.</p><p>3a) Goto 2) if the buffer is full.</p><p>3b) Return <code>READ_DATA_RECEIVED</code>, which switches the state to <code>conn_parse_cmd</code> in the <strong>state machine</strong> pass through.</p><h2 id="conn-parse-cmd"><a href="#conn-parse-cmd" class="headerlink" title="conn_parse_cmd"></a>conn_parse_cmd</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> conn_parse_cmd :</span><br><span class="line">    <span class="keyword">if</span> (try_read_command(c) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* wee need more data! */</span></span><br><span class="line">        conn_set_state(c, conn_waiting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:try_read_network</text></center><h3 id="try-read-command"><a href="#try-read-command" class="headerlink" title="try_read_command"></a>try_read_command</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_read_command</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">    assert(c-&gt;rcurr &lt;= (c-&gt;rbuf + c-&gt;rsize));</span><br><span class="line">    assert(c-&gt;rbytes &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;protocol == negotiating_prot || c-&gt;transport == udp_transport)  &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)c-&gt;rbuf[<span class="number">0</span>] == (<span class="keyword">unsigned</span> <span class="keyword">char</span>)PROTOCOL_BINARY_REQ) &#123;</span><br><span class="line">            c-&gt;protocol = binary_prot;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c-&gt;protocol = ascii_prot; <span class="comment">// scr: -------------------------&gt; 1)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123; <span class="comment">// scr: ---------------------------&gt; ~)</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%d: Client using the %s protocol\n"</span>, c-&gt;sfd,</span><br><span class="line">                    prot_text(c-&gt;protocol));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;protocol == binary_prot) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> *el, *cont;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;rbytes == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        el = <span class="built_in">memchr</span>(c-&gt;rcurr, <span class="string">'\n'</span>, c-&gt;rbytes); <span class="comment">// scr: ---------------&gt; 2)</span></span><br><span class="line">        <span class="keyword">if</span> (!el) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125;</span><br><span class="line">        cont = el + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((el - c-&gt;rcurr) &gt; <span class="number">1</span> &amp;&amp; *(el - <span class="number">1</span>) == <span class="string">'\r'</span>) &#123;</span><br><span class="line">            el--;</span><br><span class="line">        &#125;</span><br><span class="line">        *el = <span class="string">'\0'</span>; <span class="comment">// scr: -------------------------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">        assert(cont &lt;= (c-&gt;rcurr + c-&gt;rbytes));</span><br><span class="line"></span><br><span class="line">        c-&gt;last_cmd_time = current_time; <span class="comment">// scr: ----------------------&gt; 3)</span></span><br><span class="line">        process_command(c, c-&gt;rcurr); <span class="comment">// scr: -------------------------&gt; 4)</span></span><br><span class="line"></span><br><span class="line">        c-&gt;rbytes -= (cont - c-&gt;rcurr); <span class="comment">// scr: -----------------------&gt; 5)</span></span><br><span class="line">        c-&gt;rcurr = cont; <span class="comment">// scr: --------------------------------------&gt; 6)</span></span><br><span class="line"></span><br><span class="line">        assert(c-&gt;rcurr &lt;= (c-&gt;rbuf + c-&gt;rsize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:try_read_command</text></center><p>1) Determine the protocol type, in this case is <code>ascii_prot</code>.</p><p>~) Verbose message we saw in the beginning.</p><p>2) Trim all the <code>&#39;\n&#39;</code> and <code>&#39;\r&#39;</code> in the end, store the position of the command last character to <code>el</code>, and store the command end to <code>cont</code>.</p><p>3) Update <code>last_cmd_time</code>.</p><p>4) Call <a href="#" onclick="return false;" data-toggle="collapse" data-target="#process_command">process_command</a> which locates the “get” command and call <code>process_get_command</code>. In <a href="#" onclick="return false;" data-toggle="collapse" data-target="#process_command">process_command</a>, a) <code>tokenize_command</code> is a string parsing method that stores command (i.e., “get”) in <code>tokens[COMMAND_TOKEN]</code> and key (i.e., test) in <code>tokens[KEY_TOKEN]</code>; b) initialization of <code>msgcurr</code>, <code>msgused</code>, <code>iovused</code>; c) initialization other fields in <a href="#add-msghdr">add_msghdr</a>; and d) <a href="#process-get-command">process_get_command</a> is the next step.</p><div id="process_command" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">c-&gt;msgcurr = <span class="number">0</span>; <span class="comment">// scr: ---------------------------------------------&gt; b)</span></span><br><span class="line">c-&gt;msgused = <span class="number">0</span>;</span><br><span class="line">c-&gt;iovused = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (add_msghdr(c) != <span class="number">0</span>) &#123;</span><br><span class="line">    out_of_memory(c, <span class="string">"SERVER_ERROR out of memory preparing response"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ntokens = tokenize_command(command, tokens, MAX_TOKENS); <span class="comment">// scr: ----&gt; a)</span></span><br><span class="line"><span class="keyword">if</span> (ntokens &gt;= <span class="number">3</span> &amp;&amp;</span><br><span class="line">    ((<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"get"</span>) == <span class="number">0</span>) || </span><br><span class="line">     (<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"bget"</span>) == <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">    process_get_command(c, tokens, ntokens, <span class="literal">false</span>); <span class="comment">// scr: ---------&gt; c)</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:process_command</text></center><br></div><p>5) Update <code>rbytes</code> with the length of the command that has been processed (<code>cont - c-&gt;rcurr</code>).</p><p>6) Move the <code>rcurr</code> to the unprocessed data located at end of the command portion.</p><h3 id="add-msghdr"><a href="#add-msghdr" class="headerlink" title="add_msghdr"></a>add_msghdr</h3><p>Before the logic reaches <a href="#process-get-command">process_get_command</a>, an entry should be initialised in <code>msglist</code> for the current command.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_msghdr</span><span class="params">(conn *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;msgsize == c-&gt;msgused) &#123; <span class="comment">// scr: --------------------&gt; 1)</span></span><br><span class="line">        msg = <span class="built_in">realloc</span>(c-&gt;msglist, c-&gt;msgsize * <span class="number">2</span> * <span class="keyword">sizeof</span>(struct msghdr));</span><br><span class="line">        <span class="keyword">if</span> (! msg) &#123;</span><br><span class="line">            STATS_LOCK();</span><br><span class="line">            stats.malloc_fails++;</span><br><span class="line">            STATS_UNLOCK();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c-&gt;msglist = msg;</span><br><span class="line">        c-&gt;msgsize *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg = c-&gt;msglist + c-&gt;msgused; <span class="comment">// scr: ---------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this wipes msg_iovlen, msg_control, msg_controllen, and</span></span><br><span class="line"><span class="comment">       msg_flags, the last 3 of which aren't defined on solaris: */</span></span><br><span class="line">    <span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct msghdr)); <span class="comment">// scr: -------------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    msg-&gt;msg_iov = &amp;c-&gt;iov[c-&gt;iovused]; <span class="comment">// scr: ----------------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;request_addr_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;msgbytes = <span class="number">0</span>; <span class="comment">// scr: -----------------------------------&gt; 4)</span></span><br><span class="line">    c-&gt;msgused++; <span class="comment">// scr: --------------------------------------&gt; 5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_UDP(c-&gt;transport)) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">add_msghdr@memcached.c</text></center><p>1) Expand the <code>msglist</code> when required.</p><p>2) Point to the next empty entry in <code>msglist</code> with <code>msg</code>.</p><p>3) Initialise the entry pointed by <code>msg</code>. Here the critical operation is <code>msg-&gt;msg_iov = &amp;c-&gt;iov[c-&gt;iovused];</code> which links the <code>msglist</code> to the specific entry in <code>iov</code>. (<a href="#fig_core_ds">Figure - msglist &amp; iov</a>)</p><p>4) Initialise <code>msgbytes</code> to <code>0</code>.</p><p>5) Update <code>msgused</code> accordingly.</p><h3 id="process-get-command"><a href="#process-get-command" class="headerlink" title="process_get_command"></a>process_get_command</h3><p>We have seen this method in beginning of <a href="/understanding-memcached-source-code-VI/#process-get-command">LRU III</a>. This time, we will complete its pass through with the context of <strong>event driven</strong>.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">process_get_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">size_t</span> ntokens, <span class="keyword">bool</span> return_cas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">token_t</span> *key_token = &amp;tokens[KEY_TOKEN];</span><br><span class="line">    <span class="keyword">char</span> *suffix;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(key_token-&gt;length != <span class="number">0</span>) &#123; <span class="comment">// scr: -----------------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">            key = key_token-&gt;value;</span><br><span class="line">            nkey = key_token-&gt;length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nkey &gt; KEY_MAX_LENGTH) &#123;</span><br><span class="line">                out_string(c, <span class="string">"CLIENT_ERROR bad command line format"</span>);</span><br><span class="line">                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    item_remove(*(c-&gt;ilist + i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it = item_get(key, nkey, c); <span class="comment">// scr: ----------------&gt; 2)</span></span><br><span class="line">            <span class="keyword">if</span> (settings.detail_enabled) &#123;</span><br><span class="line">                stats_prefix_record_get(key, nkey, <span class="literal">NULL</span> != it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= c-&gt;isize) &#123; <span class="comment">// scr: --------------------&gt; 3)</span></span><br><span class="line">                    item **new_list = <span class="built_in">realloc</span>(c-&gt;ilist, <span class="keyword">sizeof</span>(item *) * c-&gt;isize * <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">if</span> (new_list) &#123;</span><br><span class="line">                        c-&gt;isize *= <span class="number">2</span>;</span><br><span class="line">                        c-&gt;ilist = new_list;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                        item_remove(it);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (return_cas)</span><br><span class="line">                &#123;</span><br><span class="line">...<span class="comment">// scr: cas</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  MEMCACHED_COMMAND_GET(c-&gt;sfd, ITEM_key(it), it-&gt;nkey,</span><br><span class="line">                                        it-&gt;nbytes, ITEM_get_cas(it));</span><br><span class="line">                  <span class="keyword">if</span> (add_iov(c, <span class="string">"VALUE "</span>, <span class="number">6</span>) != <span class="number">0</span> || <span class="comment">// scr: ---&gt; 4)</span></span><br><span class="line">                      add_iov(c, ITEM_key(it), it-&gt;nkey) != <span class="number">0</span> ||</span><br><span class="line">                      add_iov(c, ITEM_suffix(it), it-&gt;nsuffix + it-&gt;nbytes) != <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          item_remove(it);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: verbose &amp; stat</span></span><br><span class="line"></span><br><span class="line">                item_update(it); <span class="comment">// scr: ------------------------&gt; 5)</span></span><br><span class="line">                *(c-&gt;ilist + i) = it; <span class="comment">// scr: -------------------&gt; 6)</span></span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key_token++; <span class="comment">// scr: --------------------------------&gt; 1)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the command string hasn't been fully processed, get the next set</span></span><br><span class="line"><span class="comment">         * of tokens.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(key_token-&gt;value != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: ------------------&gt; 1)</span></span><br><span class="line">            ntokens = tokenize_command(key_token-&gt;value, tokens, MAX_TOKENS);</span><br><span class="line">            key_token = tokens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(key_token-&gt;value != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    c-&gt;icurr = c-&gt;ilist; <span class="comment">// scr: --------------------------------&gt; 6)</span></span><br><span class="line">    c-&gt;ileft = i; scr: ------------------------------------------&gt; <span class="number">6</span>)</span><br><span class="line">...<span class="comment">// scr: cas &amp; verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key_token-&gt;value != <span class="literal">NULL</span> || add_iov(c, <span class="string">"END\r\n"</span>, <span class="number">5</span>) != <span class="number">0</span></span><br><span class="line">        || (IS_UDP(c-&gt;transport) &amp;&amp; build_udp_headers(c) != <span class="number">0</span>)) &#123;</span><br><span class="line">        out_of_memory(c, <span class="string">"SERVER_ERROR out of memory writing get response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// scr: ----------------------------------------------&gt; 7)</span></span><br><span class="line">        conn_set_state(c, conn_mwrite);</span><br><span class="line">        c-&gt;msgcurr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_get_command@memcached.c</text></center><p>1) Iterate through key token array. Here we got one key token ‘test’.</p><p>2) Call <a href="/understanding-memcached-source-code-VI/#do-item-get">item_get</a> for the <strong>item</strong> pointer.</p><p>3) Increase the <code>ilist</code> size if it is full, and . Here <code>ilist</code> stores the <strong>item</strong> being processed. In the <a href="#Finish-read">end of the current command processing</a>,  this list is used to batch release the <strong>item</strong>s reference counts.</p><p>4) <code>add_iov</code> prepares the output of this session.</p><p>5) Call <a href="/understanding-memcached-source-code-VI/#do-item-update">item_update</a> to manipulate the <em>LRU</em> lists.</p><p>6) Link the <strong>item</strong> currently being processed to <code>ilist</code>, and update the associated fields.</p><p>7) Move on to the next state <a href="#conn-mwrite">conn_mwrite</a>.</p><h3 id="add-iov"><a href="#add-iov" class="headerlink" title="add_iov"></a>add_iov</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_iov</span><span class="params">(conn *c, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">m</span>;</span></span><br><span class="line">    <span class="keyword">int</span> leftover;</span><br><span class="line">    <span class="keyword">bool</span> limit_to_mtu;</span><br><span class="line"></span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = &amp;c-&gt;msglist[c-&gt;msgused - <span class="number">1</span>]; <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Limit UDP packets, and the first payloads of TCP replies, to</span></span><br><span class="line"><span class="comment">         * UDP_MAX_PAYLOAD_SIZE bytes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        limit_to_mtu = IS_UDP(c-&gt;transport) || (<span class="number">1</span> == c-&gt;msgused);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We may need to start a new msghdr if this one is full. */</span></span><br><span class="line">        <span class="keyword">if</span> (m-&gt;msg_iovlen == IOV_MAX ||</span><br><span class="line">            (limit_to_mtu &amp;&amp; c-&gt;msgbytes &gt;= UDP_MAX_PAYLOAD_SIZE)) &#123;</span><br><span class="line">            add_msghdr(c);</span><br><span class="line">            m = &amp;c-&gt;msglist[c-&gt;msgused - <span class="number">1</span>]; <span class="comment">// scr: ---------------&gt; 7)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ensure_iov_space(c) != <span class="number">0</span>) <span class="comment">// scr: ----------------------&gt; 2)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the fragment is too big to fit in the datagram, split it up */</span></span><br><span class="line">        <span class="keyword">if</span> (limit_to_mtu &amp;&amp; len + c-&gt;msgbytes &gt; UDP_MAX_PAYLOAD_SIZE) &#123;</span><br><span class="line">            leftover = len + c-&gt;msgbytes - UDP_MAX_PAYLOAD_SIZE; <span class="comment">//scr*)</span></span><br><span class="line">            len -= leftover;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftover = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m = &amp;c-&gt;msglist[c-&gt;msgused - <span class="number">1</span>]; <span class="comment">// scr: ------------------&gt; 1)</span></span><br><span class="line">        m-&gt;msg_iov[m-&gt;msg_iovlen].iov_base = (<span class="keyword">void</span> *)buf; <span class="comment">// scr: -&gt; 3)</span></span><br><span class="line">        m-&gt;msg_iov[m-&gt;msg_iovlen].iov_len = len;</span><br><span class="line"></span><br><span class="line">        c-&gt;msgbytes += len; <span class="comment">// scr: -------------------------------&gt; 4)</span></span><br><span class="line">        c-&gt;iovused++; <span class="comment">// scr: -------------------------------------&gt; 5)</span></span><br><span class="line">        m-&gt;msg_iovlen++; <span class="comment">// scr: ----------------------------------&gt; 6)</span></span><br><span class="line"></span><br><span class="line">        buf = ((<span class="keyword">char</span> *)buf) + len;</span><br><span class="line">        len = leftover;</span><br><span class="line">    &#125; <span class="keyword">while</span> (leftover &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">add_iov@memcached.c</text></center><p>This method initialised an entry on <code>iov</code> list and add it to the last in-use item in msglist (<a href="#fig_core_ds">Figure - msglist &amp; iov</a>).</p><p>1) Get the tail of the in use portion of <code>msglist</code>.</p><p>2) Expend <code>iov</code> if necessary.</p><p>3) Initialize the <code>iov_base</code> and <code>iov_len</code> fields within the <code>iov</code> entry. Note that the <code>msg_iov</code> has been linked to the position of specific entry in <code>iov</code>, hence operations on <code>msg_iov</code> change the content of <code>iov</code> as well.</p><p>4) Update <code>msgbytes</code> with the total <strong>item</strong> size.</p><p>5, 6) Update <code>iovused</code> and <code>msg_iovlen</code> accordingly.</p><p>7) Handle <strong>MTU</strong> with the assistance of <code>do while</code> loop.</p><h2 id="conn-mwrite"><a href="#conn-mwrite" class="headerlink" title="conn_mwrite"></a>conn_mwrite</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">          <span class="keyword">if</span> (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;msgcurr == <span class="number">0</span> &amp;&amp; build_udp_headers(c) != <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">switch</span> (transmit(c)) &#123;</span><br><span class="line">...<span class="comment">// scr: state processing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4521</text></center><p>Before explaining the logic <a href="#Back-to-state-processing">process of conn_mwrite state</a>, we look at the essential within first, which is</p><h3 id="transmit"><a href="#transmit" class="headerlink" title="transmit"></a>transmit</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> transmit_result <span class="title">transmit</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;msgcurr &lt; c-&gt;msgused &amp;&amp;</span><br><span class="line">            c-&gt;msglist[c-&gt;msgcurr].msg_iovlen == <span class="number">0</span>) &#123; <span class="comment">// scr: ---------&gt; 1)</span></span><br><span class="line">        <span class="comment">/* Finished writing the current msg; advance to the next. */</span></span><br><span class="line">        c-&gt;msgcurr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;msgcurr &lt; c-&gt;msgused) &#123; <span class="comment">// scr: ----------------------------&gt; 2)</span></span><br><span class="line">        <span class="keyword">ssize_t</span> res;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">m</span> = &amp;<span class="title">c</span>-&gt;<span class="title">msglist</span>[<span class="title">c</span>-&gt;<span class="title">msgcurr</span>];</span></span><br><span class="line">            </span><br><span class="line">        res = sendmsg(c-&gt;sfd, m, <span class="number">0</span>); </span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: state</span></span><br><span class="line">            <span class="comment">/* We've written some of the data. Remove the completed</span></span><br><span class="line"><span class="comment">               iovec entries from the list of pending writes. */</span></span><br><span class="line">            <span class="keyword">while</span> (m-&gt;msg_iovlen &gt; <span class="number">0</span> &amp;&amp; res &gt;= m-&gt;msg_iov-&gt;iov_len) &#123;</span><br><span class="line">                res -= m-&gt;msg_iov-&gt;iov_len;</span><br><span class="line">                m-&gt;msg_iovlen--;</span><br><span class="line">                m-&gt;msg_iov++;</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Might have written just part of the last iovec entry;</span></span><br><span class="line"><span class="comment">               adjust it so the next write will do the rest. */</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                m-&gt;msg_iov-&gt;iov_base = (<span class="keyword">caddr_t</span>)m-&gt;msg_iov-&gt;iov_base + res;</span><br><span class="line">                m-&gt;msg_iov-&gt;iov_len -= res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> TRANSMIT_INCOMPLETE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span> &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)) &#123; <span class="comment">// 3)</span></span><br><span class="line">            <span class="keyword">if</span> (!update_event(c, EV_WRITE | EV_PERSIST)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Couldn't update event\n"</span>);</span><br><span class="line">                conn_set_state(c, conn_closing);</span><br><span class="line">                <span class="keyword">return</span> TRANSMIT_HARD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> TRANSMIT_SOFT_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,</span></span><br><span class="line"><span class="comment">           we have a real error, on which we close the connection */</span></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">"Failed to write, and not due to blocking"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IS_UDP(c-&gt;transport))</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            conn_set_state(c, conn_closing);</span><br><span class="line">        <span class="keyword">return</span> TRANSMIT_HARD_ERROR; <span class="comment">// scr: --------------------------&gt; 4)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> TRANSMIT_COMPLETE; <span class="comment">// scr: ----------------------------&gt; 5)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">transmit@memcached.c</text></center><p>As the essential method of state <code>conn_mwrite</code> processing, <code>transmit</code> goes through the <code>msglist</code> (starting from <code>0</code>, the initial value) and tries its best to send out all the pending data accumulated in the current session. This is done within itself or in subsequent passes through the <em>event loop</em>. Only when blocking operation is indicated by <code>EAGAIN</code> or <code>EWOULDBLOCK</code>, the <strong>state machine</strong> stops the current <em>event loop</em> iteration, and the same session will be resumed when the buffer space becomes available again.</p><p>1) If the <code>msg_iovlen</code> is <code>0</code>, the writing of <code>msgcurr</code> slot has finished, hence move to the next slot.</p><p>2) Call <a href="http://man7.org/linux/man-pages/man3/sendmsg.3p.html" target="_blank" rel="noopener">sendmsg</a> and move <code>msg_iov</code>, <code>iov_base</code> and <code>iov_len</code> according to the data length (<code>res</code>) that has been written successfully. This leads to case b) of the <a href="#Back-to-state-processing">state processing</a>.</p><p>3) As mentioned, <code>EAGAIN</code> or <code>EWOULDBLOCK</code> returned by <a href="http://man7.org/linux/man-pages/man3/sendmsg.3p.html" target="_blank" rel="noopener">sendmsg</a> leads to case c) of <a href="#Back-to-state-processing">state processing</a>.</p><p>4) Errors other than the above two lead to case c) of <a href="#Back-to-state-processing">state processing</a>.</p><p>5) <code>c-&gt;msgcurr &gt;= c-&gt;msgused</code> means <code>write</code> of all data of the session finished, which leads to b) of the <a href="#Back-to-state-processing">state processing</a>.</p><h3 id="Back-to-state-processing"><a href="#Back-to-state-processing" class="headerlink" title="Back to state processing"></a>Back to state processing</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">          <span class="keyword">if</span> (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;msgcurr == <span class="number">0</span> &amp;&amp; build_udp_headers(c) != <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">switch</span> (transmit(c)) &#123;</span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_COMPLETE:</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;state == conn_mwrite) &#123; <span class="comment">// scr: ------------&gt; a)</span></span><br><span class="line">                    conn_release_items(c);</span><br><span class="line">                    <span class="comment">/* <span class="doctag">XXX:</span>  I don't know why this wasn't the general case */</span></span><br><span class="line">                    <span class="keyword">if</span>(c-&gt;protocol == binary_prot) &#123;</span><br><span class="line">                        conn_set_state(c, c-&gt;write_and_go);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        conn_set_state(c, conn_new_cmd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;state == conn_write) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_INCOMPLETE: <span class="comment">// scr: ---------------------&gt; b)</span></span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_HARD_ERROR:</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">/* Continue in state machine. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_SOFT_ERROR: <span class="comment">// scr: ---------------------&gt; c)</span></span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4521</text></center><p>According to the result of <code>transmit</code>, the logic flows to the following 3 branches,</p><p>a) If the result is <code>TRANSMIT_COMPLETE</code>, 1) finalise the current command processing with <a href="#Finish-read">conn_release_items</a>; 2) switch the <code>state</code> to <a href="#conn-new-cmd">conn_new_cmd</a> which 3) eventually falls to <code>conn_waiting</code> and, <a href="#conn-waiting">as discussed</a>, finishes the current <em>event loop</em>.</p><p>b) If the result is <code>TRANSMIT_INCOMPLETE</code> and <code>TRANSMIT_HARD_ERROR</code>, the <strong>state machine</strong> keeps the same <strong>state</strong>, and the subsequent passes through the <em>event loop</em> continues consuming more data in <code>msglist</code>. Unlike <code>read</code> operation, <code>TRANSMIT_INCOMPLETE</code> does not lead to immediate <em>event loop</em> finish because write operation does not block until buffer is full.</p><p>c) <code>TRANSMIT_SOFT_ERROR</code> means the buffer is full, hence finish the current <em>event loop</em> iteration straight away.</p><h3 id="Finish-read"><a href="#Finish-read" class="headerlink" title="Finish read"></a>Finish read</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_release_items</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;item) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (c-&gt;ileft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item *it = *(c-&gt;icurr);</span><br><span class="line">        assert((it-&gt;it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</span><br><span class="line">        item_remove(it); <span class="comment">// scr: ---------------------&gt; 1)</span></span><br><span class="line">        c-&gt;icurr++;</span><br><span class="line">        c-&gt;ileft--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: cas</span></span><br><span class="line"></span><br><span class="line">    c-&gt;icurr = c-&gt;ilist;</span><br><span class="line">...<span class="comment">// scr: cas</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">conn_release_items@memcached.c</text></center><p>Not sure if you noticed or not, there is a subtle bug in the <a href="/understanding-memcached-source-code-VI/#Read">LRU III</a>, the <em>reference count</em> of the <strong>item</strong> in <a href="/understanding-memcached-source-code-VI/#Read">read</a> operation is not returned to 0 as in other operations. This is because </p><p>1) all <strong>item</strong>s ownership are batched released here at the end the (<code>read</code>) command processing.</p>]]></content>
    
    <summary type="html">
    
      In classic multithreading, blocking I/O operations constrain the maximum number of requests a server can handle. Hence asynchronous event driven model is used to eliminate the throughput bottleneck. As such, the synchronous and potentially slow process is divided into logic segments that are free of I/O, and are executed asynchronously. When it comes to asynchronization, extra space is required to store contexts. This is because the logic segments, that could be associated with different sessions, are executed in an interleaved way. For instance, in the case when asynchronization is implemented (emulated) using synchronous multithreading, the “extra space” is in the form of thread stack. Whilst contexts are maintained in user land in event driven.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="socket" scheme="https://holmeshe.me/tags/socket/"/>
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="event driven" scheme="https://holmeshe.me/tags/event-driven/"/>
    
      <category term="state machine" scheme="https://holmeshe.me/tags/state-machine/"/>
    
      <category term="multithreading" scheme="https://holmeshe.me/tags/multithreading/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - Event Driven I</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-VII/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-VII/</id>
    <published>2019-01-17T20:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I - this article</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>In classic <em>multithreading</em>, large amounts of slow and blocking operations, mostly, I/O, can easily drain out available thread resources, which severely constrains the maximum number of requests a server can handle per unit time. More specific, threads are scheduled out and put into sleep in the middle of procedures that contain blocking I/O, despite piling up requests packets queuing within the network stack. In such situation, server side will show low throughput, low CPU saturation and high latency. </p><a id="more"></a><p class="back"><br>Here is a <a href="https://hackernoon.com/back-end-performance-those-metrics-we-care-about-ade678e87969" target="_blank" rel="noopener">post</a> around server side performance. Feel free to check it out.<br></p><h1 id="An-introduction-to-event-driven"><a href="#An-introduction-to-event-driven" class="headerlink" title="An introduction to event driven"></a>An introduction to event driven</h1><p>This is where asynchronous <strong>event driven</strong> model comes in, which drops the idea that <em>context</em> of a <em>session</em> must be coupled with a thread. In such model, <em>session</em> contexts are contained within and managed by a <strong>drive machine</strong> and a thread is fully unleashed with unblocking I/O operations. More specific, 1) when I/O occurs in the middle of a procedure, a thread does not block but instantly switch to the processing of another <em>request</em>; and 2) when the I/O completes, the <em>context</em> will be picked up by the <strong>drive machine</strong> to resume the interrupted <em>session</em>. As such, a potentially slow procedure is effectively divided into multiple manageable pieces, and the cutting points are marked by I/O operations. This results in more performant single threaded architecture in comparison to those employ thousands of threads.</p><p class="back"><br>In my understanding, <strong>event driven</strong> model, in its essential, is yet another instance of “divide and conquer” and “trade space for time” in a not very obvious way.<br></p><p>On the other hand, <em>multithreading</em> can be still used in <strong>event driven</strong> model purely for the purpose of parallelism. Thus, in practice, the number of threads employed does not exceed that of CPU cores. I will discuss the <strong>Memcached</strong> <em>multithreading</em> soon in <a href="#Thread-model">Thread model</a>.</p><h1 id="The-drive-machine"><a href="#The-drive-machine" class="headerlink" title="The drive machine"></a>The drive machine</h1><p>From a developer’s point of view, there are numerous ways to program an asynchronous <strong>even driven</strong> server. <strong>Memcached</strong> adopts an approach called <em>state machine</em>, in which logic flow is divided into non-linear fragments identified with <strong>state</strong>s, which is normally controled by a huge <code>switch case</code>. The brightside of this approach is that the mentioned breakdown of slow procedure is sincerely reflected by the logic fragments. But it makes the code style a bit different from what most developers are already used to.</p><p>Following is how the event <strong>drive</strong>n state <strong>machine</strong> actually looks like.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> nreqs = settings.reqs_per_event;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(c-&gt;state) &#123;</span><br><span class="line">        <span class="keyword">case</span> conn_listening:</span><br><span class="line">            addrlen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">...</span><br><span class="line">            sfd = accept(c-&gt;sfd, (struct sockaddr *)&amp;addr, &amp;addrlen);</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (sfd == <span class="number">-1</span>) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (settings.maxconns_fast &amp;&amp;</span><br><span class="line">                stats_state.curr_conns + stats_state.reserved_fds &gt;= settings.maxconns - <span class="number">1</span>) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,</span><br><span class="line">                                     DATA_BUFFER_SIZE, c-&gt;transport);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_waiting:</span><br><span class="line">...</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_read:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_parse_cmd :</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_new_cmd:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_nread:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_swallow:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_write:</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_closing:</span><br><span class="line">            <span class="keyword">if</span> (IS_UDP(c-&gt;transport))</span><br><span class="line">                conn_cleanup(c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                conn_close(c);</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_closed:</span><br><span class="line">            <span class="comment">/* This only happens if dormando is an idiot. */</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_watch:</span><br><span class="line">            <span class="comment">/* We handed off our connection to the logger thread. */</span></span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_max_state:</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">drive_machine@memcached.c</text></center><p>The omitted switch blocks will be discussed in detail in following posts, so no worries.</p><h1 id="Thread-model"><a href="#Thread-model" class="headerlink" title="Thread model"></a>Thread model</h1><p>The thread model of <strong>Memcached</strong> is quite standard. There is a <em>dispatcher thread</em>, and there are preconfigured number of <em>worker thread</em>s. Each thread runs an independent <strong>drive machine</strong> described above. The <em>dispatcher thread</em>, of which the responsible is to distribute <em>request</em>s among <em>worker thread</em>s, only executes code under <code>conn_listening</code>. The actual requests are completed by <em>worker thread</em>s running on the rest of the <strong>state</strong>s.</p><p><img src="/gallery/mem-thread.png" alt="Thread model"></p><p>Next we go through the bootstrap portion of <code>main</code> function which establishes the various building blocks of <strong>event driven</strong> as well as the <em>multithreading</em> mechanism. And we will also see locations of the discussed sub-system <code>***_init</code> methods in relation to the whole initialization process.</p><p>First thing first, all the <em>system initialization</em> relevant procedures are executed in the discussed <em>dispatcher thread</em>.</p><p>The call stack of this process is</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|-main</span><br><span class="line">  |-hash_init          (LRU II)</span><br><span class="line">  |-assoc_init         (LRU II)</span><br><span class="line">  |-conn_init</span><br><span class="line">  |-slabs_init         (Slab I)</span><br><span class="line">  |-memcached_thread_init</span><br><span class="line">    |-setup_thread</span><br><span class="line">    |-create_worker</span><br><span class="line">  |-server_sockets</span><br><span class="line">    |-new_socket</span><br><span class="line">    |-conn_new</span><br></pre></td></tr></table></figure><h1 id="System-initialization"><a href="#System-initialization" class="headerlink" title="System initialization"></a>System initialization</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">...<span class="comment">// scr: -----------------------------------------------------&gt; *)</span></span><br><span class="line">...<span class="comment">// scr: initialize `settings` using default values and command line arguements</span></span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hash_init(hash_type) != <span class="number">0</span>) &#123; <span class="comment">// scr: ---------------&gt; LRU II</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to initialize hash_algorithm!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EX_USAGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: initialize `settings` &amp; sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxcore != <span class="number">0</span>) &#123; <span class="comment">// scr: --------------------------------&gt; 1)</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim_new</span>;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * First try raising to infinity; if that fails, try bringing</span></span><br><span class="line"><span class="comment">         * the soft limit to the hard.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (getrlimit(RLIMIT_CORE, &amp;rlim) == <span class="number">0</span>) &#123;</span><br><span class="line">            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;</span><br><span class="line">            <span class="keyword">if</span> (setrlimit(RLIMIT_CORE, &amp;rlim_new)!= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* failed. try raising just to the old max */</span></span><br><span class="line">                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;</span><br><span class="line">                (<span class="keyword">void</span>)setrlimit(RLIMIT_CORE, &amp;rlim_new);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * getrlimit again to see what we ended up with. Only fail if</span></span><br><span class="line"><span class="comment">         * the soft limit ends up 0, because then no core files will be</span></span><br><span class="line"><span class="comment">         * created at all.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((getrlimit(RLIMIT_CORE, &amp;rlim) != <span class="number">0</span>) || rlim.rlim_cur == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to ensure corefile creation\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rlim) != <span class="number">0</span>) &#123; <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to getrlimit number of files\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rlim.rlim_cur = settings.maxconns;</span><br><span class="line">        rlim.rlim_max = settings.maxconns;</span><br><span class="line">        <span class="keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;rlim) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: -----------------------------------------------------&gt; *)</span></span><br><span class="line"></span><br><span class="line">    main_base = event_init(); <span class="comment">// scr: --------------------------&gt; 2)</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">    assoc_init(settings.hashpower_init); <span class="comment">// scr: -----------&gt; LRU II</span></span><br><span class="line">    conn_init(); <span class="comment">// scr: ---------------------------------------&gt; 3)</span></span><br><span class="line">    slabs_init(settings.maxbytes, settings.factor, preallocate,</span><br><span class="line">            use_slab_sizes ? slab_sizes : <span class="literal">NULL</span>); <span class="comment">// scr: ---&gt; Slab I</span></span><br><span class="line">...</span><br><span class="line">    memcached_thread_init(settings.num_threads, main_base); <span class="comment">//scr:4)</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: maintainer threads initialization</span></span><br><span class="line">...<span class="comment">// scr: unix socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the listening socket, bind it, and init */</span></span><br><span class="line">    <span class="keyword">if</span> (settings.socketpath == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        <span class="keyword">if</span> (portnumber_filename != <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        errno = <span class="number">0</span>; <span class="comment">// scr: -------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.port &amp;&amp; server_sockets(settings.port, tcp_transport,</span><br><span class="line">                                           portnumber_file)) &#123;</span><br><span class="line">            vperror(<span class="string">"failed to listen on TCP port %d"</span>, settings.port);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        errno = <span class="number">0</span>; <span class="comment">// scr: -------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.udpport &amp;&amp; server_sockets(settings.udpport, udp_transport,</span><br><span class="line">                                              portnumber_file)) &#123;</span><br><span class="line">            vperror(<span class="string">"failed to listen on UDP port %d"</span>, settings.udpport);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (portnumber_file) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">1000</span>);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (event_base_loop(main_base, <span class="number">0</span>) != <span class="number">0</span>) &#123; <span class="comment">// scr: ----------&gt; 6)</span></span><br><span class="line">        retval = EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: finalization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c</text></center><p>The two relevant steps are 4) and 5) which will be discussed in the  following sections.</p><p>1) Raise the limit for core dump file size as well as the number of file descriptors.</p><p>2) Call <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6" target="_blank" rel="noopener">event_init</a> to initialize the <strong>libevent</strong> framework. The value returned is called an <em>event base</em>.</p><p>3) For all potential connections, call <a href="#" onclick="return false;" data-toggle="collapse" data-target="#conn_init">conn_init</a> to allocate space to store their respective <em>context</em>s (located using file descriptor in global variable <code>conns</code>). The role of <em>context</em> in <strong>event driven</strong> model has already been discussed in <a href="#An-introduction-to-event-driven">introduction</a>.</p><div id="conn_init" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rl) == <span class="number">0</span>) &#123;</span><br><span class="line">        max_fds = rl.rlim_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to query maximum file descriptor; "</span></span><br><span class="line">                        <span class="string">"falling back to maxconns\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((conns = <span class="built_in">calloc</span>(max_fds, <span class="keyword">sizeof</span>(conn *))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to allocate connection structures\n"</span>);</span><br><span class="line">        <span class="comment">/* This is unrecoverable so bail out early. */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">conn_init@memcached.c</text></center><br></div><p>4) Preallocate threads and their associated resources using <a href="#memcached-thread-init">memcached_thread_init</a>.</p><p>5) Setup the socket and first event listener - <code>conn_listening</code>.</p><p>6) Call <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event_8h.html#a76e311cff042dab77125e309315a0617" target="_blank" rel="noopener">event_base_loop</a> to start the <strong>event loop</strong>.</p><p>*) Other miscellaneous system operations, such as setting the signal handler for <code>SIGINT</code> and <code>SIGTERM</code>; <code>setbuf</code> <code>stderr</code> to <code>NULL</code>; dropping the root privileges of the process; and daemonizing. If those names do not ring a bell, $\lt$$\lt$Advanced UNIX Programming$\gt$$\gt$ is your friend.</p><h1 id="Threads-initialization"><a href="#Threads-initialization" class="headerlink" title="Threads initialization"></a>Threads initialization</h1><p>The core data structure of <em>multithreading</em> mechanism is</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;        <span class="comment">/* unique ID of this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span>    <span class="comment">/* libevent handle this thread uses */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">notify_event</span>;</span>  <span class="comment">/* listen event for notify pipe */</span></span><br><span class="line">    <span class="keyword">int</span> notify_receive_fd;      <span class="comment">/* receiving end of notify pipe */</span></span><br><span class="line">    <span class="keyword">int</span> notify_send_fd;         <span class="comment">/* sending end of notify pipe */</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_queue</span> *<span class="title">new_conn_queue</span>;</span> <span class="comment">/* queue of new connections to handle */</span></span><br><span class="line">...<span class="comment">// scr: cas &amp; log</span></span><br><span class="line">&#125; LIBEVENT_THREAD;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">LIBEVENT_THREAD@memcached.h</text></center><h2 id="memcached-thread-init"><a href="#memcached-thread-init" class="headerlink" title="memcached_thread_init"></a>memcached_thread_init</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcached_thread_init</span><span class="params">(<span class="keyword">int</span> nthreads, struct event_base *main_base)</span> </span>&#123;</span><br><span class="line">...<span class="comment">// scr: initialize all sorts of mutexes and condition variables</span></span><br><span class="line"></span><br><span class="line">    threads = <span class="built_in">calloc</span>(nthreads, <span class="keyword">sizeof</span>(LIBEVENT_THREAD)); <span class="comment">// scr:  1)</span></span><br><span class="line">    <span class="keyword">if</span> (! threads) &#123;</span><br><span class="line">        perror(<span class="string">"Can't allocate thread descriptors"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatcher_thread.base = main_base; <span class="comment">// scr: ----------------&gt; 2)</span></span><br><span class="line">    dispatcher_thread.thread_id = pthread_self(); <span class="comment">// scr: ------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (pipe(fds)) &#123; <span class="comment">// scr: -------------------------------&gt; 4)</span></span><br><span class="line">            perror(<span class="string">"Can't create notify pipe"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threads[i].notify_receive_fd = fds[<span class="number">0</span>]; <span class="comment">// scr: ---------&gt; 4)</span></span><br><span class="line">        threads[i].notify_send_fd = fds[<span class="number">1</span>]; <span class="comment">// scr: ------------&gt; 4)</span></span><br><span class="line"></span><br><span class="line">        setup_thread(&amp;threads[i]); <span class="comment">// scr: ---------------------&gt; 5)</span></span><br><span class="line">        <span class="comment">/* Reserve three fds for the libevent base, and two for the pipe */</span></span><br><span class="line">        stats_state.reserved_fds += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create threads after we've done all the libevent setup. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</span><br><span class="line">        create_worker(worker_libevent, &amp;threads[i]); <span class="comment">// scr: ---&gt; 6)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for all the threads to set themselves up before returning. */</span></span><br><span class="line">    pthread_mutex_lock(&amp;init_lock);</span><br><span class="line">    wait_for_thread_registration(nthreads);</span><br><span class="line">    pthread_mutex_unlock(&amp;init_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">conn_init@memcached.c</text></center><p>1) Allocate memory for an array of <a href="#Threads-initialization">LIBEVENT_THREAD</a>. The number of thread is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#num_threads">num_threads</a> Each element represents one thread. As described above, better the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#num_threads">num_threads</a> does not exceed the number of cores.</p><div id="num_threads" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.num_threads = <span class="number">4</span>;         <span class="comment">/* N workers */</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            settings.num_threads = atoi(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Number of threads must be greater than 0\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* There're other problems when you get above 64 threads.</span></span><br><span class="line"><span class="comment">             * In the future we should portably detect # of cores for the</span></span><br><span class="line"><span class="comment">             * default.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &gt; <span class="number">64</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting a high number of worker"</span></span><br><span class="line">                                <span class="string">"threads is not recommended.\n"</span></span><br><span class="line">                                <span class="string">" Set this value to the number of cores in"</span></span><br><span class="line">                                <span class="string">" your machine or less.\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">num_threads@memcached.c</text></center><br></div><p>2) Set the <em>event base</em> for the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#dispatcher_thread">dispatcher_thread</a> which represents the main thread itself. Note that <a href="#" onclick="return false;" data-toggle="collapse" data-target="#dispatcher_thread">dispatcher_thread</a> is a global variable so the reference is accessible to all the <em>worker thread</em>s.</p><div id="dispatcher_thread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> LIBEVENT_DISPATCHER_THREAD dispatcher_thread;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">dispatcher_thread@thread.c</text></center><br></div><p>3) Set the thread id for <a href="#" onclick="return false;" data-toggle="collapse" data-target="#dispatcher_thread">dispatcher_thread</a>.</p><p>4) Initialize the <a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a> <code>fd</code>s for each of the <em>worker thread</em>. Here the <code>notify_send_fd</code> is used for communication between <em>dispatcher thread</em> and <em>worker thread</em>s - whenever the <em>dispatcher thread</em> <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener">write</a>s to <code>notify_send_fd</code>, an <strong>event</strong> is generated on the other side, <code>notify_receive_fd</code>, which is listened by <em>worker thread</em>s. Again, $\lt$$\lt$Advanced UNIX Programming$\gt$$\gt$ gives more information about <code>pipe</code>.</p><p>5) The full method name is supposed to be <code>setup_libevent_for_each_thread</code>. Will examine this method in the <a href="#setup-thread">next section</a>.</p><p>6) Call <a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html" target="_blank" rel="noopener">pthread_create</a> to create the actual <em>worker threads</em>. Will examine this method in <a href="#create-worker">create_worker</a>.</p><h2 id="setup-thread"><a href="#setup-thread" class="headerlink" title="setup_thread"></a>setup_thread</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_thread</span><span class="params">(LIBEVENT_THREAD *me)</span> </span>&#123;</span><br><span class="line">    me-&gt;base = event_init(); <span class="comment">// scr: ---------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">if</span> (! me-&gt;base) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't allocate event base\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Listen for notifications from other threads */</span></span><br><span class="line">    event_set(&amp;me-&gt;notify_event, me-&gt;notify_receive_fd, <span class="comment">// scr: &gt; 2)</span></span><br><span class="line">              EV_READ | EV_PERSIST, thread_libevent_process, me);</span><br><span class="line">    event_base_set(me-&gt;base, &amp;me-&gt;notify_event); <span class="comment">// scr: -------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event_add(&amp;me-&gt;notify_event, <span class="number">0</span>) == <span class="number">-1</span>) &#123; <span class="comment">// scr: -------&gt; 2)</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't monitor libevent notify pipe\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me-&gt;new_conn_queue = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct conn_queue)); <span class="comment">//scr:3)</span></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;new_conn_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Failed to allocate memory for connection queue"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    cq_init(me-&gt;new_conn_queue);</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: stat &amp; cas</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">setup_thread@thread.c</text></center><p>1) Call <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6" target="_blank" rel="noopener">event_init</a> to initialize the <strong>libevent</strong> instance for the <em>worker thread</em>. As discussed in <a href="#Thread-model">thread model</a>, each <em>worker thread</em> runs its own <strong>drive machine</strong>.</p><p>2) Set the <code>thread_libevent_process</code> as the callback of events emitted from the discussed <code>notify_receive_fd</code>. The major function of <code>thread_libevent_process</code> is to link the actual <strong>drive machine</strong> to <strong>event</strong>s, which we will see very soon in <a href="#thread-libevent-process">inter-thread communication</a>.</p><p>3) Allocate and initialize the connection queue of the <em>worker thread</em>.</p><h2 id="create-worker"><a href="#create-worker" class="headerlink" title="create_worker"></a>create_worker</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create_worker</span><span class="params">(<span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span>  attr;</span><br><span class="line">    <span class="keyword">int</span>             ret;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = pthread_create(&amp;((LIBEVENT_THREAD*)arg)-&gt;thread_id, &amp;attr, func, arg)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't create thread: %s\n"</span>,</span><br><span class="line">                strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">create_worker@thread.c</text></center><p>As mentioned, this method calls <a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html" target="_blank" rel="noopener">pthread_create</a> to create the actual <em>worker thread</em>s. The callback passed through is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#worker_libevent">worker_libevent</a> which essentially starts the <strong>event loop</strong> using <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event_8h.html#a76e311cff042dab77125e309315a0617" target="_blank" rel="noopener">event_base_loop</a>, this time, on <em>worker thread</em>s rather than <em>dispatch thread</em>.</p><div id="worker_libevent" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">worker_libevent</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    LIBEVENT_THREAD *me = arg;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    event_base_loop(me-&gt;base, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">worker_libevent@thread.c</text></center><br></div><h1 id="Socket-initialization"><a href="#Socket-initialization" class="headerlink" title="Socket initialization"></a>Socket initialization</h1><p>The methods involved in socket initialization reconcile the initialization of both <em>TCP</em> and <em>UDP</em> while the following discussion covers only the <em>TCP</em> logic branch. And we consider <a href="#" onclick="return false;" data-toggle="collapse" data-target="#portnumber_file">portnumber_file</a> is not set so as to focus on the critical path.</p><div id="portnumber_file" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *portnumber_filename = getenv(<span class="string">"MEMCACHED_PORT_FILENAME"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (portnumber_filename != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(portnumber_filename)+<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">    temp_portnumber_filename = <span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="built_in">snprintf</span>(temp_portnumber_filename,</span><br><span class="line">             len,</span><br><span class="line">             <span class="string">"%s.lck"</span>, portnumber_filename);</span><br><span class="line"></span><br><span class="line">    portnumber_file = fopen(temp_portnumber_filename, <span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">if</span> (portnumber_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to open \"%s\": %s\n"</span>,</span><br><span class="line">                temp_portnumber_filename, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:6029</text></center><br></div><p>Unlike <em>worker thread</em>s that listen to internal (<a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a>) <code>fd</code>s, <em>dispatch thread</em> is responsible for <strong>event</strong>s generated from external socket <code>fd</code>s (by network requests). The method that initializes sockets is <code>server_sockets</code>.</p><p>If network interface is not indicated by <a href="#" onclick="return false;" data-toggle="collapse" data-target="#inter">inter</a>, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#server_sockets">server_sockets</a> is equivalent to</p><div id="inter" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.inter = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:209</text></center><br></div><div id="server_sockets" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">server_sockets</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">enum</span> network_transport transport,</span></span></span><br><span class="line"><span class="function"><span class="params">                          FILE *portnumber_file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (settings.inter == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> server_socket(settings.inter, port, transport, portnumber_file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">server_sockets@memcached.c</text></center><br></div><h2 id="server-socket"><a href="#server-socket" class="headerlink" title="server_socket"></a>server_socket</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">server_socket</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *interface,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">enum</span> network_transport transport,</span></span></span><br><span class="line"><span class="function"><span class="params">                         FILE *portnumber_file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">ling</span> = &#123;</span><span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span> = &#123;</span> .ai_flags = AI_PASSIVE,</span><br><span class="line">                              .ai_family = AF_UNSPEC &#125;;</span><br><span class="line">    <span class="keyword">char</span> port_buf[NI_MAXSERV];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> success = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flags =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">-1</span>) &#123;</span><br><span class="line">        port = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(port_buf, <span class="keyword">sizeof</span>(port_buf), <span class="string">"%d"</span>, port);</span><br><span class="line">    error= getaddrinfo(interface, port_buf, &amp;hints, &amp;ai); <span class="comment">// scr: 1)</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (next= ai; next; next= next-&gt;ai_next) &#123; <span class="comment">// scr: --------&gt; 2)</span></span><br><span class="line">        conn *listen_conn_add;</span><br><span class="line">        <span class="keyword">if</span> ((sfd = new_socket(next)) == <span class="number">-1</span>) &#123; <span class="comment">// scr: ----------&gt; 3)</span></span><br><span class="line">            <span class="comment">/* getaddrinfo can return "junk" addresses,</span></span><br><span class="line"><span class="comment">             * we make sure at least one works before erroring.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">                <span class="comment">/* ...unless we're out of fds */</span></span><br><span class="line">                perror(<span class="string">"server_socket"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 4)</span></span><br><span class="line">        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</span><br><span class="line">        <span class="keyword">if</span> (IS_UDP(transport)) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">"setsockopt"</span>);</span><br><span class="line"></span><br><span class="line">            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (<span class="keyword">void</span> *)&amp;ling, <span class="keyword">sizeof</span>(ling));</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">"setsockopt"</span>);</span><br><span class="line"></span><br><span class="line">            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">"setsockopt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (bind(sfd, next-&gt;ai_addr, next-&gt;ai_addrlen) == <span class="number">-1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            success++;</span><br><span class="line">            <span class="keyword">if</span> (!IS_UDP(transport) &amp;&amp; listen(sfd, settings.backlog) == <span class="number">-1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (portnumber_file != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IS_UDP(transport)) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ---------------------------------------&gt; 6)</span></span><br><span class="line">            <span class="keyword">if</span> (!(listen_conn_add = conn_new(sfd, conn_listening,</span><br><span class="line">                                             EV_READ | EV_PERSIST, <span class="number">1</span>,</span><br><span class="line">                                             transport, main_base))) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to create listening connection\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            listen_conn_add-&gt;next = listen_conn; <span class="comment">// scr: -------&gt; 7)</span></span><br><span class="line">            listen_conn = listen_conn_add;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeaddrinfo(ai);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return zero iff we detected no errors in starting up connections */</span></span><br><span class="line">    <span class="keyword">return</span> success == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">server_socket@memcached.c</text></center><p>1) Get all the available network interfaces.</p><p>2) Iterate all the network interfaces and setup the sockets with the following steps.</p><p>3) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#new_socket">new_socket</a> encapsulates the operation of <a href="http://man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="noopener">socket</a> creation as well as that of setting it to non-block.</p><div id="new_socket" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">new_socket</span><span class="params">(struct addrinfo *ai)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sfd = socket(ai-&gt;ai_family, ai-&gt;ai_socktype, ai-&gt;ai_protocol)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags = fcntl(sfd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span> ||</span><br><span class="line">        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setting O_NONBLOCK"</span>);</span><br><span class="line">        close(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">new_socket@memcached.c</text></center><br></div><p>4) Tweak the newly created <a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank" rel="noopener">socket</a> <code>fd</code> using <a href="http://man7.org/linux/man-pages/man2/setsockopt.2.html" target="_blank" rel="noopener">setsockopt</a>, in which</p><p><code>SO_REUSEADDR</code> allows binding to a port in <code>TIME_WAIT</code>. This is useful for instantly rebooting a server on a “not fresh” TCP port;</p><p><code>SO_KEEPALIVE</code> sends heartbeats to detect an absent client, and to release the resource for network connection in both kernel and user space; <a href="/network-essentials-setsockopt-SO_KEEPALIVE/">learn more</a></p><p><code>SO_LINGER</code> enables fast close of a connection on <code>RST</code>; <a href="http://deepix.github.io/2016/10/21/tcprst.html" target="_blank" rel="noopener">learn more</a></p><p><code>TCP_NODELAY</code> disables <em>nagle</em> to improve latency. <a href="/network-essentials-setsockopt-TCP_NODELAY/">learn more</a></p><p>5) <a href="http://man7.org/linux/man-pages/man2/bind.2.html" target="_blank" rel="noopener">bind</a> and start <a href="http://man7.org/linux/man-pages/man2/listen.2.html" target="_blank" rel="noopener">listen</a>ing to the <code>fd</code>.</p><p>6) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#conn_new">conn_new</a> initializes the <em>context</em> for the <code>fd</code> and adds it to <strong>libevent</strong> with initial <strong>state</strong> set to <code>conn_listening</code> and callback as <code>event_handler</code>. Here <code>event_handler</code> is another transient method leading to the <strong>drive machine</strong> on <em>dispatcher thread</em>. Likewise, this method will be discussed soon in <a href="#event-handler">inter-thread communication</a>.</p><div id="conn_new" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">conn *<span class="title">conn_new</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> sfd, <span class="keyword">enum</span> conn_states init_state,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">int</span> event_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">int</span> read_buffer_size, <span class="keyword">enum</span> network_transport transport,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct event_base *base)</span> </span>&#123;</span><br><span class="line">    conn *c;</span><br><span class="line">...<span class="comment">// scr: initialize context conn</span></span><br><span class="line">    c-&gt;state = init_state;</span><br><span class="line">...<span class="comment">// scr: initialize context conn</span></span><br><span class="line"></span><br><span class="line">    event_set(&amp;c-&gt;event, sfd, event_flags, event_handler, (<span class="keyword">void</span> *)c);</span><br><span class="line">    event_base_set(base, &amp;c-&gt;event);</span><br><span class="line">    c-&gt;ev_flags = event_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event_add(&amp;c-&gt;event, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"event_add"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:120</text></center><br></div><p>7) Add the <em>context</em> to the head of a global list <a href="#" onclick="return false;" data-toggle="collapse" data-target="#listen_conn">listen_conn</a>.</p><div id="listen_conn" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> conn *listen_conn = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:120</text></center><br></div><p>Next we briefly go through the process that handles a new connection to wrap up the</p><h1 id="Inter-thread-communication"><a href="#Inter-thread-communication" class="headerlink" title="Inter-thread communication"></a>Inter-thread communication</h1><p><img src="/gallery/threads-comm.png" alt="Inter-thread communication"></p><h2 id="event-handler"><a href="#event-handler" class="headerlink" title="event_handler"></a>event_handler</h2><p>Firstly, after a TCP connection completes, the <code>fd</code> monitored by <em>dispatcher thread</em> notifies <strong>libevent</strong>, which invokes the mentioned <a href="#" onclick="return false;" data-toggle="collapse" data-target="#event_handler">event_handler</a>. Next, the logic flow enters the code snippet we got in the beginning - the <strong>drive machine</strong>, with <em>context</em> <strong>state</strong> initialized as <code>conn_listening</code> in <a href="#Socket-initialization">socket initialization</a>.</p><div id="event_handler" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_handler</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> fd, <span class="keyword">const</span> short which, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    conn *c;</span><br><span class="line"></span><br><span class="line">    c = (conn *)arg;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    c-&gt;which = which;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sanity */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    drive_machine(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait for next event */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">event_handler@memcached.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(c-&gt;state) &#123;</span><br><span class="line">        <span class="keyword">case</span> conn_listening:</span><br><span class="line">            addrlen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">...</span><br><span class="line">                  <span class="comment">// scr: --------------------------------------&gt; 1)</span></span><br><span class="line">            sfd = accept(c-&gt;sfd, (struct sockaddr *)&amp;addr, &amp;addrlen);</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (sfd == <span class="number">-1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (settings.maxconns_fast &amp;&amp;</span><br><span class="line">                stats_state.curr_conns + stats_state.reserved_fds &gt;= settings.maxconns - <span class="number">1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// scr: ----------------------------------------&gt; 2)</span></span><br><span class="line">                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,</span><br><span class="line">                                     DATA_BUFFER_SIZE, c-&gt;transport);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">drive_machine@memcached.c</text></center><p>At this stage, the <strong>drive machine</strong> 1) <a href="http://man7.org/linux/man-pages/man2/accept.2.html" target="_blank" rel="noopener">accept</a>s the connection and derives another <code>fd</code> that can be <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener">read</a> from. It 2) then calls <code>dispatch_conn_new</code> with the new <code>fd</code> and other relevant information including the next <strong>state</strong>, <code>conn_new_cmd</code>.</p><h2 id="dispatch-conn-new"><a href="#dispatch-conn-new" class="headerlink" title="dispatch_conn_new"></a>dispatch_conn_new</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_conn_new</span><span class="params">(<span class="keyword">int</span> sfd, <span class="keyword">enum</span> conn_states init_state, <span class="keyword">int</span> event_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> read_buffer_size, <span class="keyword">enum</span> network_transport transport)</span> </span>&#123;</span><br><span class="line">    CQ_ITEM *item = cqi_new();</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tid = (last_thread + <span class="number">1</span>) % settings.num_threads; <span class="comment">// scr: &gt; 1)</span></span><br><span class="line"></span><br><span class="line">    LIBEVENT_THREAD *thread = threads + tid; <span class="comment">// scr: -----------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">    last_thread = tid; <span class="comment">// scr: ---------------------------------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">    item-&gt;sfd = sfd; <span class="comment">// scr: -----------------------------------&gt; 2)</span></span><br><span class="line">    item-&gt;init_state = init_state;</span><br><span class="line">    item-&gt;event_flags = event_flags;</span><br><span class="line">    item-&gt;read_buffer_size = read_buffer_size;</span><br><span class="line">    item-&gt;transport = transport;</span><br><span class="line"></span><br><span class="line">    cq_push(thread-&gt;new_conn_queue, item); <span class="comment">// scr: -------------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    MEMCACHED_CONN_DISPATCH(sfd, thread-&gt;thread_id);</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">'c'</span>;</span><br><span class="line">    <span class="keyword">if</span> (write(thread-&gt;notify_send_fd, buf, <span class="number">1</span>) != <span class="number">1</span>) &#123; <span class="comment">// scr: --&gt; 4)</span></span><br><span class="line">        perror(<span class="string">"Writing to thread notify pipe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">dispatch_conn_new@thread.c</text></center><p>1) Round robin the threads established in <a href="#Threads-initialization">threads initialization</a>.</p><p>2) Initializes a <a href="#" onclick="return false;" data-toggle="collapse" data-target="#CQ_ITEM">CQ_ITEM</a> instance. Here <a href="#" onclick="return false;" data-toggle="collapse" data-target="#CQ_ITEM">CQ_ITEM</a> is an intermediate object passed to <em>worker thread</em>s through <em>connection queue</em>, so <em>worker thread</em>s can create new <em>context</em> based on it.</p><div id="CQ_ITEM" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">conn_queue_item</span> <span class="title">CQ_ITEM</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_queue_item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>               sfd;</span><br><span class="line">    <span class="keyword">enum</span> conn_states  init_state;</span><br><span class="line">    <span class="keyword">int</span>               event_flags;</span><br><span class="line">    <span class="keyword">int</span>               read_buffer_size;</span><br><span class="line">    <span class="keyword">enum</span> network_transport     transport;</span><br><span class="line">    CQ_ITEM          *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">CQ_ITEM@thread.c</text></center><br></div><p>3) Push <a href="#" onclick="return false;" data-toggle="collapse" data-target="#CQ_ITEM">CQ_ITEM</a> to the <em>connection queue</em>.</p><p>4) Write to <code>notify_send_fd</code> with the command <code>&#39;c&#39;</code>.</p><p>As discussed <a href="#memcached-thread-init">before</a>, 4) generates an <strong>event</strong> on the other side of the <a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a> (on the chosen <em>worker thread</em>), which invokes</p><h2 id="thread-libevent-process"><a href="#thread-libevent-process" class="headerlink" title="thread_libevent_process"></a>thread_libevent_process</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_libevent_process</span><span class="params">(<span class="keyword">int</span> fd, short which, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    LIBEVENT_THREAD *me = arg;</span><br><span class="line">    CQ_ITEM *item;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> timeout_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">1</span>) != <span class="number">1</span>) &#123; <span class="comment">// scr: -----------------------&gt; 1)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't read from libevent pipe\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (buf[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">        item = cq_pop(me-&gt;new_conn_queue); <span class="comment">// scr: -------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != item) &#123;</span><br><span class="line">            conn *c = conn_new(item-&gt;sfd, item-&gt;init_state, item-&gt;event_flags,</span><br><span class="line">                               item-&gt;read_buffer_size, item-&gt;transport,</span><br><span class="line">                               me-&gt;base); <span class="comment">// scr: --------------&gt; 3)</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c-&gt;thread = me; <span class="comment">// scr: ------------------------&gt; 4)</span></span><br><span class="line">            &#125;</span><br><span class="line">            cqi_free(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* we were told to pause and report in */</span></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">thread_libevent_process@thread.c</text></center><p>1) Read the command (i.e., <code>&#39;c&#39;</code>) from the <a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a>.</p><p>2) Read the <code>CQ_ITEM</code> from the <em>connection queue</em>.</p><p>3) Call <code>conn_new</code>. In <a href="#server-socket">server_socket</a> we know that <code>conn_new</code> establishes the <em>context</em>, this time, for the new connection, and adds the <a href="http://man7.org/linux/man-pages/man2/accept.2.html" target="_blank" rel="noopener">accept</a>ed <code>fd</code> to <strong>libevent</strong>. Here on <em>worker thread</em>, the callback is set to <code>event_handler</code>, which essentially connects the <strong>drive machine</strong> to the upcoming <strong>event</strong>s on the same connection.</p><p>4) Set the <a href="#Threads-initialization">thread information</a> to the context.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf" target="_blank" rel="noopener">Why Threads Are A Bad Idea</a></p><p>W. Richard Stevens. 1992. Advanced Programming in the UNIX Environment. Addison Wesley Longman Publishing Co., Inc., Redwood City, CA, USA. </p><p><a href="http://deepix.github.io/2016/10/21/tcprst.html" target="_blank" rel="noopener">Resetting a TCP connection and SO_LINGER</a></p><p><a href="https://www.usenix.org/legacy/publications/library/proceedings/usenix99/full_papers/pai/pai_html/node7.html" target="_blank" rel="noopener">Single-process event-driven</a></p>]]></content>
    
    <summary type="html">
    
      In classic multithreading, large amounts of slow and blocking operations, mostly, I/O, can easily drain out available thread resources, which severely constrains the maximum number of requests a server can handle per unit time. More specific, threads are scheduled out and put into sleep in the middle of procedures that contain blocking I/O, despite piling up requests packets queuing within the network stack. In such situation, server side will show low throughput, low CPU saturation and high latency.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="socket" scheme="https://holmeshe.me/tags/socket/"/>
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="event driven" scheme="https://holmeshe.me/tags/event-driven/"/>
    
      <category term="state machine" scheme="https://holmeshe.me/tags/state-machine/"/>
    
      <category term="multithreading" scheme="https://holmeshe.me/tags/multithreading/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - LRU III</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-VI/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-VI/</id>
    <published>2018-12-23T22:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I, </text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;"> II, </text></a> <a href="#"><text style="color:black;font-weight:bold;"> III - this article)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>In previous posts, we have discussed different facets of an <strong>item</strong>, i.e., <strong>slab</strong>, <strong>hash map</strong> and <strong>LRU list</strong> as well as their associated (CRUD) methods, which build up the internal procedures and perform client requests after the corresponding commands are parsed by the <strong>drive machine</strong>. This time we will go through those procedures by issuing <em>telnet commands</em> to a <strong>Memcached</strong> instance and see how the discussed modules work together on various <strong>item</strong> operations. We will also see the whole picture of <strong>LRU list</strong>s that maintain the property of ‘least recently used’ in accordance to those operations.</p><a id="more"></a><p>On top of standard <strong>LRU</strong> algorithm, the <strong>Memcached</strong> (1.4.28) emploies <code>3</code> lists instead of just <code>1</code>, i.e., hot, warm and cold, a.k.a., <a href="https://memcached.org/blog/modern-lru/" target="_blank" rel="noopener">Segmented LRU</a> for each <strong>slab class</strong>. This heuristic is implemented to reduce the lock contention between <strong>item</strong> <em>bumping</em> (an <a href="/understanding-memcached-source-code-IV/#Linked-list">action</a> that moves recently accessed <strong>item</strong> to the list head) and <strong>item</strong> read. Moreover, unlike a casual implementation (such as the one I coded), <strong>Memcached</strong> does not <em>bump</em> <strong>item</strong> right on <a href="#opt1">read action</a>. Rather, the <em>bumping</em> is delayed to <a href="#opt2">other operations when the resource is in short</a>, which could reflect <strong>Memcached</strong>‘s read-first design decision.</p><blockquote><p>In normal use cases, let’s say, a social media, the volume of read requests are more than that of other operations combined by orders of magnitude, hence it’s a critical point that worth extensive optimizations, I suppose.</p></blockquote><p>We start this post by issuing an <strong>item</strong> read command to a <strong>Memcached</strong> instance.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~telnet localhost 11211</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">...// add some items</span><br><span class="line">&gt; get test</span><br></pre></td></tr></table></figure><h1 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h1><p>The the normal execution of this procedure,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line">1 |~Drive machine &amp; command parser</span><br><span class="line">    |-process_get_command</span><br><span class="line">++    |-item_get</span><br><span class="line">        |-assoc_find    (LRU II)</span><br><span class="line">      |-item_update</span><br><span class="line">        |-item_unlink_q (LRU I)</span><br><span class="line">        |-item_link_q   (LRU I)</span><br></pre></td></tr></table></figure><h2 id="process-get-command"><a href="#process-get-command" class="headerlink" title="process_get_command"></a>process_get_command</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">process_get_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">size_t</span> ntokens, <span class="keyword">bool</span> return_cas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">token_t</span> *key_token = &amp;tokens[KEY_TOKEN];</span><br><span class="line">    <span class="keyword">char</span> *suffix;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(key_token-&gt;length != <span class="number">0</span>) &#123; <span class="comment">// scr: -----------------&gt; *)</span></span><br><span class="line"></span><br><span class="line">            key = key_token-&gt;value;</span><br><span class="line">            nkey = key_token-&gt;length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nkey &gt; KEY_MAX_LENGTH) &#123;</span><br><span class="line">                out_string(c, <span class="string">"CLIENT_ERROR bad command line format"</span>);</span><br><span class="line">                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    item_remove(*(c-&gt;ilist + i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it = item_get(key, nkey, c); <span class="comment">// scr: ----------------&gt; 1)</span></span><br><span class="line">            <span class="keyword">if</span> (settings.detail_enabled) &#123;</span><br><span class="line">                stats_prefix_record_get(key, nkey, <span class="literal">NULL</span> != it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= c-&gt;isize) &#123; <span class="comment">// scr: --------------------&gt; *)</span></span><br><span class="line">                    item **new_list = <span class="built_in">realloc</span>(c-&gt;ilist, <span class="keyword">sizeof</span>(item *) * c-&gt;isize * <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">if</span> (new_list) &#123;</span><br><span class="line">                        c-&gt;isize *= <span class="number">2</span>;</span><br><span class="line">                        c-&gt;ilist = new_list;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">                        item_remove(it);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (return_cas)</span><br><span class="line">                &#123;</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  MEMCACHED_COMMAND_GET(c-&gt;sfd, ITEM_key(it), it-&gt;nkey,</span><br><span class="line">                                        it-&gt;nbytes, ITEM_get_cas(it));</span><br><span class="line">                  <span class="keyword">if</span> (add_iov(c, <span class="string">"VALUE "</span>, <span class="number">6</span>) != <span class="number">0</span> || <span class="comment">// scr: ---&gt; *)</span></span><br><span class="line">                      add_iov(c, ITEM_key(it), it-&gt;nkey) != <span class="number">0</span> ||</span><br><span class="line">                      add_iov(c, ITEM_suffix(it), it-&gt;nsuffix + it-&gt;nbytes) != <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          item_remove(it);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: verbose &amp; stat</span></span><br><span class="line"></span><br><span class="line">                item_update(it); <span class="comment">// scr: ------------------------&gt; 2)</span></span><br><span class="line">                *(c-&gt;ilist + i) = it;</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key_token++; <span class="comment">// scr: --------------------------------&gt; *)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the command string hasn't been fully processed, get the next set</span></span><br><span class="line"><span class="comment">         * of tokens.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(key_token-&gt;value != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: ------------------&gt; *)</span></span><br><span class="line">            ntokens = tokenize_command(key_token-&gt;value, tokens, MAX_TOKENS);</span><br><span class="line">            key_token = tokens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(key_token-&gt;value != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    c-&gt;icurr = c-&gt;ilist;</span><br><span class="line">    c-&gt;ileft = i;</span><br><span class="line">... <span class="comment">// scr: cas &amp; verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key_token-&gt;value != <span class="literal">NULL</span> || add_iov(c, <span class="string">"END\r\n"</span>, <span class="number">5</span>) != <span class="number">0</span></span><br><span class="line">        || (IS_UDP(c-&gt;transport) &amp;&amp; build_udp_headers(c) != <span class="number">0</span>)) &#123;</span><br><span class="line">        out_of_memory(c, <span class="string">"SERVER_ERROR out of memory writing get response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// scr: ----------------------------------------------&gt; *)</span></span><br><span class="line">        conn_set_state(c, conn_mwrite);</span><br><span class="line">        c-&gt;msgcurr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_get_command@memcached.c</text></center><p>The only relevant step here are 1) <code>item_get</code> and 2) <code>item_update</code>. Steps marked as *) are mostly command parsing and I/O which will be discussed in later posts when we examine <strong>event driven</strong> mechanism.</p><h2 id="do-item-get"><a href="#do-item-get" class="headerlink" title="do_item_get"></a>do_item_get</h2><p>Like other methods discussed before, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_get">item_get</a> is a thread-safe wrapper of <code>do_item_get</code>.</p><div id="item_get" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">item_get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, conn *c)</span> </span>&#123;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(key, nkey);</span><br><span class="line">    item_lock(hv);</span><br><span class="line">    it = do_item_get(key, nkey, hv, c);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_get@thread.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">do_item_get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv, conn *c)</span> </span>&#123;</span><br><span class="line">    item *it = assoc_find(key, nkey, hv); <span class="comment">// scr: -----------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        refcount_incr(&amp;it-&gt;refcount); <span class="comment">// scr: ---------------------&gt; 2)</span></span><br><span class="line">...<span class="comment">// scr: comments</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> was_found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        was_found = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (item_is_flushed(it)) &#123;</span><br><span class="line">...<span class="comment">// scr: item flush</span></span><br><span class="line"><span class="comment">// scr: -----------------------------------------------------------&gt; 3)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;exptime != <span class="number">0</span> &amp;&amp; it-&gt;exptime &lt;= current_time) &#123;</span><br><span class="line">            do_item_unlink(it, hv);</span><br><span class="line">            do_item_remove(it);</span><br><span class="line">            it = <span class="literal">NULL</span>;</span><br><span class="line">...<span class="comment">// scr: stat &amp; verbose</span></span><br><span class="line">            was_found = <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ------------------------------------------&gt; 4)</span></span><br><span class="line">            it-&gt;it_flags |= ITEM_FETCHED|ITEM_ACTIVE;</span><br><span class="line">            DEBUG_REFCNT(it, <span class="string">'+'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_get@items.c</text></center><p>1) Use the discussed <a href="/understanding-memcached-source-code-V/#assoc-find">assoc_find</a> to locate the <strong>item</strong> using the <em>hash key</em>.</p><p>2) Increase the discussed <a href="/understanding-memcached-source-code-IV/#do-item-link">reference count</a>.</p><p>3) If the <strong>item</strong> has expired, remove it. Note that <code>do_item_unlink</code> decreases the reference count held by the last step, and <code>do_item_remove</code> actually removes the <strong>item</strong>. These two methods will be discussed soon in <a href="#Delete">item delete</a>.</p><a href="#" id="opt1" style="visibility: hidden"></a><p>4) Simply mark the <strong>item</strong> as <code>ITEM_ACTIVE</code> rather than perform <strong>item</strong> <em>bumping</em> which is offloaded to other operations associated procedures. This is part of the heuristic discussed in the beginning.</p><h2 id="do-item-update"><a href="#do-item-update" class="headerlink" title="do_item_update"></a>do_item_update</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_update">item_update</a> is a thread-safe wrapper of <code>do_item_update</code>.<br><br><div id="item_update" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_update</span><span class="params">(item *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(ITEM_key(item), item-&gt;nkey);</span><br><span class="line"></span><br><span class="line">    item_lock(hv);</span><br><span class="line">    do_item_update(item);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_update@thread.c</text></center><p></p></div><p></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_update</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it-&gt;nkey, it-&gt;nbytes);</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;time &lt; current_time - ITEM_UPDATE_INTERVAL) &#123;</span><br><span class="line">        assert((it-&gt;it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">            it-&gt;time = current_time; <span class="comment">// scr: ----------------------&gt; 1)</span></span><br><span class="line">            <span class="keyword">if</span> (!settings.lru_maintainer_thread) &#123;</span><br><span class="line">                item_unlink_q(it);</span><br><span class="line">                item_link_q(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_update@items.c</text></center><p>1) The only line effective in this method is to set the access time for the <strong>item</strong> in (passively) an <a href="#" onclick="return false;" data-toggle="collapse" data-target="#interval">interval</a> of 60 seconds. <a href="#" onclick="return false;" data-toggle="collapse" data-target="#lru_maintainer_thread">lru_maintainer_thread</a> is set to <code>true</code> by command line argument <code>modern</code> so the operations inside <code>if (!settings.lru_maintainer_thread)</code> is not applicable.</p><div id="interval" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_UPDATE_INTERVAL 60</span></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.h:73</text></center><br></div><div id="lru_maintainer_thread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MODERN:</span><br><span class="line">...</span><br><span class="line">    start_lru_maintainer = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5828</text></center><br></div><p>Next, </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; delete test</span><br></pre></td></tr></table></figure><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>Call stack in normal execution,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line">1 |~Drive machine &amp; command parser</span><br><span class="line">    |-process_delete_command</span><br><span class="line">++    |-do_item_get</span><br><span class="line">      |-do_item_unlink</span><br><span class="line">        |-assoc_delete    (LRU II)</span><br><span class="line">        |-item_unlink_q   (LRU I)</span><br><span class="line">--      |-do_item_remove</span><br><span class="line">--    |-do_item_remove</span><br><span class="line">        |-do_item_free</span><br><span class="line">          |-do_slabs_free (Slab II)</span><br></pre></td></tr></table></figure><h2 id="process-delete-command"><a href="#process-delete-command" class="headerlink" title="process_delete_command"></a>process_delete_command</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_delete_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">const</span> <span class="keyword">size_t</span> ntokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    item *it;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    key = tokens[KEY_TOKEN].value;</span><br><span class="line">    nkey = tokens[KEY_TOKEN].length;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: sanity check &amp; stat</span></span><br><span class="line"></span><br><span class="line">    it = item_get(key, nkey, c); <span class="comment">// scr: -------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">if</span> (it) &#123;</span><br><span class="line">        MEMCACHED_COMMAND_DELETE(c-&gt;sfd, ITEM_key(it), it-&gt;nkey);</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">        item_unlink(it); <span class="comment">// scr: ---------------------------------&gt; 2)</span></span><br><span class="line">        item_remove(it);      <span class="comment">/* release our reference */</span></span><br><span class="line">        out_string(c, <span class="string">"DELETED"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">        out_string(c, <span class="string">"NOT_FOUND"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_delete_command@memcached.c</text></center><p>1) Get the <strong>item</strong> using <code>item_get</code> discussed in last section. Note that the reference count is increased in <code>item_get</code>.</p><p>2) Delete it.</p><h2 id="do-item-unlink"><a href="#do-item-unlink" class="headerlink" title="do_item_unlink"></a>do_item_unlink</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_unlink">item_unlink</a> is a thread safe wrapper of <code>do_item_unlink</code>.<br><br><div id="item_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_unlink</span><span class="params">(item *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(ITEM_key(item), item-&gt;nkey);</span><br><span class="line">    item_lock(hv);</span><br><span class="line">    do_item_unlink(item, hv);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_unlink@thread.c</text></center><p></p></div><p></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_unlink</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_LINKED;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">        assoc_delete(ITEM_key(it), it-&gt;nkey, hv); <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">        item_unlink_q(it); <span class="comment">// scr: -------------------------------&gt; 2)</span></span><br><span class="line">        do_item_remove(it); <span class="comment">// scr: ------------------------------&gt; 3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@items.c</text></center><p>1) As discussed in last post, <a href="/understanding-memcached-source-code-IV/#assoc-delete-remove-from-hash-map">assoc_delete</a> removes the <strong>item</strong> from the <em>hash map</em>; and</p><p>2) <a href="/understanding-memcached-source-code-IV/#item-unlink-q-remove-from-linked-list">item_unlink_q</a> removes the <strong>item</strong> from the <strong>LRU list</strong> that the <strong>item</strong> belongs to.</p><p>3) This time <code>do_item_remove</code> simply decreases the reference count. The <strong>item</strong> will be removed when <code>do_item_remove</code> is called the second time from</p><h2 id="do-item-remove"><a href="#do-item-remove" class="headerlink" title="do_item_remove"></a>do_item_remove</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_remove">item_remove</a> is a thread safe wrapper of <code>do_item_remove</code>.<br><br><div id="item_remove" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_remove</span><span class="params">(item *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(ITEM_key(item), item-&gt;nkey);</span><br><span class="line"></span><br><span class="line">    item_lock(hv);</span><br><span class="line">    do_item_remove(item);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_remove@thread.c</text></center><p></p></div><p></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_remove</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (refcount_decr(&amp;it-&gt;refcount) == <span class="number">0</span>) &#123; <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">        item_free(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_free</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ntotal = ITEM_ntotal(it);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> clsid;</span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* so slab size changer can tell later if item is already free or not */</span></span><br><span class="line">    clsid = ITEM_clsid(it); <span class="comment">// scr: -------------------------&gt; 2)</span></span><br><span class="line">    DEBUG_REFCNT(it, <span class="string">'F'</span>);</span><br><span class="line">    slabs_free(it, ntotal, clsid); <span class="comment">// scr: ------------------&gt; 3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_remove@items.c</text></center><p>1) Decrease the reference count, if it reaches <code>0</code>, goto 2) and free the <strong>item</strong>.</p><p>2) Use <a href="#" onclick="return false;" data-toggle="collapse" data-target="#ITEM_clsid">ITEM_clsid</a> to get the <em>slab class</em> the <strong>item</strong> belongs. This macro removes the <em>list type</em> from <code>slabs_clsid</code>.</p><div id="ITEM_clsid" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_clsid(item) ((item)-&gt;slabs_clsid &amp; ~(3&lt;&lt;6))</span></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.h:116</text></center><br></div><p>3) Call <a href="/understanding-memcached-source-code-II/#do-slabs-free">slabs_free</a> to release the memory to slab subsystem.</p><h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><p>The <strong>Item</strong> creating procedure is divided into several logic fragments by the mentioned <strong>drive machine</strong>, 1) creating an empty <strong>item</strong> object with the <em>key</em> and other <em>meta data</em> sent through; 2) read the value (from the <em>socket</em>) and fill the <strong>item</strong> object with it; and 3) <em>link</em> the <strong>item object</strong>. The workflow controller - <strong>drive machine</strong> will be discussed in the next post.</p><p>Now we send an <code>add</code> command to the <strong>Memcached</strong> instance.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; add test 0 60 11 (\r\n)</span><br><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure><h2 id="Creating-an-empty-item-object"><a href="#Creating-an-empty-item-object" class="headerlink" title="Creating an empty item object"></a>Creating an empty item object</h2><p>After the first line of the above command</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; add test 0 60 11 (\r\n)</span><br></pre></td></tr></table></figure><p>the procedure described in this section starts, the call stack of the hot path is,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line">1 |~Drive machine &amp; command parser</span><br><span class="line">    |-process_update_command</span><br><span class="line">      |-do_item_alloc</span><br><span class="line">        |-slabs_clsid                (Slab III)</span><br><span class="line">++      |-do_slabs_alloc             (Slab III)</span><br><span class="line">        |-lru_pull_tail (on hot list)</span><br><span class="line">          |-do_item_update_nolock    (same to do_item_update)</span><br><span class="line">          |-do_item_remove</span><br><span class="line">          |-item_link_q              (LRU I)</span><br><span class="line">          |-do_item_remove</span><br><span class="line">        |-lru_pull_tail (on warm list)</span><br><span class="line">          |-same as hot list</span><br><span class="line">        |-lru_pull_tail (on cold list)</span><br><span class="line">          |-do_item_unlink_nolock    (same to do_item_unlink LRU I)</span><br></pre></td></tr></table></figure><p>We start from</p><h3 id="process-update-command"><a href="#process-update-command" class="headerlink" title="process_update_command"></a>process_update_command</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_update_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">const</span> <span class="keyword">size_t</span> ntokens, <span class="keyword">int</span> comm, <span class="keyword">bool</span> handle_cas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int32_t</span> exptime_int = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">time_t</span> exptime;</span><br><span class="line">    <span class="keyword">int</span> vlen;</span><br><span class="line">    <span class="keyword">uint64_t</span> req_cas_id=<span class="number">0</span>;</span><br><span class="line">    item *it;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: irrelevant code &amp; sanity checks</span></span><br><span class="line"></span><br><span class="line">    key = tokens[KEY_TOKEN].value; <span class="comment">// scr: ----------------------&gt; 1)</span></span><br><span class="line">    nkey = tokens[KEY_TOKEN].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! (safe_strtoul(tokens[<span class="number">2</span>].value, (<span class="keyword">uint32_t</span> *)&amp;flags)</span><br><span class="line">           &amp;&amp; safe_strtol(tokens[<span class="number">3</span>].value, &amp;exptime_int)</span><br><span class="line">           &amp;&amp; safe_strtol(tokens[<span class="number">4</span>].value, (<span class="keyword">int32_t</span> *)&amp;vlen))) &#123;</span><br><span class="line">        out_string(c, <span class="string">"CLIENT_ERROR bad command line format"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */</span></span><br><span class="line">    exptime = exptime_int;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: cas &amp; sanity checks</span></span><br><span class="line"></span><br><span class="line">    vlen += <span class="number">2</span>; <span class="comment">// scr: ------------------------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    it = item_alloc(key, nkey, flags, realtime(exptime), vlen); <span class="comment">// 3)</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: cas &amp; error handling</span></span><br><span class="line"></span><br><span class="line">    c-&gt;item = it; <span class="comment">// scr: ---------------------------------------&gt; 4)</span></span><br><span class="line">    c-&gt;ritem = ITEM_data(it);</span><br><span class="line">    c-&gt;rlbytes = it-&gt;nbytes;</span><br><span class="line">    c-&gt;cmd = comm;</span><br><span class="line">    conn_set_state(c, conn_nread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_update_command@memcached.c</text></center><p>1) Set the <em>key</em> (i.e., <code>test</code>), as well as the <em>meta data</em> (i.e., <code>flags</code>, <code>0</code>; <code>exptime</code>, <code>60;</code>vlen<code>,</code>11`), to local variables.</p><p>2) Increase <code>vlen</code> by <code>2</code>, to populate the <code>\n\r</code> in addition to the <em>key</em> string.</p><p>3) Call <code>item_alloc</code> to allocate the memory (from <a href="/understanding-memcached-source-code-III/">slab</a>) for the <strong>item</strong>.</p><p>4) After <code>item_alloc</code> is called, set the properties of <code>conn</code>. Here <code>ritem</code> points to the data portion of an <a href="/understanding-memcached-source-code-IV/#Memory-layout-of-an-item-chunk">item chunk</a>; and <code>rlbytes</code> is set to <code>vlen</code>. These two fields will be used to populate the data portion with the content, i.e., <code>hello world</code>, in the next post.</p><h3 id="do-item-alloc"><a href="#do-item-alloc" class="headerlink" title="do_item_alloc"></a>do_item_alloc</h3><p>Unlike other methods we have discussed, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_alloc">item_alloc</a> is a wrapper of <code>do_item_alloc</code> without adding any locks. I would assume this wrapper is added simply for consistent code style.</p><div id="item_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">size_t</span> nkey, <span class="keyword">int</span> flags, <span class="keyword">rel_time_t</span> exptime, <span class="keyword">int</span> nbytes)</span> </span>&#123;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="comment">/* do_item_alloc handles its own locks */</span></span><br><span class="line">    it = do_item_alloc(key, nkey, flags, exptime, nbytes, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5849</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">do_item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">rel_time_t</span> exptime, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">uint8_t</span> nsuffix;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> suffix[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> total_chunks;       <span class="comment">// scr: -----------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">size_t</span> ntotal = item_make_header(nkey + <span class="number">1</span>, flags, nbytes, suffix, &amp;nsuffix);</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id = slabs_clsid(ntotal); <span class="comment">// scr: -----------------------&gt; 2)</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If no memory is available, attempt a direct LRU juggle/eviction */</span></span><br><span class="line">    <span class="comment">/* This is a race in order to simplify lru_pull_tail; in cases where</span></span><br><span class="line"><span class="comment">     * locked items are on the tail, you want them to fall out and cause</span></span><br><span class="line"><span class="comment">     * occasional OOM's, rather than internally work around them.</span></span><br><span class="line"><span class="comment">     * This also gives one fewer code path for slab alloc/free</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* Try to reclaim memory first */</span></span><br><span class="line">... <span class="comment">// scr: legacy, no lru_maintainer_thread</span></span><br><span class="line">        it = slabs_alloc(ntotal, id, &amp;total_chunks, <span class="number">0</span>); <span class="comment">// scr: ----------&gt; 3)</span></span><br><span class="line">... <span class="comment">// scr: no-expire setting</span></span><br><span class="line">        <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (settings.lru_maintainer_thread) &#123; <span class="comment">// scr: ----------------&gt; 4)</span></span><br><span class="line">                lru_pull_tail(id, HOT_LRU, total_chunks, <span class="literal">false</span>, cur_hv);</span><br><span class="line">                lru_pull_tail(id, WARM_LRU, total_chunks, <span class="literal">false</span>, cur_hv);</span><br><span class="line">                lru_pull_tail(id, COLD_LRU, total_chunks, <span class="literal">true</span>, cur_hv);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: legacy, no lru_maintainer_thread</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: stat &amp; sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Refcount is seeded to 1 by slabs_alloc() */</span></span><br><span class="line">    it-&gt;next = it-&gt;prev = it-&gt;h_next = <span class="number">0</span>; <span class="comment">// scr: ------------------------&gt; 5)</span></span><br><span class="line">    <span class="comment">/* Items are initially loaded into the HOT_LRU. This is '0' but I want at</span></span><br><span class="line"><span class="comment">     * least a note here. Compiler (hopefully?) optimizes this out.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (settings.lru_maintainer_thread) &#123;</span><br><span class="line">... <span class="comment">// scr: no expire setting</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id |= HOT_LRU; <span class="comment">// scr: ---------------------------------------&gt; 6)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: legacy, no lru_maintainer_thread</span></span><br><span class="line">    &#125;</span><br><span class="line">    it-&gt;slabs_clsid = id; <span class="comment">// scr: ----------------------------------------&gt; 7)</span></span><br><span class="line"></span><br><span class="line">    DEBUG_REFCNT(it, <span class="string">'*'</span>);</span><br><span class="line">    it-&gt;it_flags = settings.use_cas ? ITEM_CAS : <span class="number">0</span>;</span><br><span class="line">    it-&gt;nkey = nkey;</span><br><span class="line">    it-&gt;nbytes = nbytes;</span><br><span class="line">    <span class="built_in">memcpy</span>(ITEM_key(it), key, nkey);</span><br><span class="line">    it-&gt;exptime = exptime;</span><br><span class="line">    <span class="built_in">memcpy</span>(ITEM_suffix(it), suffix, (<span class="keyword">size_t</span>)nsuffix);</span><br><span class="line">    it-&gt;nsuffix = nsuffix;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_alloc@items.c</text></center><p>1) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_make_header">item_make_header</a> initializes <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">suffix</a> portion of the <a href="/understanding-memcached-source-code-IV/#Memory-layout-of-an-item-chunk">item chunk</a> using the <em>meta data</em> (<code>flags</code>) and <em>key</em>.</p><div id="item_make_header" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">item_make_header</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> nkey, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">char</span> *suffix, <span class="keyword">uint8_t</span> *nsuffix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* suffix is defined at 40 chars elsewhere.. */</span></span><br><span class="line">    *nsuffix = (<span class="keyword">uint8_t</span>) <span class="built_in">snprintf</span>(suffix, <span class="number">40</span>, <span class="string">" %u %d\r\n"</span>, flags, nbytes - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(item) + nkey + *nsuffix + nbytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_make_header@items.c</text></center><br></div><p>2), 3) are discussed in detail in <a href="/understanding-memcached-source-code-III/">Slab III</a>. To recap, <a href="/understanding-memcached-source-code-III/#slabs-clsid">slabs_clsid</a> select the most optimal <em>slab class</em> and <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">slab_alloc</a> allocates one <strong>item chunk</strong> from <strong>slab</strong> sub-system.</p><p>4) If <code>slab_alloc</code> fails, try to release some memory using <code>lru_pull_tail</code> and retry the allocation for at most <code>5</code> times. <code>lru_pull_tail</code> is the focus of the <a href="#lru-pull-tail">next section</a>.</p><p>5) Initialize the <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">pointers</a> of <strong>LRU list</strong> and <em>hash collision list</em>.</p><p>6) Set the <em>list type</em> (<code>HOT_LRU</code>) to the <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">slabs_clsid</a>, which indicates that this <strong>item</strong> belongs to the “HOT” <strong>LRU list</strong> of its respective <em>slab class</em>.</p><p>7) Initialize <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">other fields</a> of <strong>item</strong>.</p><h3 id="lru-pull-tail"><a href="#lru-pull-tail" class="headerlink" title="lru_pull_tail"></a>lru_pull_tail</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lru_pull_tail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> orig_id, <span class="keyword">const</span> <span class="keyword">int</span> cur_lru,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> total_chunks, <span class="keyword">const</span> <span class="keyword">bool</span> do_evict, <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv)</span> </span>&#123;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> id = orig_id; <span class="comment">// scr: ---------------------------------------&gt; p)</span></span><br><span class="line">    <span class="keyword">int</span> removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tries = <span class="number">5</span>;</span><br><span class="line">    item *search;</span><br><span class="line">    item *next_it;</span><br><span class="line">    <span class="keyword">void</span> *hold_lock = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> move_to_lru = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> limit;</span><br><span class="line"></span><br><span class="line">    id |= cur_lru; <span class="comment">// scr: ------------------------------------------&gt; p)</span></span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[id]);</span><br><span class="line">    search = tails[id]; <span class="comment">// scr: -------------------------------------&gt; p)</span></span><br><span class="line">    <span class="comment">/* We walk up *only* for locked items, and if bottom is expired. */</span></span><br><span class="line">    <span class="keyword">for</span> (; tries &gt; <span class="number">0</span> &amp;&amp; search != <span class="literal">NULL</span>; tries--, search=next_it) &#123;<span class="comment">//s: p)</span></span><br><span class="line">        <span class="comment">/* we might relink search mid-loop, so search-&gt;prev isn't reliable */</span></span><br><span class="line">        next_it = search-&gt;prev; <span class="comment">// scr: -----------------------------&gt; p)</span></span><br><span class="line">...<span class="comment">// scr: irrelevant code here</span></span><br><span class="line">        <span class="keyword">uint32_t</span> hv = hash(ITEM_key(search), search-&gt;nkey);</span><br><span class="line">        <span class="comment">/* Attempt to hash item lock the "search" item. If locked, no</span></span><br><span class="line"><span class="comment">         * other callers can incr the refcount. Also skip ourselves. */</span></span><br><span class="line">        <span class="keyword">if</span> (hv == cur_hv || (hold_lock = item_trylock(hv)) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/* Now see if the item is refcount locked */</span></span><br><span class="line">        <span class="keyword">if</span> (refcount_incr(&amp;search-&gt;refcount) != <span class="number">2</span>) &#123; <span class="comment">// scr: --------&gt; s)</span></span><br><span class="line">            <span class="comment">/* Note pathological case with ref'ed items in tail.</span></span><br><span class="line"><span class="comment">             * Can still unlink the item, but it won't be reusable yet */</span></span><br><span class="line">            itemstats[id].lrutail_reflocked++;</span><br><span class="line">            <span class="comment">/* In case of refcount leaks, enable for quick workaround. */</span></span><br><span class="line">            <span class="comment">/* WARNING: This can cause terrible corruption */</span></span><br><span class="line">            <span class="keyword">if</span> (settings.tail_repair_time &amp;&amp;</span><br><span class="line">                    search-&gt;time + settings.tail_repair_time &lt; current_time) &#123;</span><br><span class="line">                itemstats[id].tailrepairs++;</span><br><span class="line">                search-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/* This will call item_remove -&gt; item_free since refcnt is 1 */</span></span><br><span class="line">                do_item_unlink_nolock(search, hv);</span><br><span class="line">                item_trylock_unlock(hold_lock);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Expired or flushed */</span> <span class="comment">// scr: ---------------------------&gt; e1)</span></span><br><span class="line">        <span class="keyword">if</span> ((search-&gt;exptime != <span class="number">0</span> &amp;&amp; search-&gt;exptime &lt; current_time)</span><br><span class="line">            || item_is_flushed(search)) &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">            <span class="comment">/* refcnt 2 -&gt; 1 */</span></span><br><span class="line">            do_item_unlink_nolock(search, hv);</span><br><span class="line">            <span class="comment">/* refcnt 1 -&gt; 0 -&gt; item_free */</span></span><br><span class="line">            do_item_remove(search);</span><br><span class="line">            item_trylock_unlock(hold_lock);</span><br><span class="line">            removed++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If all we're finding are expired, can keep going */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we're HOT_LRU or WARM_LRU and over size limit, send to COLD_LRU.</span></span><br><span class="line"><span class="comment">         * If we're COLD_LRU, send to WARM_LRU unless we need to evict</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (cur_lru) &#123;</span><br><span class="line">            <span class="keyword">case</span> HOT_LRU: <span class="comment">// scr: -----------------------------------&gt; 1)</span></span><br><span class="line">                limit = total_chunks * settings.hot_lru_pct / <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> WARM_LRU:</span><br><span class="line">                limit = total_chunks * settings.warm_lru_pct / <span class="number">100</span>; <span class="comment">// 1)</span></span><br><span class="line">                <span class="keyword">if</span> (sizes[id] &gt; limit) &#123; <span class="comment">// scr: --------------------&gt; 2)</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                    move_to_lru = COLD_LRU;</span><br><span class="line">                    do_item_unlink_q(search);</span><br><span class="line">                    it = search;</span><br><span class="line">                    removed++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((search-&gt;it_flags &amp; ITEM_ACTIVE) != <span class="number">0</span>) &#123; <span class="comment">//e3)</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                    search-&gt;it_flags &amp;= ~ITEM_ACTIVE;</span><br><span class="line">                    do_item_update_nolock(search);</span><br><span class="line">                    do_item_remove(search);</span><br><span class="line">                    item_trylock_unlock(hold_lock);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ------------------------------------&gt; 3)</span></span><br><span class="line">                    <span class="comment">/* Don't want to move to COLD, not active, bail out */</span></span><br><span class="line">                    it = search;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> COLD_LRU:</span><br><span class="line">                it = search; <span class="comment">/* No matter what, we're stopping */</span></span><br><span class="line">                <span class="keyword">if</span> (do_evict) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (settings.evict_to_free == <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applied here</span></span><br><span class="line">                    &#125;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                    LOGGER_LOG(<span class="literal">NULL</span>, LOG_EVICTIONS, LOGGER_EVICTION, search);</span><br><span class="line">                    do_item_unlink_nolock(search, hv); <span class="comment">// scr: ------&gt; 4)</span></span><br><span class="line">                    removed++;</span><br><span class="line">                    <span class="keyword">if</span> (settings.slab_automove == <span class="number">2</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applied here</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">...<span class="comment">// scr: not applied here</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[id]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: --------------------------------------&gt; e2)</span></span><br><span class="line">        <span class="keyword">if</span> (move_to_lru) &#123;</span><br><span class="line">            it-&gt;slabs_clsid = ITEM_clsid(it);</span><br><span class="line">            it-&gt;slabs_clsid |= move_to_lru;</span><br><span class="line">            item_link_q(it);</span><br><span class="line">        &#125;</span><br><span class="line">        do_item_remove(it);</span><br><span class="line">        item_trylock_unlock(hold_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">lru_pull_tail@items.c</text></center><p><strong>Method start &amp; end</strong></p><p>p) This method starts by selecting the tail element of the designated <strong>LRU list</strong> using the <strong>slab class</strong> id and the <em>list type</em>, assuming that the element can be a release candidate. And it iterates over (at most <code>5</code> entries) the list in reverse order to find a entry in case that elements near the tail are recently <a href="#Read">accessed</a>.</p><p>s) For each <strong>item</strong> selected, increase its <em>reference count</em>. In normal situation, the original value of <em>reference count</em> should be <code>1</code> (as you will see in the <a href="#Populate-the-data-amp-Link-the-item">last step</a> of the create operation). Hence a <code>!= 2</code> value after the increment indicates an exception that needs to be corrected. Note that the reference count is now 2 so it is required to decrease at least one time (back to 1) when the processing of the current item is done (e1, e2 or e3 is reached).</p><p>e1) Remove the <strong>item</strong> directly when an expiration is detected. Here the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_unlink_nolock">do_item_unlink_nolock</a> is exactly the same as the discussed <a href="#item-unlink">do_item_unlink</a> (I think the code is duplicated to emphasize that this method is not thread-safe), and it follows the same “unlink and remove” routine as in <a href="#Delete">item delete</a>.</p><p>e2) When a candidate is found, we might need to relocate it to another <strong>list</strong> (when <code>move_to_lru</code> is set in the <code>switch</code> <code>case</code>) by calling <a href="/understanding-memcached-source-code-IV/#item-link-q-add-to-linked-list">item_link_q</a>. And we do need to call <a href="##item-remove">do_item_remove</a> to reduce the reference count back to <code>1</code>. The decision is made by the steps discussed bellow.</p><a href="#" id="opt2" style="visibility: hidden"></a><p>e3) If an <strong>item</strong> is recently accessed, reset the <code>ITEM_ACTIVE</code> flag; <em>bump</em> it to the head of the list; decrease its <em>reference count</em> and iterate to the next one (maximum <code>5</code> times). Remember that the flag <code>ITEM_ACTIVE</code> is set by <a href="/understanding-memcached-source-code-VI/#item-get">item_get</a>, and here is the place where the <strong>item</strong> gets <em>bumped</em>.</p><p><strong>Hot &amp; warm</strong></p><p>1) The only difference of <code>HOT_LRU</code> and <code>WARM_LRU</code> is the threshold (<code>limit</code>) which are indicated by their respective configurations <a href="#" onclick="return false;" data-toggle="collapse" data-target="#hot_lru_pct">hot_lru_pct</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#warm_lru_pct">warm_lru_pct</a>.</p><div id="hot_lru_pct" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.hot_lru_pct = <span class="number">32</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> HOT_LRU_PCT:</span><br><span class="line">    <span class="keyword">if</span> (subopts_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Missing hot_lru_pct argument\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    settings.hot_lru_pct = atoi(subopts_value);</span><br><span class="line">    <span class="keyword">if</span> (settings.hot_lru_pct &lt; <span class="number">1</span> || settings.hot_lru_pct &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"hot_lru_pct must be &gt; 1 and &lt; 80\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">hot_lru_pct@memcached.c</text></center><br></div><div id="warm_lru_pct" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.warm_lru_pct = <span class="number">32</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> WARM_LRU_PCT:</span><br><span class="line">    <span class="keyword">if</span> (subopts_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Missing warm_lru_pct argument\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    settings.warm_lru_pct = atoi(subopts_value);</span><br><span class="line">    <span class="keyword">if</span> (settings.warm_lru_pct &lt; <span class="number">1</span> || settings.warm_lru_pct &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"warm_lru_pct must be &gt; 1 and &lt; 80\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">warm_lru_pct@memcached.c</text></center><br></div><p>2) If the threshold of <code>HOT_LRU</code> or <code>WARM_LRU</code> is reached, remove the <strong>item</strong> from the current list using <a href="/understanding-memcached-source-code-IV/#item-unlink-q-remove-from-linked-list">do_item_unlink_q</a>, and goto e2). Therefore, e2) is responsible to relink it to the <code>COLD_LRU</code> and decrease the reference count.</p><p>3) If the current <strong>item</strong> is not “active”, and the threshold is not reached, finish this method without any <strong>item</strong> relocation, nor release.</p><p><strong>Cold</strong></p><p>4) If there are any <strong>item</strong> in the list, evict it directly with the discussed <code>do_item_unlink_nolock</code> to free up its resource, and goto e1). Note that the default values of <a href="#" onclick="return false;" data-toggle="collapse" data-target="#evict_to_free">evict_to_free</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_automove">slab_automove</a> are set to values that disable their respective <code>if</code> blocks.</p><div id="evict_to_free" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.evict_to_free = <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:215</text></center><br></div><div id="slab_automove" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> MODERN:</span><br><span class="line">    <span class="comment">/* Modernized defaults. Need to add equivalent no_* flags</span></span><br><span class="line"><span class="comment">     * before making truly default. */</span></span><br><span class="line">...</span><br><span class="line">    settings.slab_automove = <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5824</text></center><br></div><p>Now we input the second line of the command</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure><p>and trigger the following procedures.</p><h2 id="Populate-the-item-with-content"><a href="#Populate-the-item-with-content" class="headerlink" title="Populate the item with content"></a>Populate the item with content</h2><p>As mentioned in <a href="#process-update-command">process_update_command</a>, the content we input is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#populated">populated</a> to <code>conn.item</code> using <code>conn.ritem</code> and <code>conn.rlbytes</code>. This step is handled by <strong>drive machine</strong> which will be discussed in detail in the next post.</p><div id="populated" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">res = read(c-&gt;sfd, c-&gt;ritem, c-&gt;rlbytes);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4421</text></center><br></div><p>Now we consider <code>conn.item</code> is filled with all relevant information, hence the next and final step is to</p><h2 id="Link-the-item"><a href="#Link-the-item" class="headerlink" title="Link the item"></a>Link the item</h2><p>the call stack of this step is</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line"><span class="number">2</span> |~Drive machine &amp; command parser</span><br><span class="line">    |-complete_nread</span><br><span class="line">      |-complete_nread_ascii</span><br><span class="line">        |-do_store_item</span><br><span class="line">        |=do_item_link      (LRU I)</span><br><span class="line">--      |-do_item_remove</span><br></pre></td></tr></table></figure><a href="#" onclick="return false;" data-toggle="collapse" data-target="#complete_nread">complete_nread</a> checks the protocol in use and moves directly to<br><br><div id="complete_nread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete_nread</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">    assert(c-&gt;protocol == ascii_prot</span><br><span class="line">           || c-&gt;protocol == binary_prot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;protocol == ascii_prot) &#123;</span><br><span class="line">        complete_nread_ascii(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;protocol == binary_prot) &#123;</span><br><span class="line">        complete_nread_binary(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">complete_nread@memcached.c</text></center><p></p></div><p></p><h3 id="complete-nread-ascii"><a href="#complete-nread-ascii" class="headerlink" title="complete_nread_ascii"></a>complete_nread_ascii</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete_nread_ascii</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    item *it = c-&gt;item;</span><br><span class="line">    <span class="keyword">int</span> comm = c-&gt;cmd;</span><br><span class="line">    <span class="keyword">enum</span> store_item_type ret;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(ITEM_data(it) + it-&gt;nbytes - <span class="number">2</span>, <span class="string">"\r\n"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        out_string(c, <span class="string">"CLIENT_ERROR bad data chunk"</span>); <span class="comment">// scr: -----&gt; 1)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret = store_item(it, comm, c);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">      <span class="keyword">case</span> STORED:</span><br><span class="line">          out_string(c, <span class="string">"STORED"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> EXISTS:</span><br><span class="line">          out_string(c, <span class="string">"EXISTS"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NOT_FOUND:</span><br><span class="line">          out_string(c, <span class="string">"NOT_FOUND"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NOT_STORED:</span><br><span class="line">          out_string(c, <span class="string">"NOT_STORED"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          out_string(c, <span class="string">"SERVER_ERROR Unhandled storage type."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scr: -------------------------------------------------------&gt; 2)</span></span><br><span class="line">    item_remove(c-&gt;item);       <span class="comment">/* release the c-&gt;item reference */</span></span><br><span class="line">    c-&gt;item = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_store_item@items.c</text></center><p>1) Call <code>store_item</code> to link the <strong>item</strong> to the <strong>LRU list</strong> and <strong>hash map</strong>.</p><p>2) The <em>reference count</em> is set to <code>1</code> by <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slab_alloc</a> in <a href="#do-item-alloc">do_item_alloc</a> and increased by <a href="/understanding-memcached-source-code-IV/#do-item-link">do_item_link</a> in <a href="#do-store-item">do_store_item</a>. So reduce it to the normal value, <code>1</code>, with <a href="#do-item-remove">item_remove</a>. The methods of those have all been discussed in detail.</p><h3 id="do-store-item"><a href="#do-store-item" class="headerlink" title="do_store_item"></a>do_store_item</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> store_item_type <span class="title">do_store_item</span><span class="params">(item *it, <span class="keyword">int</span> comm, conn *c, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key = ITEM_key(it);</span><br><span class="line">    item *old_it = do_item_get(key, it-&gt;nkey, hv, c); <span class="comment">// scr: ------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">enum</span> store_item_type stored = NOT_STORED;</span><br><span class="line"></span><br><span class="line">    item *new_it = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_it != <span class="literal">NULL</span> &amp;&amp; comm == NREAD_ADD) &#123;</span><br><span class="line">... <span class="comment">// scr: update logic</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!old_it &amp;&amp; (comm == NREAD_REPLACE</span><br><span class="line">        || comm == NREAD_APPEND || comm == NREAD_PREPEND))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* replace only replaces an existing value; don't store */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comm == NREAD_CAS) &#123;</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (comm == NREAD_APPEND || comm == NREAD_PREPEND) &#123;</span><br><span class="line">... <span class="comment">// scr: comm is NREAD_ADD (1)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stored == NOT_STORED &amp;&amp; failed_alloc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (old_it != <span class="literal">NULL</span>)</span><br><span class="line">                item_replace(old_it, it, hv);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                do_item_link(it, hv); <span class="comment">// scr: ----------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            stored = STORED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: irrelevant code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: cas</span></span><br><span class="line">    LOGGER_LOG(c-&gt;thread-&gt;l, LOG_MUTATIONS, LOGGER_ITEM_STORE, <span class="literal">NULL</span>,</span><br><span class="line">            stored, comm, ITEM_key(it), it-&gt;nkey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_store_item@items.c</text></center><p>1) The newly created <strong>item</strong> exists only in the <strong>slab</strong> subsystem, hence <a href="#do-item-get">do_item_get</a> returns <code>null</code> as there is no such record in <strong>hash map</strong> yet.</p><p>2) So in the context of <em>item creation</em>, <code>do_store_item</code> is essentially the same as <a href="/understanding-memcached-source-code-IV/#do-item-link">do_item_link</a>.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://memcached.org/blog/modern-lru/" target="_blank" rel="noopener">Replacing the cache replacement algorithm in memcached</a></p><p><a href="http://hourlyapps.blogspot.com/2010/06/examples-of-memcached-commands.html" target="_blank" rel="noopener">Examples of Memcached telnet commands</a></p><p><a href="https://blog.elijaa.org/2010/05/21/memcached-telnet-command-summary/#delete" target="_blank" rel="noopener">Memcached telnet command summary</a></p>]]></content>
    
    <summary type="html">
    
      In previous posts, we have discussed different facets of an item, i.e., slab, hash map and LRU list as well as their associated (CRUD) methods, which build up the internal procedures and perform client requests after the corresponding commands are parsed by the drive machine. This time we will go through those procedures by issuing telnet commands to a Memcached instance and see how the discussed modules work together on various item operations. We will also see the whole picture of LRU lists that maintain the property of ‘least recently used’ in accordance to those operations.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="LRU" scheme="https://holmeshe.me/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - LRU II</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-V/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-V/</id>
    <published>2018-12-17T22:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="#"><text style="color:black;font-weight:bold;">, II - this article</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>More often than not, the <strong>LRU</strong> algorithm is combined with a <strong>hash map</strong>, and is referred to as a LRU cache. </p><p>In a <strong>LRU-cache</strong>, the <strong>hash map</strong> enables fast accessing of <em>cached</em> objects; and <strong>LRU</strong> avoids the <em>cache</em> to grow infinitely by marking expired, or so called, <strong>least recently used</strong> objects. This time we examine the <strong>memcached</strong>‘s implementation of <strong>hash map</strong>.</p><a id="more"></a><h1 id="Overview-textbook-overlapped-skip"><a href="#Overview-textbook-overlapped-skip" class="headerlink" title="Overview (textbook overlapped, skip)"></a>Overview (textbook overlapped, <a href="#Module-initialization">skip</a>)</h1><p><strong>Hash map</strong> is basically a <em>fixed-sized</em> array that indexes <em>value</em>s with integers <strong>hashed</strong> from <em>key</em>s. In <strong>hash map</strong> an array entry is referred to as a <em>bucket</em>. If the <strong>hash value</strong> exceeds the number of buckets (i.e., array size), it <em>rolls over</em> using ‘mod’ (<code>%</code>). <em>Collision</em> occurs when more than two <em>key</em>s result in the same <strong>hash value</strong> or different <strong>hash value</strong>s roll over to the same bucket, then a *linked list is formed on the bucket in collision.</p><p><em>Collision</em> slows down lookups speed for the sequential access of <em>linked list</em>, hence it is required to increase the <em>bucket number</em>, and to <em>rehash</em> entries using the new <strong>bucket number</strong> before the performance goes too bad. This process will be discussed <a href="#Scale-up-amp-entry-migration">soon</a>.</p><h1 id="Module-initialization"><a href="#Module-initialization" class="headerlink" title="Module initialization"></a>Module initialization</h1><p>The first relevant method is</p><h2 id="hash-init"><a href="#hash-init" class="headerlink" title="hash_init"></a>hash_init</h2><p>which simply determines the hash algorithm type.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_init</span><span class="params">(<span class="keyword">enum</span> hashfunc_type type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> JENKINS_HASH:</span><br><span class="line">            hash = jenkins_hash;</span><br><span class="line">            settings.hash_algorithm = <span class="string">"jenkins"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MURMUR3_HASH:</span><br><span class="line">            hash = MurmurHash3_x86_32;</span><br><span class="line">            settings.hash_algorithm = <span class="string">"murmur3"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">hash_init@hash.c</text></center><p>This method is called from <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet1">here</a> as one of the init steps before the logic enters the main event loop.</p><div id="snippet1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (hash_init(hash_type) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to initialize hash_algorithm!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EX_USAGE);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5849</text></center><br></div><p>The parameter <code>hash_type</code> is set to <code>MURMUR3_HASH</code> by the mentioned command-line argument <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet2">modern</a>.</p><div id="snippet2" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> MODERN:</span><br><span class="line">                <span class="comment">/* Modernized defaults. Need to add equivalent no_* flags</span></span><br><span class="line"><span class="comment">                 * before making truly default. */</span></span><br><span class="line">...</span><br><span class="line">                hash_type = MURMUR3_HASH;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5849</text></center><br></div><p>The second method</p><h2 id="assoc-init"><a href="#assoc-init" class="headerlink" title="assoc_init"></a>assoc_init</h2><p>allocates the fixed sized array mentioned in the beginning.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assoc_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> hashtable_init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hashtable_init) &#123;</span><br><span class="line">        hashpower = hashtable_init;</span><br><span class="line">    &#125;</span><br><span class="line">    primary_hashtable = <span class="built_in">calloc</span>(hashsize(hashpower), <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="keyword">if</span> (! primary_hashtable) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to init hashtable.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">hash_init@hash.c</text></center><p>This method is called in a similar <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet3">location</a> as <code>hash_init</code> as part of the system bootstrap process.</p><div id="snippet3" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    assoc_init(settings.hashpower_init);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5976</text></center><br></div><p>And the actual initial size is determined by the command-line argument <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet4">hashpower</a>.</p><div id="snippet4" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> HASHPOWER_INIT:</span><br><span class="line">    <span class="keyword">if</span> (subopts_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Missing numeric argument for hashpower\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    settings.hashpower_init = atoi(subopts_value);</span><br><span class="line">    <span class="keyword">if</span> (settings.hashpower_init &lt; <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Initial hashtable multiplier of %d is too low\n"</span>,</span><br><span class="line">            settings.hashpower_init);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (settings.hashpower_init &gt; <span class="number">64</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Initial hashtable multiplier of %d is too high\n"</span></span><br><span class="line">            <span class="string">"Choose a value based on \"STAT hash_power_level\" from a running instance\n"</span>,</span><br><span class="line">            settings.hashpower_init);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5677</text></center><br></div><p>As said before, the array can be replaced with a newly allocated larger one if the performance drops due to excessive <em>collision</em>. Next we discuss the process of</p><h1 id="Scale-up-amp-entry-migration"><a href="#Scale-up-amp-entry-migration" class="headerlink" title="Scale up &amp; entry migration"></a>Scale up &amp; entry migration</h1><p>In <strong>memcached</strong>, the threshold is 1.5, meaning, if the <strong>item</strong>s number exceeds 1.5 * <strong>bucket number</strong>, the mentioned expanding process starts.</p><p><img src="/gallery/expanding.png" alt="Expand hash map"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (! expanding &amp;&amp; hash_items &gt; (hashsize(hashpower) * <span class="number">3</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        assoc_start_expand();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_insert@assoc.c:173</text></center><p>The <code>assoc_start_expand</code> simply set a flag (i.e., <code>do_run_maintenance_thread</code>), and send a signal to awake a maintenance thread that does the actual job.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assoc_start_expand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (started_expanding)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    started_expanding = <span class="literal">true</span>;</span><br><span class="line">    pthread_cond_signal(&amp;maintenance_cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_insert@assoc.c:173</text></center><h2 id="Maintenance-thread-main-loop"><a href="#Maintenance-thread-main-loop" class="headerlink" title="Maintenance thread main loop"></a>Maintenance thread main loop</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">assoc_maintenance_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  mutex_lock(&amp;maintenance_lock);</span><br><span class="line">  <span class="keyword">while</span> (do_run_maintenance_thread<span class="comment">/* scr: the flag*/</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There is only one expansion thread, so no need to global lock. */</span></span><br><span class="line">    <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; hash_bulk_move &amp;&amp; expanding; ++ii) &#123; <span class="comment">// scr: ----&gt; 2)</span></span><br><span class="line">      item *it, *next;</span><br><span class="line">      <span class="keyword">int</span> bucket;</span><br><span class="line">      <span class="keyword">void</span> *item_lock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* bucket = hv &amp; hashmask(hashpower) =&gt;the bucket of hash table</span></span><br><span class="line"><span class="comment">       * is the lowest N bits of the hv, and the bucket of item_locks is</span></span><br><span class="line"><span class="comment">       *  also the lowest M bits of hv, and N is greater than M.</span></span><br><span class="line"><span class="comment">       *  So we can process expanding with only one item_lock. cool! */</span></span><br><span class="line">      <span class="keyword">if</span> ((item_lock = item_trylock(expand_bucket))) &#123; <span class="comment">// scr: --------&gt; 3)</span></span><br><span class="line">        <span class="keyword">for</span> (it = old_hashtable[expand_bucket]; <span class="literal">NULL</span> != it; it = next) &#123;</span><br><span class="line">          next = it-&gt;h_next; <span class="comment">// scr: ----------------------------------&gt; 4)</span></span><br><span class="line">          bucket = hash(ITEM_key(it), it-&gt;nkey) &amp; hashmask(hashpower);</span><br><span class="line">          it-&gt;h_next = primary_hashtable[bucket];</span><br><span class="line">          primary_hashtable[bucket] = it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        old_hashtable[expand_bucket] = <span class="literal">NULL</span>; <span class="comment">// scr: ----------------&gt; 4.1)</span></span><br><span class="line"></span><br><span class="line">        expand_bucket++; <span class="comment">// scr: --------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (expand_bucket == hashsize(hashpower - <span class="number">1</span>)) &#123; <span class="comment">// scr: -------&gt; 6)</span></span><br><span class="line">          expanding = <span class="literal">false</span>;</span><br><span class="line">          <span class="built_in">free</span>(old_hashtable);</span><br><span class="line">... <span class="comment">// scr: ---------------------------------------------------&gt; stat &amp; log</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        usleep(<span class="number">10</span>*<span class="number">1000</span>); <span class="comment">// scr: ------------------------------------&gt; 3.1)</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (item_lock) &#123; <span class="comment">// scr: --------------------------------------&gt; 3.2)</span></span><br><span class="line">        item_trylock_unlock(item_lock);</span><br><span class="line">        item_lock = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!expanding) &#123;</span><br><span class="line">      <span class="comment">/* We are done expanding.. just wait for next invocation */</span></span><br><span class="line">      started_expanding = <span class="literal">false</span>;</span><br><span class="line">      pthread_cond_wait(&amp;maintenance_cond, &amp;maintenance_lock); <span class="comment">// scr: &gt; 0)</span></span><br><span class="line">      <span class="comment">/* assoc_expand() swaps out the hash table entirely, so we need</span></span><br><span class="line"><span class="comment">       * all threads to not hold any references related to the hash</span></span><br><span class="line"><span class="comment">       * table while this happens.</span></span><br><span class="line"><span class="comment">       * This is instead of a more complex, possibly slower algorithm to</span></span><br><span class="line"><span class="comment">       * allow dynamic hash table expansion without causing significant</span></span><br><span class="line"><span class="comment">       * wait times.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      pause_threads(PAUSE_ALL_THREADS);</span><br><span class="line">      assoc_expand(); <span class="comment">// scr: -----------------------------------------&gt; 1)</span></span><br><span class="line">      pause_threads(RESUME_ALL_THREADS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_maintenance_thread@assoc.c</text></center><p>0) This is where the thread waits up from sleep and start working, and goes to sleep when there is nothing to be done.</p><p>1) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#assoc_expand">assoc_expand</a> allocates the resource for the new <strong>hash map</strong> which is meant to replace the old one initialized from <a href="#assoc-init">here</a>.</p><div id="assoc_expand" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* grows the hashtable to the next power of 2. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assoc_expand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    old_hashtable = primary_hashtable;</span><br><span class="line"></span><br><span class="line">    primary_hashtable = <span class="built_in">calloc</span>(hashsize(hashpower + <span class="number">1</span>), <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="keyword">if</span> (primary_hashtable) &#123;</span><br><span class="line">... <span class="comment">// scr: log</span></span><br><span class="line">        hashpower++;</span><br><span class="line">        expanding = <span class="literal">true</span>;</span><br><span class="line">        expand_bucket = <span class="number">0</span>;</span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        primary_hashtable = old_hashtable;</span><br><span class="line">        <span class="comment">/* Bad news, but we can keep running. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_expand@assoc.c</text></center><br></div><p>2) Only migrate a certain number of <strong>item</strong>s in one batch. <a href="#" onclick="return false;" data-toggle="collapse" data-target="#hash_bulk_move">hash_bulk_move</a> avoids the thread hanging around too long when <a href="#" onclick="return false;" data-toggle="collapse" data-target="#stop_assoc_maintenance_thread">stop_assoc_maintenance_thread</a> is called. In contrast to the discussed <code>assoc_start_expand</code>, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#stop_assoc_maintenance_thread">stop_assoc_maintenance_thread</a> reset the flag <code>do_run_maintenance_thread</code> and send the signal to wake up the thread to exit.</p><div id="hash_bulk_move" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_HASH_BULK_MOVE 1</span></span><br><span class="line"><span class="keyword">int</span> hash_bulk_move = DEFAULT_HASH_BULK_MOVE;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc.c:207</text></center><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">char</span> *env = getenv(<span class="string">"MEMCACHED_HASH_BULK_MOVE"</span>);</span><br><span class="line">    <span class="keyword">if</span> (env != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        hash_bulk_move = atoi(env);</span><br><span class="line">        <span class="keyword">if</span> (hash_bulk_move == <span class="number">0</span>) &#123;</span><br><span class="line">            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">start_assoc_maintenance_thread@assoc.c:281</text></center><br></div><div id="stop_assoc_maintenance_thread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_assoc_maintenance_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mutex_lock(&amp;maintenance_lock);</span><br><span class="line">    do_run_maintenance_thread = <span class="number">0</span>;</span><br><span class="line">    pthread_cond_signal(&amp;maintenance_cond);</span><br><span class="line">    mutex_unlock(&amp;maintenance_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for the maintenance thread to stop */</span></span><br><span class="line">    pthread_join(maintenance_tid, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">stop_assoc_maintenance_thread@assoc.c</text></center><br></div><p>3) (The “item lock” actually works on the whole <em>bucket</em> hence I will call it <em>bucket lock</em> instead) Use low priority <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_trylock">item_trylock</a> (<code>i.e., pthread_mutex_trylock</code>) to access the <em>bucket lock</em>; 3.1) sleep for 10 sec when the the <strong>item</strong> is not available; and 3.2) release the lock using <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_trylock_unlock">item_trylock_unlock</a> when the migration (of this <em>bucket</em>) completes.</p><div id="item_trylock" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">item_trylock</span><span class="params">(<span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> *lock = &amp;item_locks[hv &amp; hashmask(item_lock_hashpower)];</span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_trylock(lock) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_trylock@thread.c</text></center><br></div><div id="item_trylock_unlock" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_trylock_unlock</span><span class="params">(<span class="keyword">void</span> *lock)</span> </span>&#123;</span><br><span class="line">    mutex_unlock((<span class="keyword">pthread_mutex_t</span> *) lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_trylock@thread.c</text></center><br></div><p>4) Rehash all the <strong>item</strong>s in the bucket, and migrate them to the new hash map.</p><p>5) Move on to the next <em>bucket</em>.</p><p>6) Last <em>bucket</em> reached -&gt; go to 0)</p><h2 id="Maintenance-thread-start"><a href="#Maintenance-thread-start" class="headerlink" title="Maintenance thread start"></a>Maintenance thread start</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">start_assoc_maintenance_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *env = getenv(<span class="string">"MEMCACHED_HASH_BULK_MOVE"</span>);</span><br><span class="line">    <span class="keyword">if</span> (env != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        hash_bulk_move = atoi(env);</span><br><span class="line">        <span class="keyword">if</span> (hash_bulk_move == <span class="number">0</span>) &#123;</span><br><span class="line">            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_init(&amp;maintenance_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret = pthread_create(&amp;maintenance_tid, <span class="literal">NULL</span>,</span><br><span class="line">                              assoc_maintenance_thread, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't create thread: %s\n"</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">start_assoc_maintenance_thread@assoc.c</text></center><p>Similar to initialization <a href="#Module-initialization">methods</a>, it is called during system <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet5">bootstrap</a>. </p><div id="snippet5" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (start_assoc_maintenance_thread() == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5992</text></center><br></div><h2 id="Maintenance-thread-stop"><a href="#Maintenance-thread-stop" class="headerlink" title="Maintenance thread stop"></a>Maintenance thread stop</h2><p>This method is called in system <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet6">shutdown</a> process, hence it is opposite in logic to <code>start_assoc_maintenance_thread</code>. Nevertheless, the operations of this method are opposite that of <code>assoc_start_expand</code> mechanism wise.</p><div id="snippet6" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    stop_assoc_maintenance_thread();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:6098</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_assoc_maintenance_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mutex_lock(&amp;maintenance_lock);</span><br><span class="line">    do_run_maintenance_thread = <span class="number">0</span>;</span><br><span class="line">    pthread_cond_signal(&amp;maintenance_cond);</span><br><span class="line">    mutex_unlock(&amp;maintenance_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for the maintenance thread to stop */</span></span><br><span class="line">    pthread_join(maintenance_tid, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">stop_assoc_maintenance_thread@assoc.c</text></center><p>As said before, the expanding &amp; migration process discussed here has an impact on the logic of all <strong>hash map</strong> related operations. In the next section, we look at these operations.</p><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><p>N.b., <code>assoc_delete</code> has been discussed in the <a href="/understanding-memcached-source-code-IV/#assoc-delete-remove-from-hash-map">last post</a>; and in a key-value system <em>update</em> and <em>insert</em> are essentially the same, thus, this section will discuss the operations of <em>C</em> (create) and <em>R</em> (read) only.</p><h2 id="assoc-insert"><a href="#assoc-insert" class="headerlink" title="assoc_insert"></a>assoc_insert</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">assoc_insert</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expanding &amp;&amp;</span><br><span class="line">        (oldbucket = (hv &amp; hashmask(hashpower - <span class="number">1</span>))) &gt;= expand_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        it-&gt;h_next = old_hashtable[oldbucket]; <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">        old_hashtable[oldbucket] = it;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;h_next = primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr: &gt; 2)</span></span><br><span class="line">        primary_hashtable[hv &amp; hashmask(hashpower)] = it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;hash_items_counter_lock);</span><br><span class="line">    hash_items++; <span class="comment">// scr: ------------------------------------------------&gt; 3)</span></span><br><span class="line">    <span class="keyword">if</span> (! expanding &amp;&amp; hash_items &gt; (hashsize(hashpower) * <span class="number">3</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        assoc_start_expand();</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;hash_items_counter_lock);</span><br><span class="line"></span><br><span class="line">    MEMCACHED_ASSOC_INSERT(ITEM_key(it), it-&gt;nkey, hash_items);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_insert@assoc.c</text></center><p>1) If expanding process is undergoing and the <em>hash key</em> associated bucket has not been migrated, insert the item to <code>old_hashtable</code>. Note that here we use the old <em>bucket number</em> (i.e., <code>hashmask(hashpower - 1))</code>) to calculate the hash index.</p><p>2) Otherwise, insert the <strong>item</strong>to <code>primary_hashtable</code> directly.</p><p>3) Increase the global variable <a href="#" onclick="return false;" data-toggle="collapse" data-target="#hash_items">hash_items</a> (number of <strong>item</strong>s). If it exceeds the threshold after the <strong>item</strong> is added, start expanding &amp; migration process. Note that this is also the preamble of <a href="#Scale-up-amp-entry-migration">the last section</a>.</p><div id="hash_items" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_items = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc.c:51</text></center><br></div><h2 id="assoc-find"><a href="#assoc-find" class="headerlink" title="assoc_find"></a>assoc_find</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">assoc_find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expanding &amp;&amp;</span><br><span class="line">        (oldbucket = (hv &amp; hashmask(hashpower - <span class="number">1</span>))) &gt;= expand_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        it = old_hashtable[oldbucket]; <span class="comment">// scr: ---------------------------&gt; 1)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it = primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr: --------&gt; 2)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (it) &#123; <span class="comment">// scr: -------------------------------------------------&gt; 3)</span></span><br><span class="line">        <span class="keyword">if</span> ((nkey == it-&gt;nkey) &amp;&amp; (<span class="built_in">memcmp</span>(key, ITEM_key(it), nkey) == <span class="number">0</span>)) &#123;</span><br><span class="line">            ret = it;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        it = it-&gt;h_next;</span><br><span class="line">        ++depth;</span><br><span class="line">    &#125;</span><br><span class="line">    MEMCACHED_ASSOC_FIND(key, nkey, depth);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_find@assoc.c</text></center><p>1) Similar to that of <a href="#assoc-insert">assoc_insert</a>, this step locates the bucket from <code>old_hashtable</code> when the key is yet to be rehashed.</p><p>2) Use <code>primary_hashtable</code> directly otherwise.</p><p>3) Go through the <em>linked list</em> and compare the <em>key</em> (instead of the <em>hash index</em>) directly to lookup the <strong>item</strong> in the case of <em>Collision</em>.</p><p>One thing worth noting is that <code>assoc_find</code> is very similar to <code>_hashitem_before</code> which has been discussed in the <a href="/understanding-memcached-source-code-IV/#assoc-delete-remove-from-hash-map">last post</a>. The difference here is, <code>_hashitem_before</code> returns the <strong>address of the next member of the element before the found one</strong> (<code>pos = &amp;(*pos)-&gt;h_next;</code>), which is required when removing entries from a <em>singly linked list</em>; whilst this method returns the element found directly (<code>ret = it;</code>).</p>]]></content>
    
    <summary type="html">
    
      More often than not, the LRU algorithm is combined with a hash map, and is referred to as a LRU cache. In a LRU-cache, the hash map enables fast accessing of cached objects; and LRU avoids the cache to grow infinitely by marking expired, or so called, least recently used objects. This time we examine the memcached‘s implementation of hash map.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="LRU" scheme="https://holmeshe.me/tags/LRU/"/>
    
      <category term="hash map" scheme="https://holmeshe.me/tags/hash-map/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - LRU I</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-IV/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-IV/</id>
    <published>2018-12-10T23:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I - this article</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>More often than not, the <strong>LRU</strong> algorithm is combined with a <strong>hash map</strong>, and is referred to as a </p><h1 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h1><p>In a <strong>LRU-cache</strong>, the <strong>hash map</strong> enables fast accessing of <em>cached</em> objects; and <strong>LRU</strong> avoids the <em>cache</em> to grow infinitely by marking expired, or so called, <strong>least recently used</strong> objects. Next we look at how <strong>LRU</strong> works from a high level standpoint.</p><a id="more"></a><h2 id="Linked-list"><a href="#Linked-list" class="headerlink" title="Linked list"></a>Linked list</h2><p>Technically, <strong>LRU</strong> algorithm works on a <em>linked list</em>, whenever a list entry is used (accessed or updated), it is removed from the list and be attached to the list head. In this way, the closer an element is to the list tail, the <strong>less recently used</strong> it is. Hence it is easy to remove irrelevant or “expired” elements from the tail based on a certain configuration.</p><h2 id="Harsh-map"><a href="#Harsh-map" class="headerlink" title="Harsh map"></a>Harsh map</h2><p><em>Linked list</em> is slow when it comes to element access, hence another data structure is employed. We have seen how <strong>linked list</strong> “strings” <em>chunks</em> in <strong>slabs</strong> to make <em>free list</em>s. In an <strong>LRU cache</strong>, the mechanism is similar, however, it is the <strong>hash map</strong> entries instead of <em>chunks</em> in <strong>slabs</strong> got wired up this time, which looks like:</p><p><img src="/gallery/lru.png" alt="hash map perspective"></p><p>We can also flatten the linked list, and make the structure a bit more clear,</p><p><img src="/gallery/lru-linked-list.png" alt="linked list perspective"></p><h1 id="Core-data-structure-item"><a href="#Core-data-structure-item" class="headerlink" title="Core data structure - item"></a>Core data structure - item</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protected by LRU locks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">/* Rest are protected by an item lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">h_next</span>;</span>    <span class="comment">/* hash chain next */</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      time;       <span class="comment">/* least recent access */</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      exptime;    <span class="comment">/* expire time */</span></span><br><span class="line">    <span class="keyword">int</span>             nbytes;     <span class="comment">/* size of data */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  refcount;</span><br><span class="line">    <span class="keyword">uint8_t</span>         nsuffix;    <span class="comment">/* length of flags-and-length string */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         nkey;       <span class="comment">/* key length, w/terminating null and padding */</span></span><br><span class="line">    <span class="comment">/* this odd type prevents type-punning issues when we do</span></span><br><span class="line"><span class="comment">     * the little shuffle to save space when not using CAS. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">        <span class="keyword">char</span> end; <span class="comment">// scr: flexible array member indicating the item header "end"</span></span><br><span class="line">    &#125; data[];</span><br><span class="line">    <span class="comment">/* if it_flags &amp; ITEM_CAS we have 8 bytes CAS */</span></span><br><span class="line">    <span class="comment">/* then null-terminated key */</span></span><br><span class="line">    <span class="comment">/* then " flags length\r\n" (no terminating null) */</span></span><br><span class="line">    <span class="comment">/* then data with terminating \r\n (no terminating null; it's binary!) */</span></span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@item.c</text></center><h2 id="Properties-in-discussion"><a href="#Properties-in-discussion" class="headerlink" title="Properties in discussion"></a>Properties in discussion</h2><p><code>next</code>, <code>prev</code> - <em>LRU list</em> pointers, initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="#item-link-q-add-to-linked-list">item_link_q</a>, <a href="#item-unlink-q-remove-from-linked-list">item_unlink_q</a></p><p><code>h_next</code> - <em>hash collision</em> list pointers, initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="#assoc-insert-add-to-hash-map">assoc_insert</a>, <a href="#assoc-delete-remove-from-hash-map">assoc_delete</a>, <a href="/understanding-memcached-source-code-II">various methods (LRU II)</a> </p><p><code>time</code> - last access time, set in <a href="#do-item-link">do_item_link</a>, used by <a href="(/understanding-memcached-source-code-VI/#lru-pull-tail">lru_pull_tail (LRU III)</a></p><p><code>exptime</code> - expire time indicated by request argument, initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="(/understanding-memcached-source-code-VI/#lru-pull-tail">lru_pull_tail (LRU III)</a></p><p><code>nbytes</code> - data size indicated by request argument, initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a></p><p><code>refcount</code> - reference cound, initialized in <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc (Slab III)</a>, used by <a href="#do-item-link">do_item_link</a></p><p><code>nsuffix</code> - initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> with <code>item_make_header</code></p><p><code>it_flags</code> - initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="#do-item-link">do_item_link</a>, <a href="#do-item-unlink">do_item_unlink</a></p><p><code>slabs_clsid</code> - the <strong>LRU</strong> list the <strong>item</strong> belongs, initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="#item-link-q-add-to-linked-list">item_link_q</a>, <a href="#item-unlink-q-remove-from-linked-list">item_unlink_q</a></p><p><code>nkey</code> - key size, calcuated in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="#assoc-delete-remove-from-hash-map">assoc_delete</a></p><h2 id="Memory-layout-of-an-item-chunk"><a href="#Memory-layout-of-an-item-chunk" class="headerlink" title="Memory layout of an item chunk"></a>Memory layout of an item chunk</h2><p>We have mentioned <em>item chunk</em> in <a href="/understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>. With the help of this data structure, we can now examine the chunk more closely.</p><p><img src="/gallery/item-chunk.png" alt="item chunk"></p><p>Next we read the relevant code that performs the above discussed LRU operations.</p><h1 id="do-item-link"><a href="#do-item-link" class="headerlink" title="do_item_link"></a>do_item_link</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_item_link</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123; <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">    it-&gt;it_flags |= ITEM_LINKED;                <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">    it-&gt;time = current_time;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate a new CAS ID on link. */</span></span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">    assoc_insert(it, hv);                       <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    item_link_q(it);                            <span class="comment">// scr: -------------------&gt; 4)</span></span><br><span class="line">    refcount_incr(&amp;it-&gt;refcount);               <span class="comment">// scr: -------------------&gt; 5)</span></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_link@item.c</text></center><p>1) <code>hv</code> is supposed to be the shortened “hashed value”.</p><p>2) Set <code>ITEM_LINKED</code> in <code>it-&gt;it_flags</code>, and set current time to <code>it-&gt;time</code>.</p><p class="back"><br>The field <code>it_flags</code> is used in <a href="/understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a> and <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc</a><br></p><p>3) Insert the <strong>item</strong> to hash map.</p><p>4) Insert the <strong>item</strong> to linked list.</p><p>5) Increase the <em>reference count</em>.</p><p class="back"><br>This field is initialized as <code>1</code> in <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc</a><br></p><p>It is worth noting here that <em>reference count</em> indicates how many sub-modules are using the same resource, so as to determine when to actually deallocate the resource (In this particular case, <strong>item</strong> is referred by both <strong>slab</strong> and <strong>LRU</strong>). I have written <a href="/cpp-pointers/">this article</a> that explains a similar mechanism of C++.</p><h2 id="item-link-q-add-to-linked-list"><a href="#item-link-q-add-to-linked-list" class="headerlink" title="item_link_q - add to linked list"></a>item_link_q - add to linked list</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_link_q">item_link_q</a> is a thread safe wrapper of the workhorse method <code>do_item_link_q</code>.<br><br><div id="item_link_q" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">item_link_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">    do_item_link_q(it);</span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_link_q@item.c</text></center><p></p></div><p></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_item_link_q</span><span class="params">(item *it)</span> </span>&#123; <span class="comment">/* item is the new head */</span></span><br><span class="line">    item **head, **tail;</span><br><span class="line">    assert((it-&gt;it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    head = &amp;heads[it-&gt;slabs_clsid];           <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">    tail = &amp;tails[it-&gt;slabs_clsid];</span><br><span class="line">    assert(it != *head);</span><br><span class="line">    assert((*head &amp;&amp; *tail) || (*head == <span class="number">0</span> &amp;&amp; *tail == <span class="number">0</span>));</span><br><span class="line">    it-&gt;prev = <span class="number">0</span>;                             <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">    it-&gt;next = *head;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it;</span><br><span class="line">    *head = it;</span><br><span class="line">    <span class="keyword">if</span> (*tail == <span class="number">0</span>) *tail = it;</span><br><span class="line">    sizes[it-&gt;slabs_clsid]++;                 <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_link_q@item.c</text></center><p>1) Get the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">head</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">tail</a> of the respective <strong>LRU linked list</strong> indicated by <code>slabs_clsid</code>. Note that the <code>slabs_clsid</code> is <em>salted</em> with the type of the queue, hence each <strong>slab group</strong> may enlist multiple <em>lists</em>.</p><p>2) Standard operations of “adding an element to the front”.</p><p>3) Increase the global array <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">sizes</a>.</p><div id="globals" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item *heads[LARGEST_ID];</span><br><span class="line"><span class="keyword">static</span> item *tails[LARGEST_ID];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> sizes[LARGEST_ID];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item.c:59</text></center><br></div><h2 id="assoc-insert-add-to-hash-map"><a href="#assoc-insert-add-to-hash-map" class="headerlink" title="assoc_insert - add to hash map"></a>assoc_insert - add to hash map</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">assoc_insert</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123; <span class="comment">// scr: again, hv -&gt; hash value</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;h_next = primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr:  1)</span></span><br><span class="line">        primary_hashtable[hv &amp; hashmask(hashpower)] = it;         // scr:  2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_insert@assoc.c</text></center><p>1) Deal with potential conflict. If there is no, the <code>h_next</code> is set to <code>null</code>.</p><p>2) Set the <strong>item</strong> to the bucket in <a href="#" onclick="return false;" data-toggle="collapse" data-target="#primary_hashtable">primary_hashtable</a>.</p><div id="primary_hashtable" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> item** primary_hashtable = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc.c:42</text></center><br></div><p>The expanding logic omitted here will be covered in the <a href="/understanding-memcached-source-code-V/#Scale-up-amp-entry-migration">next post</a>.</p><h1 id="do-item-unlink"><a href="#do-item-unlink" class="headerlink" title="do_item_unlink"></a>do_item_unlink</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_unlink</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it-&gt;nkey, it-&gt;nbytes);</span><br><span class="line">    <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_LINKED;         <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">        assoc_delete(ITEM_key(it), it-&gt;nkey, hv); <span class="comment">// scr: ---------------&gt; 2)</span></span><br><span class="line">        item_unlink_q(it);                    <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">        do_item_remove(it);                   <span class="comment">// scr: -------------------&gt; *)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@item.c</text></center><p>1) Clear <code>ITEM_LINKED</code> in <code>it-&gt;it_flags</code>.</p><p>2) Remove the <strong>item</strong> from hash map.</p><p>3) Remove the <strong>item</strong> from linked list.</p><p>*) The actual releasing of an <em>item</em> will be covered in later posts.</p><h2 id="item-unlink-q-remove-from-linked-list"><a href="#item-unlink-q-remove-from-linked-list" class="headerlink" title="item_unlink_q - remove from linked list"></a>item_unlink_q - remove from linked list</h2><p>Likewise, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_unlink_q">item_unlink_q</a> is a thread safe wrapper of the workhorse method <code>do_item_unlink_q</code>.</p><div id="item_unlink_q" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">item_link_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">    do_item_link_q(it);</span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_unlink_q@item.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_item_unlink_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    item **head, **tail;</span><br><span class="line">    head = &amp;heads[it-&gt;slabs_clsid];           <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">    tail = &amp;tails[it-&gt;slabs_clsid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*head == it) &#123;                        <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">        assert(it-&gt;prev == <span class="number">0</span>);</span><br><span class="line">        *head = it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*tail == it) &#123;</span><br><span class="line">        assert(it-&gt;next == <span class="number">0</span>);</span><br><span class="line">        *tail = it-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(it-&gt;next != it);</span><br><span class="line">    assert(it-&gt;prev != it);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;prev) it-&gt;prev-&gt;next = it-&gt;next;</span><br><span class="line">    sizes[it-&gt;slabs_clsid]--;                 <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink_q@item.c</text></center><p>1) Same, get the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">head</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">tail</a> of the respective <strong>LRU linked list</strong> indicated by <code>slabs_clsid</code>.</p><p>2) Standard operations of “removing an element from a linked list”.</p><p>3) Decrease the global array <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">sizes</a>.</p><div id="globals1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item *heads[LARGEST_ID];</span><br><span class="line"><span class="keyword">static</span> item *tails[LARGEST_ID];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> sizes[LARGEST_ID];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item.c:59</text></center><br></div><h2 id="assoc-delete-remove-from-hash-map"><a href="#assoc-delete-remove-from-hash-map" class="headerlink" title="assoc_delete - remove from hash map"></a>assoc_delete - remove from hash map</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item** _hashitem_before (<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv) &#123;</span><br><span class="line">    item **pos;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = &amp;primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr: -----&gt; 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*pos &amp;&amp; ((nkey != (*pos)-&gt;nkey) || <span class="built_in">memcmp</span>(key, ITEM_key(*pos), nkey))) &#123;</span><br><span class="line">        pos = &amp;(*pos)-&gt;h_next; <span class="comment">// scr: ----------------------------------&gt; 2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assoc_delete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    item **before = _hashitem_before(key, nkey, hv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*before) &#123;</span><br><span class="line">        item *nxt;</span><br><span class="line">...</span><br><span class="line">        nxt = (*before)-&gt;h_next; <span class="comment">// scr: --------------------------------&gt; 3)</span></span><br><span class="line">        (*before)-&gt;h_next = <span class="number">0</span>;   <span class="comment">/* probably pointless, but whatever. */</span></span><br><span class="line">        *before = nxt; <span class="comment">// scr: ------------------------------------------&gt; 4)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Note:  we never actually get here.  the callers don't delete things</span></span><br><span class="line"><span class="comment">       they can't find. */</span></span><br><span class="line">    assert(*before != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_delete@assoc.c</text></center><p>1) Get the hash bucket using <code>hv</code>.</p><p>2) Go through the conflict chain and compare the <code>key</code>. Note that the result value is the <strong>address of the <code>next</code> member of the element <code>before</code> the found one</strong>. When there is no conflict, the address is the bucket itself.</p><p>3) Set the next element after the found one to temporary variable <code>nxt</code>.</p><p>4) Update the <strong><code>next</code> member of the element <code>before</code> the found one</strong>.</p><h1 id="Take-home"><a href="#Take-home" class="headerlink" title="Take home"></a>Take home</h1><p>Try <a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">this</a>.</p>]]></content>
    
    <summary type="html">
    
      More often than not, the LRU algorithm is combined with a hash map, and is referred to as a LRU Cache. In a LRU-cache, the hash map enables fast accessing of cached objects; and LRU avoids the cache to grow infinitely by marking expired, or so called, least recently used objects. Next we look at how LRU works from a high level standpoint.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="LRU" scheme="https://holmeshe.me/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - Slab III</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-III/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-III/</id>
    <published>2018-09-28T09:55:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="#"><text style="color:black;font-weight:bold;">III - this article)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>Last time we saw the memory allocating process, which further formulates <strong>slabs</strong> and the derivative “free lists” (a.k.a., <code>slots</code>). This time we will examine how to take advantage of the established data structures to <strong>“slab allocate / release”</strong> memory chunks which will be used to store <strong>items</strong>.</p><a id="more"></a><h1 id="Slab-alloc"><a href="#Slab-alloc" class="headerlink" title="Slab alloc"></a>Slab alloc</h1><p>Firstly, we look at</p><h2 id="do-slabs-alloc"><a href="#do-slabs-alloc" class="headerlink" title="do_slabs_alloc"></a>do_slabs_alloc</h2><p class="back"><br>which is opposite to the <a href="../understanding-memcached-source-code-II/#do-slabs-free">discussed <code>do_slabs_free</code></a>.<br></p><p>Note that the “public” interface of <code>do_slabs_alloc</code> is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_alloc">slabs_alloc</a> which is basically a thread-safe wrapper that locks the core data structures manipulated by the <strong>Memcached</strong> instance that is configured as <a href="#" onclick="return false;" data-toggle="collapse" data-target="#multithreaded">multithreaded</a>.</p><div id="slabs_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">slabs_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">int</span> *total_chunks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;slabs_lock);</span><br><span class="line">    ret = do_slabs_alloc(size, id, total_chunks, flags);</span><br><span class="line">    pthread_mutex_unlock(&amp;slabs_lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_alloc@slabs.c</text></center><br></div><div id="multithreaded" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            settings.num_threads = atoi(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Number of threads must be greater than 0\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* There're other problems when you get above 64 threads.</span></span><br><span class="line"><span class="comment">             * In the future we should portably detect # of cores for the</span></span><br><span class="line"><span class="comment">             * default.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &gt; <span class="number">64</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting a high number of worker"</span></span><br><span class="line">                                <span class="string">"threads is not recommended.\n"</span></span><br><span class="line">                                <span class="string">" Set this value to the number of cores in"</span></span><br><span class="line">                                <span class="string">" your machine or less.\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5572</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">do_slabs_alloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">int</span> *total_chunks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p;</span><br><span class="line">    <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br><span class="line">    p = &amp;slabclass[id]; <span class="comment">// scr: ----------------------------------------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (total_chunks != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *total_chunks = p-&gt;slabs * p-&gt;perslab; <span class="comment">// scr: -----------------&gt; 2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* fail unless we have space at the end of a recently allocated page,</span></span><br><span class="line"><span class="comment">       we have something on our freelist, or we could allocate a new page */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sl_curr == <span class="number">0</span> &amp;&amp; flags != SLABS_ALLOC_NO_NEWPAGE) &#123; <span class="comment">// scr: --&gt; *)</span></span><br><span class="line">        do_slabs_newslab(id); <span class="comment">// scr: ----------------------------------&gt; 3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sl_curr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* return off our freelist */</span></span><br><span class="line">        it = (item *)p-&gt;slots; <span class="comment">// scr: ---------------------------------&gt; 4)</span></span><br><span class="line">        p-&gt;slots = it-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Kill flag and initialize refcount here for lock safety in slab</span></span><br><span class="line"><span class="comment">         * mover's freeness detection. */</span></span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_SLABBED; <span class="comment">// scr: -------------------------&gt; 5)</span></span><br><span class="line">        it-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">        p-&gt;sl_curr--;</span><br><span class="line">        ret = (<span class="keyword">void</span> *)it; <span class="comment">// scr: --------------------------------------&gt; 6)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_alloc@slabs.c</text></center><p>1) For <em>item allocation</em>, <code>id</code> indicates the <strong>slab class</strong> that suits the requested <em>item size</em> best. In other words, <code>id</code> is selected using the actual <em>item size</em>, the process of which will be discussed <a href="#slabs-clsid">very soon</a>.</p><p>2) <code>total_chunks</code> is the parameter that outputs the total number of <em>memory chunks</em> (entries in the <em>free list</em>) available for the <strong>slab class</strong>. <code>if (total_chunks != NULL)</code> suggests that the argument is optional.</p><p>*) As the name indicates, <code>SLABS_ALLOC_NO_NEWPAGE</code> (<code>flags</code>) prevents this method to allocate new <strong>slab</strong> when there is no memory chunk available. This option is not used in the normal path of <em>item allocation</em>, hence is ignored for now.</p><p>3) When there is no free memory chunk, allocate a new <strong>slab</strong>. Here <code>p-&gt;sl_curr</code> indicates the number of available <em>chunks</em>, whose value decreases each time this method got called (in step 5 below).</p><p class="back"><br>Conversely, this field is increased in <a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>. Note that <em>new slab</em> has also been covered from <a href="../understanding-memcached-source-code-II/#New-slab">here</a>.<br></p><p>4) Remove the front element (<strong>f</strong>) from the <em>free list</em>, and set it to <code>it</code>.</p><p class="back"><br>In <a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>, an element is added to the front of the <em>free list</em>.<br></p><p>5) Clear the <code>ITEM_SLABBED</code> for the chuck (<strong>f</strong>), set its reference count to 1, and reduce <code>p-&gt;sl_curr</code> by <code>1</code>.</p><p class="back"><br>Likewise, this flag is set in <a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>.<br></p><p>6) Return (<strong>f</strong>).</p><p>Next, we look at the process of determining the <code>id</code> based on <em>item size</em>, the workhorse method of which is</p><h2 id="slabs-clsid"><a href="#slabs-clsid" class="headerlink" title="slabs_clsid"></a>slabs_clsid</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">slabs_clsid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = POWER_SMALLEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; slabclass[res].size)</span><br><span class="line">        <span class="keyword">if</span> (res++ == power_largest)     <span class="comment">/* won't fit in the biggest slab */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_alloc@slabs.c</text></center><p><code>slabs_clsid</code> consists mainly of a <code>while</code> loop that linear search the possible smallest <strong>slab class</strong> that can contain the requested <code>size</code>. This method is called from <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_alloc">do_item_alloc</a> before <code>slabs_alloc</code>. We will discuss <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_alloc">do_item_alloc</a> in the following post.</p><div id="do_item_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">do_item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">rel_time_t</span> exptime, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id = slabs_clsid(ntotal);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">        it = slabs_alloc(ntotal, id, &amp;total_chunks, <span class="number">0</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_alloc@items.c</text></center><br></div>]]></content>
    
    <summary type="html">
    
      Last time we saw the memory allocating process, which further formulates slabs and the derivative “free lists” (a.k.a., slots). This time we will examine how to take advantage of the established data structures to “slab allocate / release” memory chunks which will be used to store items. Firstly, we look at do_slabs_alloc
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - Slab II</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-II/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-II/</id>
    <published>2018-09-17T08:17:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="#"><text style="color:black;font-weight:bold;">II - this article</text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">, III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/diamond.svg" width="30" height="30">  <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>This time we continue examining how <strong>slab</strong>s memory is allocated.</p><p>Firstly we look at the two arguments for <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init">slabs_init</a>, which were passed over in the previous article. The first one is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_maxbytes">settings.maxbytes</a>. It limits the overall memory that can be used by the <strong>memcached</strong> instance. In <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init">slabs_init</a>, the value of <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_maxbytes">settings.maxbytes</a> is assigned to the global variable <a href="#" onclick="return false;" data-toggle="collapse" data-target="#mem_limit">mem_limit</a> which will be used very <a href="#do_slabs_newslab_mem_limit">soon</a>.</p><a id="more"></a><div id="slabs_init" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    mem_limit = limit; <span class="comment">// scr: here</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@memcached.c</text></center><br></div><div id="settings_maxbytes" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">  settings.maxbytes = <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">/* default is 64MB */</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">            settings.maxbytes = ((<span class="keyword">size_t</span>)atoi(optarg)) * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:210,5493</text></center><br></div><div id="mem_limit" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> mem_limit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:43</text></center><br></div><p>The other argument is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#preallocate">preallocate</a>. It determines whether to <em>preallocate</em> <strong>slab</strong> for each <strong>slab class</strong>. This argument is toggled with <code>L</code> command line argument.</p><div id="preallocate" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="keyword">bool</span> preallocate = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span> :</span><br><span class="line">            <span class="keyword">if</span> (enable_large_pages() == <span class="number">0</span>) &#123;</span><br><span class="line">                preallocate = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot enable large pages on this system\n"</span></span><br><span class="line">                    <span class="string">"(There is no Linux support as of this version)\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5350,5597</text></center><br></div><p>Next we look at the method for <strong>slabs</strong> memory allocation itself.</p><h1 id="New-slab"><a href="#New-slab" class="headerlink" title="New slab"></a>New slab</h1><h2 id="do-slabs-newslab"><a href="#do-slabs-newslab" class="headerlink" title="do_slabs_newslab"></a>do_slabs_newslab</h2><p>More specific, this method allocates one 1M sized <strong>slab</strong> for the <strong>slab class</strong> indicated by the parameter <code>id</code>.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_slabs_newslab</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id]; <span class="comment">// scr: ----------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">slabclass_t</span> *g = &amp;slabclass[SLAB_GLOBAL_PAGE_POOL]; <span class="comment">// scr: ---------&gt; *)</span></span><br><span class="line">    <span class="keyword">int</span> len = settings.slab_reassign ? settings.item_size_max <span class="comment">// scr: ---&gt; 2)</span></span><br><span class="line">        : p-&gt;size * p-&gt;perslab;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mem_limit &amp;&amp; mem_malloced + len &gt; mem_limit &amp;&amp; p-&gt;slabs &gt; <span class="number">0</span> <span class="comment">// -&gt; 3)</span></span><br><span class="line">         &amp;&amp; g-&gt;slabs == <span class="number">0</span>)) &#123;</span><br><span class="line">        mem_limit_reached = <span class="literal">true</span>;</span><br><span class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((grow_slab_list(id) == <span class="number">0</span>) || <span class="comment">// scr: ----------------------------&gt; 4)</span></span><br><span class="line">        (((ptr = get_page_from_global_pool()) == <span class="literal">NULL</span>) &amp;&amp; <span class="comment">// scr: -------&gt; *)</span></span><br><span class="line">        ((ptr = memory_allocate((<span class="keyword">size_t</span>)len)) == <span class="number">0</span>))) &#123; <span class="comment">// scr: ---------&gt; 5)</span></span><br><span class="line"></span><br><span class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ptr, <span class="number">0</span>, (<span class="keyword">size_t</span>)len);</span><br><span class="line">    split_slab_page_into_freelist(ptr, id); <span class="comment">// scr: ---------------------&gt; 6)</span></span><br><span class="line"></span><br><span class="line">    p-&gt;slab_list[p-&gt;slabs++] = ptr; <span class="comment">// scr: -----------------------------&gt; 7)</span></span><br><span class="line">    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_newslab@slabs.c</text></center><p>1) <code>slabclass[id]</code> is one of the <strong>slab class</strong>, the initialization of which is discussed in <a href="../understanding-memcached-source-code-I/#Module-initialization">last article</a>.</p><p>2) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_slab_reassign">settings.slab_reassign</a> determines whether to enlist a <em>rebalancing mechanism</em>, which recycles the unused <strong>slabs</strong> and redistributes them across <strong>slab classes</strong>. This requires that <strong>slabs</strong> contained in all <strong>slab classes</strong> be of the same size, hence this <em>setting</em> also decides whether to use unanimous (i.e., <code>settings.item_size_max</code>, or 1M as mentioned <a href="../understanding-memcached-source-code-I/#What-is-a-slab">before</a>) or heterogeneous (i.e., <code>p-&gt;size * p-&gt;perslab</code>) <strong>slabs</strong>. Besides its associated command line argument <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_slab_reassign">"slab_reassign"</a>, the value can be controlled by another argument <a href="#" onclick="return false;" data-toggle="collapse" data-target="#modern">"modern"</a>. For the positivity the name “modern” implies, 1M will be used throughout the text.</p><div id="settings_slab_reassign" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    settings.slab_reassign = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> SLAB_REASSIGN:</span><br><span class="line">                settings.slab_reassign = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:238,5694</text></center><br></div><div id="modern" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> MODERN:</span><br><span class="line">                <span class="comment">/* Modernized defaults. Need to add equivalent no_* flags</span></span><br><span class="line"><span class="comment">                 * before making truly default. */</span></span><br><span class="line">                settings.slab_reassign = <span class="literal">true</span>;</span><br><span class="line">                settings.slab_automove = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5820</text></center><br></div><a href="#" id="nb_rebalancing" style="visibility: hidden"></a><p>N.b. *, <em>rebalancing mechanism</em> will be discussed later when we have a better understanding of the LRU module. </p><a href="#" id="do_slabs_newslab_mem_limit" style="visibility: hidden"></a><p>3) Check if the memory usage will exceed the upper limit.</p><p>4) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#grow_slab_list">grow_slab_list</a> checks if we need to increase <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slab_list</a>, if so, grows it.</p><div id="grow_slab_list" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">grow_slab_list</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id];</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;slabs == p-&gt;list_size) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> new_size =  (p-&gt;list_size != <span class="number">0</span>) ? p-&gt;list_size * <span class="number">2</span> : <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">void</span> *new_list = <span class="built_in">realloc</span>(p-&gt;slab_list, new_size * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">        <span class="keyword">if</span> (new_list == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p-&gt;list_size = new_size;</span><br><span class="line">        p-&gt;slab_list = new_list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">grow_slab_list@slabs.c</text></center><br></div><p>5) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#memory_allocate">memory_allocate</a> allocates the actual memory for the <strong>slab</strong>. As discussed, here the value of <code>len</code> is 1M.</p><div id="memory_allocate" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">memory_allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* We are not using a preallocated large memory chunk */</span></span><br><span class="line">        ret = <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: when preallocate is set to true</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memory_allocate@slabs.c</text></center><br></div><p>6) <code>split_slab_page_into_freelist</code> initializes (frees) the newly allocated <code>slab</code> preparing for objects storing. This method will be discussed in the next section.</p><p>7) Add the newly allocated <code>slab</code> to the <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slab_list</a>.</p><p>What has happened so far can be summarized with the following figure, (we assume <code>do_slabs_newslab(n)</code> is called two times) </p><p><img src="../gallery/slab_alloc.png" alt="new slabs"></p><p>Now we look inside the 1M <strong>slab</strong> in step 6).</p><h2 id="split-slab-page-into-freelist"><a href="#split-slab-page-into-freelist" class="headerlink" title="split_slab_page_into_freelist"></a>split_slab_page_into_freelist</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_slab_page_into_freelist</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id];</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; p-&gt;perslab; x++) &#123;</span><br><span class="line">        do_slabs_free(ptr, <span class="number">0</span>, id);</span><br><span class="line">        ptr += p-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">split_slab_page_into_freelist@slabs.c</text></center><p>This method goes through all the <em>item chunk</em>s (in the size of <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.size</a>) within a <strong>slab</strong>. And for each of them, the method initializes its meta data by calling <code>do_slabs_free</code>. Another way to interpret this process is “split a slab into <strong>item</strong> free list”. As you might have already figured out, this “free list” will be used by <strong>item allocation</strong> in the future.</p><h2 id="do-slabs-free"><a href="#do-slabs-free" class="headerlink" title="do_slabs_free"></a>do_slabs_free</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_slabs_free</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p;</span><br><span class="line">    item *it;</span><br><span class="line">...</span><br><span class="line">    p = &amp;slabclass[id];</span><br><span class="line"></span><br><span class="line">    it = (item *)ptr;</span><br><span class="line">    it-&gt;it_flags = ITEM_SLABBED; <span class="comment">// scr: ---------------&gt; 1)</span></span><br><span class="line">    it-&gt;slabs_clsid = <span class="number">0</span>;</span><br><span class="line">    it-&gt;prev = <span class="number">0</span>; <span class="comment">// scr: ------------------------------&gt; 2)</span></span><br><span class="line">    it-&gt;next = p-&gt;slots;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it;</span><br><span class="line">    p-&gt;slots = it;</span><br><span class="line"></span><br><span class="line">    p-&gt;sl_curr++; <span class="comment">// scr: ------------------------------&gt; 3)</span></span><br><span class="line">    p-&gt;requested -= size;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_free@slabs.c</text></center><p>This method works on <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item">item meta data</a> that is populated at the beginning of an <em>item chunk</em>.</p><div id="item" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protected by LRU locks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></span><br><span class="line">...</span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5820</text></center><br></div><p>1) Initialize some fields. <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item">item</a> is another core data structure, we will come back to <strong>item</strong> data structure later.</p><p>2) Add the <strong>item</strong> to the front of the linked list (a.k.a., free list). And update the list head, <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slots</a>.</p><p>3) Update the available (free list) slot count, <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.sl_curr</a>; and updates the <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.requested</a> for statistic. Note that here we are not actually releasing an <strong>item</strong>, so the passed <code>size</code> is 0.</p><p><img src="../gallery/slab_free_list.png" alt="free list"></p><h1 id="Slab-preallocate"><a href="#Slab-preallocate" class="headerlink" title="Slab preallocate"></a>Slab preallocate</h1><p>Next we look at how <code>do_slabs_newslab</code> is used. One place it gets called is from the discussed <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init_1">slabs_init</a> when <code>preallocate</code> is set to <code>true</code>,</p><div id="slabs_init_1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (prealloc) &#123;</span><br><span class="line">        slabs_preallocate(power_largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@slabs.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slabs_preallocate</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> maxslabs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prealloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pre-allocate a 1MB slab in every size class so people don't get</span></span><br><span class="line"><span class="comment">       confused by non-intuitive "SERVER_ERROR out of memory"</span></span><br><span class="line"><span class="comment">       messages.  this is the most common question on the mailing</span></span><br><span class="line"><span class="comment">       list.  if you really don't want this, you can rebuild without</span></span><br><span class="line"><span class="comment">       these three lines.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = POWER_SMALLEST <span class="comment">/* scr: 1 */</span>; i &lt; MAX_NUMBER_OF_SLAB_CLASSES; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++prealloc &gt; maxslabs)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (do_slabs_newslab(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error while preallocating slab memory!\n"</span></span><br><span class="line">                <span class="string">"If using -L or other prealloc options, max memory must be "</span></span><br><span class="line">                <span class="string">"at least %d megabytes.\n"</span>, power_largest);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_preallocate@slabs.c</text></center><p>This method simply goes through the <a href="../understanding-memcached-source-code-I/#core_ds">slabclass</a> starting from the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#defines">POWER_SMALLEST</a>, i.e., 1st entry, and allocate one <strong>slab</strong> for each of them. Note that the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#defines">0th</a> is a special <strong>slab class</strong> used by mentioned <em>rebalancing mechanism</em>.</p><div id="defines" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_SMALLEST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_LARGEST 256 <span class="comment">/* actual cap is 255 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLAB_GLOBAL_PAGE_POOL 0 <span class="comment">/* magic slab class for storing pages for reassignment */</span></span></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.h:88</text></center><br></div><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>Same to <a href="../understanding-memcached-source-code-I/#References">the last article</a>.</p>]]></content>
    
    <summary type="html">
    
      This time we continue examining how slabs memory is allocated. Firstly we look at the two arguments for slabs_init, which were passed over in the previous article. The first one is settings.maxbytes. It limits the overall memory that can be used by the memcached instance. In slabs_init, the value of settings.maxbytes is assigned to the global variable mem_limit which will be used very soon. The other argument is preallocate. It determines whether to preallocate slab for each slab class. This argument is toggled with L command line argument.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="source code analysis" scheme="https://holmeshe.me/tags/source-code-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - Slab I</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-I/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-I/</id>
    <published>2018-09-12T09:17:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I - this article</text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">, III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>Variants of <strong>slab allocator</strong> is implemented in other systems, such as nginx and Linux kernel, to fight a common problem called <strong>memory fragmentation</strong>. And this article will, of course, focus on <strong>Memcached</strong>‘s implementation of the algorithm.</p><p><strong>memcached version: 1.4.28</strong></p><p>Firstly, let’s answer some questions.</p><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="What-is-a-slab"><a href="#What-is-a-slab" class="headerlink" title="What is a slab"></a>What is a slab</h2><p><strong>slab</strong>s are pre-allocated 1M memory chunks that can be subdivided for numerous objects. They are grouped into <strong>slab class</strong>es to serve allocation requests for various sizes.</p><h2 id="What-is-memory-fragmentation-how-it-occurs"><a href="#What-is-memory-fragmentation-how-it-occurs" class="headerlink" title="What is memory fragmentation, how it occurs"></a>What is memory fragmentation, how it occurs</h2><p>In particular, <strong>slab allocator</strong> curbs <strong>internal memory fragmentation</strong>. This kind of fragmentation exits within an allocated memory chunk. In the context of OS kernel, for instance, the fundamental unit allocated by memory management sub-system is called a <em>page</em>.</p><blockquote><p>On the other hand, <strong>external memory fragmentation</strong> exists across chunks, and the solution of which (keyword: buddy) belongs to another story.</p></blockquote><p>The most common phenomenon where <strong>internal fragmentation</strong> causes the problem is as following:</p><p>1) <code>malloc</code> of small objects is called a lot of times; and in the meantime;</p><p>2) <code>free</code> of those objects is called a lot of times.</p><p>The above process generates (a lot of) nominal “free” memory that cannot be utilized, as the discrete holes of various sizes, or <strong>fragments</strong>, can not be reused by subsequent <code>malloc</code>s for any objects that are larger than them.</p><h2 id="Why-memory-fragmentation-is-bad"><a href="#Why-memory-fragmentation-is-bad" class="headerlink" title="Why memory fragmentation is bad"></a>Why memory fragmentation is bad</h2><p>The impact of <strong>memory fragmentation</strong> is similar to that of <strong>memory leak</strong> - periodical system reboot is inevitable whenever the fragments accumulate to a certain level, which, increase the complexity in system operation, or even worse, leads to bad user experiences.</p><h2 id="How-the-problem-is-fixed"><a href="#How-the-problem-is-fixed" class="headerlink" title="How the problem is fixed"></a>How the problem is fixed</h2><p><strong>Slab allocator</strong> does not eliminate <strong>internal fragmentation</strong>. Instead, it converges the fragments and locks them in fixated memory locations. This is done by 1) categorizing objects of similar sizes in <strong>classes</strong>; and 2) allocating objects belonging to the same <strong>class</strong> only on the same group of “<strong>slab</strong>s”, or, a <strong>slab class</strong>.</p><p>The detail devil is in the code, so we start reading the code.</p><p><strong>reminder: Memcached version is 1.4.28</strong></p><p>The core data structure in use<br><a href="#" id="core_ds" style="visibility: hidden"></a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;      <span class="comment">/* sizes of items */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> perslab;   <span class="comment">/* how many items per slab */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *slots;           <span class="comment">/* list of item ptrs */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sl_curr;   <span class="comment">/* total free items in list */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> slabs;     <span class="comment">/* how many slabs were allocated for this class */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> **slab_list;       <span class="comment">/* array of slab pointers */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> list_size; <span class="comment">/* size of prev array */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> requested; <span class="comment">/* The number of requested bytes */</span></span><br><span class="line">&#125; <span class="keyword">slabclass_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">slabclass_t</span> slabclass[MAX_NUMBER_OF_SLAB_CLASSES];</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabclass_t@slabs.c</text></center></p><h1 id="Module-initialization"><a href="#Module-initialization" class="headerlink" title="Module initialization"></a>Module initialization</h1><p>In this section we examine <code>slabs_init</code> that initializes <code>slabclass[MAX_NUMBER_OF_SLAB_CLASSES]</code> array. In particular, this process initializes the values of two fields, i.e., <code>slabclass_t.size</code>, the item (object) size of each <strong>slab class</strong>, and <code>slabclass_t.perslab</code> the item number one <strong>slab</strong> contains. This method is called from <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet1">here</a> as one of the <em>init</em> steps before the logic enters the <em>main even loop</em>.</p><div id="snippet1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    assoc_init(settings.hashpower_init);</span><br><span class="line">    conn_init();</span><br><span class="line">    slabs_init(settings.maxbytes, settings.factor, preallocate,</span><br><span class="line">               use_slab_sizes ? slab_sizes : <span class="literal">NULL</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5977</text></center><br></div><p>In this step <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_sizes">slab_sizes</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_factor">settings.factor</a> jointly control the routes in which sizes of each <strong>slab class</strong> are decided, they are:</p><div id="slab_sizes" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5372</text></center><br></div><div id="settings_factor" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.factor = <span class="number">1.25</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">settings_init@memcached.c:217</text></center><br></div><p>a) if <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_sizes">slab_sizes</a> is not <code>NULL</code>, the values within the array are used directly; and</p><p>b) otherwise, the sizes are calculated as <em>base size</em> × <em>n</em> × <code>settings.factor</code> where <em>n</em> is the index within <code>slabclass</code>.</p><p>Besides the default values, the two arguments can be set <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet2">at runtime</a> as well.</p><div id="snippet2" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">            settings.factor = atof(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.factor &lt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Factor must be greater than 1\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'o'</span>: <span class="comment">/* It's sub-opts time! */</span></span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> SLAB_SIZES:</span><br><span class="line">                <span class="keyword">if</span> (_parse_slab_sizes(subopts_value, slab_sizes)) &#123;</span><br><span class="line">                    use_slab_sizes = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5558, 5810</text></center><br></div><p>The other two arguments of this method <code>settings.maxbytes</code> and <code>preallocate</code> will be discussed <a href="../understanding-memcached-source-code-II">soon</a>. For now we set <code>false</code> to <code>preallocate</code> and ignore the relevant logic flow.</p><p>Next we look at the <code>slabs_init</code> itself.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = POWER_SMALLEST <span class="comment">/* scr: 1 */</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(item) + settings.chunk_size; <span class="comment">// scr: ---------&gt; b 1)</span></span><br><span class="line">...</span><br><span class="line">    <span class="built_in">memset</span>(slabclass, <span class="number">0</span>, <span class="keyword">sizeof</span>(slabclass));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (++i &lt; MAX_NUMBER_OF_SLAB_CLASSES<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slab_sizes != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: -----------------------------------&gt; a 1)</span></span><br><span class="line">            <span class="keyword">if</span> (slab_sizes[i<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            size = slab_sizes[i<span class="number">-1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt;= settings.item_size_max / factor) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Make sure items are always n-byte aligned */</span></span><br><span class="line">        <span class="keyword">if</span> (size % CHUNK_ALIGN_BYTES) <span class="comment">// scr: ---------------------------------&gt; 2)</span></span><br><span class="line">            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);</span><br><span class="line"></span><br><span class="line">        slabclass[i].size = size;</span><br><span class="line">        slabclass[i].perslab = settings.item_size_max / slabclass[i].size; <span class="comment">// -&gt; 3)</span></span><br><span class="line">        <span class="keyword">if</span> (slab_sizes == <span class="literal">NULL</span>)</span><br><span class="line">            size *= factor; <span class="comment">// scr: -----------------------------------------&gt; b 4)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"slab class %3d: chunk size %9u perslab %7u\n"</span>,</span><br><span class="line">                    i, slabclass[i].size, slabclass[i].perslab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scr: -------------------------------------------------------------------&gt; 5)</span></span><br><span class="line">    power_largest = i;</span><br><span class="line">    slabclass[power_largest].size = settings.item_size_max;</span><br><span class="line">    slabclass[power_largest].perslab = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@slabs.c</text></center><h2 id="Route-a"><a href="#Route-a" class="headerlink" title="Route a"></a>Route a</h2><p>1) use the values in <code>slab_sizes</code>;</p><p>2) align the <code>size</code> to <code>CHUNK_ALIGN_BYTES</code>, and give the result to <code>slabclass[i].size</code>;</p><p>3) calculate the <code>slabclass[i].perslab</code>;</p><p>5) use the <code>settings.item_size_max</code> to initialize the last <strong>slab class</strong>.</p><p>Note that <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_item_size_max">settings.item_size_max</a> is the size of each <strong>slab</strong>, hence it is also the max size of items that are allocated on <em>slabs</em>. Likewise, the value of  <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_item_size_max">settings.item_size_max</a> can be decided in <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet3">runtime</a>.</p><div id="settings_item_size_max" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.item_size_max = <span class="number">1024</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">settings_init@memcached.c:226</text></center><br></div><div id="snippet3" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">    buf = strdup(optarg);</span><br><span class="line">    unit = buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="string">'k'</span> || unit == <span class="string">'m'</span> ||</span><br><span class="line">        unit == <span class="string">'K'</span> || unit == <span class="string">'M'</span>) &#123;</span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        size_max = atoi(buf);</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="string">'k'</span> || unit == <span class="string">'K'</span>)</span><br><span class="line">            size_max *= <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="string">'m'</span> || unit == <span class="string">'M'</span>)</span><br><span class="line">            size_max *= <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        settings.item_size_max = size_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        settings.item_size_max = atoi(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Item max size cannot be less than 1024 bytes.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &gt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">128</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot set item size limit higher than 128 mb.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &gt; <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting item max size above 1MB is not"</span></span><br><span class="line">            <span class="string">" recommended!\n"</span></span><br><span class="line">            <span class="string">" Raising this limit increases the minimum memory requirements\n"</span></span><br><span class="line">            <span class="string">" and will decrease your memory efficiency.\n"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5626</text></center><br></div><h2 id="Route-b"><a href="#Route-b" class="headerlink" title="Route b"></a>Route b</h2><p>1) calculate the <em>base size</em> with <em>settings.chunk_size</em> plus the extra bytes for metadata (<code>item</code> will be discussed in following articles);</p><p>2) align the <code>size</code> to <code>CHUNK_ALIGN_BYTES</code>, and give the result to <code>slabclass[i].size</code>; (same to route a)</p><p>3) calculate the <code>slabclass[i].perslab</code>;  (same to route a)</p><p>4) calculate the size for the next <code>slab class</code> using <code>factor</code> (<code>settings.factor</code>);</p><p>5) use the <code>settings.item_size_max</code> to initialize the last <strong>slab class</strong>. (same to route a)</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://github.com/memcached/memcached/wiki" target="_blank" rel="noopener">memcached wiki</a></p><p><a href="http://gihyo.jp/dev/feature/01/memcached/0002" target="_blank" rel="noopener">第2回　memcachedのメモリストレージを理解する</a></p><p><a href="https://blog.csdn.net/initphp/article/details/44888555" target="_blank" rel="noopener">Memcached源码分析之存储机制Slabs（7）</a></p><p><a href="https://gokulvasanblog.wordpress.com/2016/07/11/understanding-malloc-part1/" target="_blank" rel="noopener">Understanding Malloc</a></p><p><a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html" target="_blank" rel="noopener">Ch8 - Slab Allocator</a></p><p><a href="https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a" target="_blank" rel="noopener">The Slab Allocator:An Object-Caching Kernel Memory Allocator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;#&quot; class=&quot;fancybox&quot;&gt;&lt;img align=&quot;left&quot; style=&quot;padding-right:10px;&quot; src=&quot;../gallery/spade.svg&quot; width=&quot;30&quot; height=&quot;30&quot;&gt; &lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;slab allocator (I - this article&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-II/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, II&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-III/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, III)&lt;/text&gt;&lt;/a&gt; is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/understanding-memcached-source-code-IV/&quot; class=&quot;fancybox&quot;&gt;&lt;img align=&quot;left&quot; style=&quot;padding-right:10px;&quot; src=&quot;../gallery/heart.svg&quot; width=&quot;30&quot; height=&quot;30&quot;&gt; &lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;LRU algorithm (I&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-V/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, II&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-VI/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, III)&lt;/text&gt;&lt;/a&gt; for entry expiration; and an&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/understanding-memcached-source-code-VII/&quot; class=&quot;fancybox&quot;&gt;&lt;img align=&quot;left&quot; style=&quot;padding-right:10px;&quot; src=&quot;../gallery/club.svg&quot; width=&quot;30&quot; height=&quot;30&quot;&gt; &lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;event driven model (I&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-VIII/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, II&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-IX/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, III)&lt;/text&gt;&lt;/a&gt; based on libevent; and the&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#&quot; class=&quot;fancybox&quot;&gt;&lt;img align=&quot;left&quot; style=&quot;padding-right:10px;&quot; src=&quot;../gallery/diamond.svg&quot; width=&quot;30&quot; height=&quot;30&quot;&gt; &lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;consistent harsh (not complete)&lt;/text&gt;&lt;/a&gt; for data distribution,&lt;/p&gt;
&lt;p&gt;are built around it.&lt;/p&gt;
&lt;p&gt;Variants of &lt;strong&gt;slab allocator&lt;/strong&gt; is implemented in other systems, such as nginx and Linux kernel, to fight a common problem called &lt;strong&gt;memory fragmentation&lt;/strong&gt;. And this article will, of course, focus on &lt;strong&gt;Memcached&lt;/strong&gt;‘s implementation of the algorithm.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;memcached version: 1.4.28&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Firstly, let’s answer some questions.&lt;/p&gt;
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>setsockopt, TCP_NODELAY and Packet Aggregation I</title>
    <link href="https://holmeshe.me/network-essentials-setsockopt-TCP_NODELAY/"/>
    <id>https://holmeshe.me/network-essentials-setsockopt-TCP_NODELAY/</id>
    <published>2018-06-08T23:47:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p>Latency, instead of throughput, is found as the system bottleneck more often than not. However, the TCP socket enables a so-called <em>nagle algorithm</em> by default, which delays an egress packet in order to coalesces it with one that could be sent in the future, into a single TCP segment. This effectively reduces the number of TCP segments and the bandwidth overhead used by the TCP headers, whilst potentially imposes latency for every network request (response) being sent.</p><blockquote><p>Lock, and his temperamental brother, Block, are the two notorious villains in the world of programming. In the beginning, they always show up to assist. But sooner or later, they will kick your back-end like really hard.</p></blockquote><p>When I consider about <em>nagle algorithem</em>, it seems to me another scenario involving block operations which are meant to be helpful. So I decide to put hands on a keyboard to test if I am wrong.</p><p><strong>Software setup</strong><br><em>Client OS: Debian 4.9.88</em><br><em>Server OS (LAN &amp; WAN): Unbutu 16.04</em><br><em>gcc: 6.3.0</em></p><p><strong>Hardware (or VM) setup</strong><br><em>Server (LAN): Intel® Core™2 Duo CPU E8400 @ 3.00GHz × 2, 4GB</em><br><em>Server (WAN): t2.micro, 1GB</em></p><a id="more"></a><h1 id="The-impact-nagle-algorithm-has-on-latency"><a href="#The-impact-nagle-algorithm-has-on-latency" class="headerlink" title="The impact nagle algorithm has on latency"></a>The impact <em>nagle algorithm</em> has on latency</h1><p>First thing first, the code of client:</p><script src="https://gist.github.com/holmeshe/f8737a7aecbf368fdfe6fa0c5d0f897a.js"></script><p>and server:</p><script src="https://gist.github.com/holmeshe/6fc669c486b2070e2e482420ad0d0272.js"></script><p>The client code given above sends 1000 packets 4 bytes long in an interval indicated by the last command line argument. And as discussed, it adopts the default TCP behavior by default. The server is not different than a discard server, so the code is irrelevant here.</p><p>In this test, I will record the number of packets that are aggregated in different intervals, by adjusting the mentioned argument. This way, we can grasp the extent of latency the <em>nagle algorithm</em> can impose. The same test is conducted in both LAN (RTT &lt; 0.6ms) and WAN (RTT ≈ 200ms).</p><p><img src="../gallery/nagle-lan.png" alt="1000 packets through LAN"></p><p><img src="../gallery/nagle-wan.png" alt="1000 packets through WAN"></p><p>As given in the figures, the number aggregated packets approaches to 0 when the interval is greater than the RTT. This conforms to what described in &lt;&lt;TCP/IP Illustrated&gt;&gt;</p><blockquote><p>This algorithm says that a TCP connection can have only one outstanding small segment that has not yet been acknowledged. No additional small segments can be sent until the acknowledgment is received.</p></blockquote><p>If looking at the <code>tcpdump</code> output, we can also see that this algorithm effectively changes the sending interval to the RTT regardless of the actual <code>write(2)</code> frequency of the program. And the packets between two sends are those being aggregated.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">18:34:52.986972 IP debian.53700 &gt; ******.compute.amazonaws.com.6666: Flags [P.], seq 4:12, ack 1, win 229, options [nop,nop,TS val 7541746 ecr 2617170332], length 8</span><br><span class="line">18:34:53.178277 IP debian.53700 &gt; ******.amazonaws.com.6666: Flags [P.], seq 12:20, ack 1, win 229, options [nop,nop,TS val 7541794 ecr 2617170379], length 8</span><br><span class="line">18:34:53.369431 IP debian.53700 &gt; ******.amazonaws.com.6666: Flags [P.], seq 20:32, ack 1, win 229, options [nop,nop,TS val 7541842 ecr 2617170427], length 12</span><br><span class="line">18:34:53.560351 IP debian.53700 &gt; ******.amazonaws.com.6666: Flags [P.], seq 32:40, ack 1, win 229, options [nop,nop,TS val 7541890 ecr 2617170475], length 8</span><br><span class="line">18:34:54.325242 IP debian.53700 &gt; ******.amazonaws.com.6666: Flags [P.], seq 68:80, ack 1, win 229, options [nop,nop,TS val 7542081 ecr 2617170666], length 12</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>As a result, the delay imposed on every packet by the algorithm is RTT on average and 2 * RTT in worst case.</strong></p><h1 id="Combined-with-delayed-ACK"><a href="#Combined-with-delayed-ACK" class="headerlink" title="Combined with delayed ACK"></a>Combined with delayed ACK</h1><p>Delayed ACK is another similar algorithm, here I will just use the lines from &lt;&lt;TCP/IP Illustrated&gt;&gt; to brief the mechanism</p><blockquote><p>TCP will delay an ACK up to 200 ms to see if there is data to send with the ACK.</p></blockquote><p>Apperantly <em>nagle algorithm</em> is <a href="https://news.ycombinator.com/item?id=10607422" target="_blank" rel="noopener">not happy</a> with <em>delayed ACK</em>.</p><p>In some cases when the back-end do not reply instantly to a request, <em>delayed ACK</em> will have to wait for another request which is potentially delayed by <em>nagle algorithm</em> waiting for ACK. This senario where two resources waiting for each other, in another word, is called a dead-lock. </p><blockquote><p>Remember the two brothers mentioned in the beginning?</p></blockquote><p>Unfortunately, in my environments, seems like the <em>delayed ACK</em> is disabled by default and I failed to enable it by</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flags = 0;</span><br><span class="line">flglen = sizeof(flags);</span><br><span class="line">getsockopt(sfd, SOL_TCP, TCP_QUICKACK, &amp;flags, &amp;flglen)</span><br></pre></td></tr></table></figure><p>So I could not hand test the compounded impact.</p><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><p>At the moment when I am writing, except for <em>telnet</em>, most of the other applications, including those of front-end(<em>Firefox</em>, <em>Chromium</em>), back-end(<em>nginx</em>, <em>memcached</em>), and the <em>telnet</em>‘s substitute, <em>ssh</em>, disable <em>nagle algorithm</em> with some code like bellow,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int flags =1;</span><br><span class="line">setsockopt(sfd, SOL_TCP, TCP_NODELAY, (void *)&amp;flags, sizeof(flags));</span><br></pre></td></tr></table></figure><p>which indicates that the packets should be emitted as it is.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">18:22:38.983278 IP debian.43808 &gt; 192.168.1.71.6666: Flags [P.], seq 1:5, ack 1, win 229, options [nop,nop,TS val 7358245 ecr 6906652], length 4</span><br><span class="line">18:22:38.984149 IP debian.43808 &gt; 192.168.1.71.6666: Flags [P.], seq 5:9, ack 1, win 229, options [nop,nop,TS val 7358246 ecr 6906652], length 4</span><br><span class="line">18:22:38.985028 IP debian.43808 &gt; 192.168.1.71.6666: Flags [P.], seq 9:13, ack 1, win 229, options [nop,nop,TS val 7358246 ecr 6906653], length 4</span><br><span class="line">18:22:38.985897 IP debian.43808 &gt; 192.168.1.71.6666: Flags [P.], seq 13:17, ack 1, win 229, options [nop,nop,TS val 7358246 ecr 6906653], length 4</span><br><span class="line">18:22:38.986765 IP debian.43808 &gt; 192.168.1.71.6666: Flags [P.], seq 17:21, ack 1, win 229, options [nop,nop,TS val 7358246 ecr 6906653], length 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>I think the reasons behind the prevalence of <code>TCP_NODELAY</code> are as follows,<br>1) the increasing bandwidth makes the benefits of <em>nagle algorithm</em> more and more negligible - it requires hundreds of thousands of tinygrams to saturate an edge node with mediocre bandwidth nowadays; and<br>2) app that generate a lot of tinygram tend to demand low latency.</p><p>To conclude, technically, it’s probably not a good idea to turn a modern real-time on-line battle arena into some (200 ms) turn based 80s RPG.</p><p><img src="../gallery/old-rpg.gif" alt="80s RPG"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.amazon.com/TCP-Illustrated-Vol-Addison-Wesley-Professional/dp/0201633469" target="_blank" rel="noopener">TCP/IP Illustrated</a><br><a href="https://tools.ietf.org/html/rfc896" target="_blank" rel="noopener">RFC 896</a><br><a href="https://news.ycombinator.com/item?id=10607422" target="_blank" rel="noopener">Hacker news</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Latency, instead of throughput, is found as the system bottleneck more often than not. However, the TCP socket enables a so-called &lt;em&gt;nagle algorithm&lt;/em&gt; by default, which delays an egress packet in order to coalesces it with one that could be sent in the future, into a single TCP segment. This effectively reduces the number of TCP segments and the bandwidth overhead used by the TCP headers, whilst potentially imposes latency for every network request (response) being sent.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lock, and his temperamental brother, Block, are the two notorious villains in the world of programming. In the beginning, they always show up to assist. But sooner or later, they will kick your back-end like really hard.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When I consider about &lt;em&gt;nagle algorithem&lt;/em&gt;, it seems to me another scenario involving block operations which are meant to be helpful. So I decide to put hands on a keyboard to test if I am wrong.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Software setup&lt;/strong&gt;&lt;br&gt;&lt;em&gt;Client OS: Debian 4.9.88&lt;/em&gt;&lt;br&gt;&lt;em&gt;Server OS (LAN &amp;amp; WAN): Unbutu 16.04&lt;/em&gt;&lt;br&gt;&lt;em&gt;gcc: 6.3.0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hardware (or VM) setup&lt;/strong&gt;&lt;br&gt;&lt;em&gt;Server (LAN): Intel® Core™2 Duo CPU E8400 @ 3.00GHz × 2, 4GB&lt;/em&gt;&lt;br&gt;&lt;em&gt;Server (WAN): t2.micro, 1GB&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Network Essentials" scheme="https://holmeshe.me/categories/Network-Essentials/"/>
    
    
      <category term="network" scheme="https://holmeshe.me/tags/network/"/>
    
      <category term="socket" scheme="https://holmeshe.me/tags/socket/"/>
    
      <category term="setsockopt" scheme="https://holmeshe.me/tags/setsockopt/"/>
    
      <category term="SOL_TCP" scheme="https://holmeshe.me/tags/SOL-TCP/"/>
    
      <category term="TCP_NODELAY" scheme="https://holmeshe.me/tags/TCP-NODELAY/"/>
    
      <category term="packet aggregation" scheme="https://holmeshe.me/tags/packet-aggregation/"/>
    
      <category term="nagle algorithm" scheme="https://holmeshe.me/tags/nagle-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>setsockopt, SO_KEEPALIVE and Heartbeats</title>
    <link href="https://holmeshe.me/network-essentials-setsockopt-SO_KEEPALIVE/"/>
    <id>https://holmeshe.me/network-essentials-setsockopt-SO_KEEPALIVE/</id>
    <published>2018-05-27T08:45:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p>There are two end purposes for sending heartbeats through a persistent connection. For a back-end application, heartbeats are generally used to detect an absent client, so as to drop a connection and release the associated resources; for a client, on the contrary, it is to prevent connection resources stored within intermediate nodes being released (such as a <em>NAT</em> router), <code>SO</code> as to <code>KEEP</code> the connection <code>ALIVE</code>.</p><p>This article will examine how to configure the four socket options, <code>SO_KEEPALIVE</code>, <code>TCP_KEEPIDLE</code>, <code>TCP_KEEPINTVL</code> and <code>TCP_KEEPCNT</code> with <code>setsockopt()</code> to send heartbeats; and discuss the practice of keep-alive heartbeats in general.</p><p><strong>Experiment setting</strong>:<br><em>OS: Unbutu 16.04</em><br><em>gcc: 5.4.0</em></p><a id="more"></a><h1 id="To-keep-the-connection-alive"><a href="#To-keep-the-connection-alive" class="headerlink" title="To keep the connection alive"></a>To keep the connection alive</h1><p>One cause of silent connection drop is <em>NAT</em> entry timeout. A <em>NAT</em> entry consisting of the 4-tuple (source address, source port, destination address and destination port) is recorded by a <strong>network</strong> router internally for <strong>address translation</strong>. Due to limited memory available to the hardware, the router has to remove the entry belonging to an inactive session after a timeout. As a result, the connection is effectively closed even though neither ends have explicitly issued a <code>FIN</code> nor <code>RST</code>.</p><p>Reconnecting is expensive. An end user has to wait for at least 3xRTT spent by handshakes; and additional logic is required to smoothly restore the UX with the previously interrupted state after the user is back on-line.</p><blockquote><p>In order to avoid the unnecessary handshakes and the RTTs imposed, HTTP adopts KEEP-ALIVE so that the short-lived HTTP sessions can reuse the same established, persistent TCP connection, which is another story.</p></blockquote><p>Next, I will use two programs to illustrate how it works exactly. We look at the code of a server first,</p><script src="https://gist.github.com/holmeshe/4eb2313d6c67872de5d628864bec0e99.js"></script><p>For simplicity, I do not apply IO multiplexing so the server can accept connect from 1 client one time.</p><p>the code of client,</p><script src="https://gist.github.com/holmeshe/a8186dd3020840dc4337f7b139da4550.js"></script><p>After setting the socket options mentioned before, the client initiates the TCP handshakes by <code>connect()</code>, and yield the CPU by <code>sleep()</code>.</p><blockquote><p>If you are not familiar with network programming (<code>socket</code>), please read <a href="http://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/socket.html" target="_blank" rel="noopener">this</a> first.</p></blockquote><p>Next, let’s see the network interaction in action.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i wlp3s0 dst net 192.168.1.71 or src net 192.168.1.71 and not dst port 22 and not src port 22</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ========================&gt; start handshakes</span><br><span class="line">12:21:42.437163 IP 192.168.1.66.43066 &gt; 192.168.1.71.6666: Flags [S], seq 3002564942, win 29200, options [mss 1460,sackOK,TS val 7961984 ecr 0,nop,wscale 7], length 0</span><br><span class="line">12:21:42.439960 IP 192.168.1.71.6666 &gt; 192.168.1.66.43066: Flags [S.], seq 3450454053, ack 3002564943, win 28960, options [mss 1460,sackOK,TS val 2221927 ecr 7961984,nop,wscale 7], length 0</span><br><span class="line">12:21:42.440088 IP 192.168.1.66.43066 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 7961985 ecr 2221927], length 0</span><br><span class="line">// ========================&gt; end handshakes</span><br><span class="line">12:21:52.452057 IP 192.168.1.66.43066 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 7964488 ecr 2221927], length 0</span><br><span class="line">12:21:52.454443 IP 192.168.1.71.6666 &gt; 192.168.1.66.43066: Flags [.], ack 1, win 227, options [nop,nop,TS val 2224431 ecr 7961985], length 0</span><br><span class="line">12:22:02.468056 IP 192.168.1.66.43066 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 7966992 ecr 2224431], length 0</span><br><span class="line">12:22:02.470458 IP 192.168.1.71.6666 &gt; 192.168.1.66.43066: Flags [.], ack 1, win 227, options [nop,nop,TS val 2226935 ecr 7961985], length 0</span><br><span class="line">12:22:12.484119 IP 192.168.1.66.43066 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 7969496 ecr 2226935], length 0</span><br><span class="line">12:22:12.489786 IP 192.168.1.71.6666 &gt; 192.168.1.66.43066: Flags [.], ack 1, win 227, options [nop,nop,TS val 2229440 ecr 7961985], length 0</span><br></pre></td></tr></table></figure><blockquote><p>Here I removed the irrelevant output of <code>ARP</code>s. If you are not familiar with <code>tcpdump</code>, please read <a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="noopener">this</a> first.</p></blockquote><p>With the feet gotten wet, now it’s a good time to explain the heartbeat mechanism,</p><p>1) <code>SO_KEEPALIVE</code> enables (or disables) heartbeat;<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flags =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags))) &#123; perror(<span class="string">"ERROR: setsocketopt(), SO_KEEPALIVE"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;;</span><br></pre></td></tr></table></figure></p><p>and</p><p>2) the side with heartbeat enabled (in this example, client) sends empty packets (&#x1f441; <code>length 0</code>); and<br>3) after received the packets, the other side (server) reply with <code>ACK</code> (&#x1f441; <code>Flags [.]</code>); and<br>4) <code>TCP_KEEPIDLE</code> defines the heartbeat frequency (&#x1f441; timestamps).<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flags = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sfd, SOL_TCP, TCP_KEEPIDLE, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags))) &#123; perror(<span class="string">"ERROR: setsocketopt(), SO_KEEPIDLE"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;;</span><br></pre></td></tr></table></figure></p><p>Note that throughout the process, the <code>read()</code> is blocked in the server side, which means the heartbeat packets are transparent to the recipient (server).</p><h1 id="To-detect-an-absent-peer"><a href="#To-detect-an-absent-peer" class="headerlink" title="To detect an absent peer"></a>To detect an absent peer</h1><p>Besides <em>NAT</em> entry expiration, a connection can be dropped silently in one way or another (e.g., a loosen cable). It is crucial for a server application to identify such exception in time, so it can release the associated resources, invoke clean-up routines and/or notify other peer clients. This is why sending heartbeats from server-side makes more sense.</p><p>Since our feet is already wet.<br>5) <code>TCP_KEEPINTVL</code> defines the heartbeat frequency when there is no answer from the other side; and<br>6) <code>TCP_KEEPCNT</code> dictates how many unanswered heartbeat will indicate a dropped connection;</p><p>Next we modify the server and client code to test this feature</p><p>in server, we added all the mentioned socket options,</p><script src="https://gist.github.com/holmeshe/7157ca6174964e1114a7d670e581416a.js"></script><p>and client is reduced to</p><script src="https://gist.github.com/holmeshe/c5a19a16f2accd0a4548c15eda3c13ba.js"></script><p>and the <code>tcpdump</code> output (that is executed on server machine, because we are going to unplug the connection from client)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ========================&gt; handshakes are omitted here</span><br><span class="line">20:04:12.535386 IP 192.168.1.66.49232 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 12312604 ecr 9154395], length 0</span><br><span class="line">20:04:22.538591 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9161936 ecr 12312604], length 0</span><br><span class="line">20:04:22.570817 IP 192.168.1.66.49232 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 12315113 ecr 9154395], length 0</span><br><span class="line">// ========================&gt; we unplug the network connection here</span><br><span class="line">20:04:32.586590 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9164448 ecr 12315113], length 0</span><br><span class="line">20:04:37.594590 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9165700 ecr 12315113], length 0</span><br><span class="line">20:04:42.602590 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9166952 ecr 12315113], length 0</span><br><span class="line">20:04:47.610591 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9168204 ecr 12315113], length 0</span><br><span class="line">20:04:52.618596 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9169456 ecr 12315113], length 0</span><br></pre></td></tr></table></figure><p>Because we set 5 as the threshold number of unacknowledged packets, and each is 5 seconds apart, (&#x1f441; timestamps)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flags = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sfd, SOL_TCP, TCP_KEEPCNT, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags))) &#123; perror(<span class="string">"ERROR: setsocketopt(), SO_KEEPCNT"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;;</span><br><span class="line"></span><br><span class="line">flags = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sfd, SOL_TCP, TCP_KEEPINTVL, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags))) &#123; perror(<span class="string">"ERROR: setsocketopt(), SO_KEEPINTVL"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;;</span><br></pre></td></tr></table></figure><p>after 5 heartbeats that are unanswered from the client, the </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = read(rfd, buffer, BUF_SIZE);</span><br></pre></td></tr></table></figure><p>is unblocked with an <code>n</code> indicating a closed connection. So that the process of breaking a connection, unlike heartbeat itself, notifies the monitor (server in this case) which in turn can trigger the mentioned actions to finalize a broken connection.</p><h1 id="Consideration"><a href="#Consideration" class="headerlink" title="Consideration"></a>Consideration</h1><h2 id="When-heartbeat-should-not-be-used"><a href="#When-heartbeat-should-not-be-used" class="headerlink" title="When heartbeat should not be used"></a>When heartbeat should not be used</h2><p>In mobile network, periodic data transfer will unnecessarily keep the radio active. When this happens in background, the application drains the battery fast and surprises users. So I would go for the extra miles preparing to reconnecting in such case.</p><h2 id="When-heartbeat-could-not-be-used"><a href="#When-heartbeat-could-not-be-used" class="headerlink" title="When heartbeat could not be used"></a>When heartbeat could not be used</h2><p>For a back-end with heavy traffic, the packets generated by business logic alone can be indicators of connectivity. In such case, I would make the server drop a connection after a client has not been sending packets for a long period of time.</p><p>Alternatively, if I need to further reduce false-positive, I could activate the heartbeat mechanism (through <code>setsockopt()</code>) only for a prolonged silence of a client. It is worth noting that when modifying socket option midway, <code>setsockopt()</code> should work on the file descriptor returned by the <code>accept()</code>, i.e., <code>rdf</code> which represents a established connection. (and other settings will be “inherited” from <code>sdf</code>)</p><h2 id="System-wide-setting"><a href="#System-wide-setting" class="headerlink" title="System wide setting"></a>System wide setting</h2><p>Some of the discussed socket options can also be set using <code>procfs</code> and <code>sysctl</code>.</p><p><code>TCP_KEEPIDLE</code> -&gt; <code>/net/ipv4/tcp_keepalive_time</code><br><code>TCP_KEEPCNT</code> -&gt; <code>/net/ipv4/tcp_keepalive_probes</code><br><code>TCP_KEEPINTVL</code> -&gt; <code>/net/ipv4/tcp_keepalive_intvl</code></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://hpbn.co/" target="_blank" rel="noopener">https://hpbn.co/</a><br><a href="https://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/" target="_blank" rel="noopener">https://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/</a><br><a href="https://gist.github.com/physacco/5792698" target="_blank" rel="noopener">https://gist.github.com/physacco/5792698</a><br><a href="https://notes.shichao.io/unp/ch7/#so_keepalive-socket-option" target="_blank" rel="noopener">https://notes.shichao.io/unp/ch7/#so_keepalive-socket-option</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;There are two end purposes for sending heartbeats through a persistent connection. For a back-end application, heartbeats are generally used to detect an absent client, so as to drop a connection and release the associated resources; for a client, on the contrary, it is to prevent connection resources stored within intermediate nodes being released (such as a &lt;em&gt;NAT&lt;/em&gt; router), &lt;code&gt;SO&lt;/code&gt; as to &lt;code&gt;KEEP&lt;/code&gt; the connection &lt;code&gt;ALIVE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This article will examine how to configure the four socket options, &lt;code&gt;SO_KEEPALIVE&lt;/code&gt;, &lt;code&gt;TCP_KEEPIDLE&lt;/code&gt;, &lt;code&gt;TCP_KEEPINTVL&lt;/code&gt; and &lt;code&gt;TCP_KEEPCNT&lt;/code&gt; with &lt;code&gt;setsockopt()&lt;/code&gt; to send heartbeats; and discuss the practice of keep-alive heartbeats in general.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Experiment setting&lt;/strong&gt;:&lt;br&gt;&lt;em&gt;OS: Unbutu 16.04&lt;/em&gt;&lt;br&gt;&lt;em&gt;gcc: 5.4.0&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Network Essentials" scheme="https://holmeshe.me/categories/Network-Essentials/"/>
    
    
      <category term="network" scheme="https://holmeshe.me/tags/network/"/>
    
      <category term="socket" scheme="https://holmeshe.me/tags/socket/"/>
    
      <category term="setsockopt" scheme="https://holmeshe.me/tags/setsockopt/"/>
    
      <category term="SOL_SOCKET" scheme="https://holmeshe.me/tags/SOL-SOCKET/"/>
    
      <category term="SO_KEEPALIVE" scheme="https://holmeshe.me/tags/SO-KEEPALIVE/"/>
    
      <category term="heartbeat" scheme="https://holmeshe.me/tags/heartbeat/"/>
    
  </entry>
  
  <entry>
    <title>Smart Pointer, shared_ptr, Automatic pointer, and unique_ptr</title>
    <link href="https://holmeshe.me/cpp-pointers/"/>
    <id>https://holmeshe.me/cpp-pointers/</id>
    <published>2017-10-05T11:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<p>Objects life-cycle is crucial. A mistake in determining an object’s lifecycle can lead to resource (e.g., memory, fd) leaks as the resource owned cannot be properly released and recycled for future use. When the leak accumulates to a certain level, it crashes the whole system.</p><p>Objects life-cycle is also complicated since the ownership of one object might be relinquished by, transferred to, or shared with different entities which include but are not limited to variables, function arguments, modules, data structures, containers, and threads. Again, the resource has to be released and recycled by one of the owners at some undetermined point.</p><p>There is no de-facto standard to determine objects life-cycle. Utilities like <strong>GC</strong> (garbage collection) that is used in Java, <strong>ARC</strong> used in Objective-C and all those pointers (ptrs) in C++, all have their pros and cons. However, this article is not about pros and cons but is focused on C++ resource management helper classes, <strong>Smart Pointer</strong>, <code>shared_ptr</code>, <code>auto_ptr</code> and <code>unique_ptr</code>.</p><a id="more"></a><h1 id="Smart-pointer"><a href="#Smart-pointer" class="headerlink" title="Smart pointer"></a>Smart pointer</h1><p>A <strong>smart pointer</strong> is a wrapper class of a normal pointer. <strong>Smart point</strong> defines life-cycle with a reference count that reflects how many time the smart pointer object is referenced.<br>Next, I will show a simple implementation of a <strong>smart pointer</strong>. The code is for demonstration purposes only, thus, there is no sanity check, no exception handling and no thread-safety guarantee.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="class"><span class="keyword">class</span> <span class="title">SmartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* _pRes;</span><br><span class="line">  <span class="keyword">int</span>* _refCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _release() &#123;</span><br><span class="line">    <span class="keyword">if</span>(--(*_refCount) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"---Valar Morghulis:%d\n"</span>,*_refCount);</span><br><span class="line">      <span class="keyword">delete</span> _pRes;</span><br><span class="line">      <span class="keyword">delete</span> _refCount;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"---not today:%d\n"</span>,*_refCount);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  SmartPointer() : _pRes(<span class="literal">NULL</span>), _refCount(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    _refCount = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SP default cons:%d\n"</span>,*_refCount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">SmartPointer(T* pRes) : _pRes(pRes), _refCount(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    _refCount = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SP cons:%d\n"</span>,*_refCount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">SmartPointer(<span class="keyword">const</span> SmartPointer&lt;T&gt;&amp; sp) : _pRes(sp._pRes), _refCount(sp._refCount) &#123;</span><br><span class="line">    (*_refCount)++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SP copy cons:%d\n"</span>,*_refCount);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">SmartPointer&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> SmartPointer&lt;T&gt;&amp; sp) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_release(); <span class="comment">// release the last resource it points to </span></span><br><span class="line">    _pRes = sp._pRes;</span><br><span class="line">    _refCount = sp._refCount;</span><br><span class="line">    (*_refCount)++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SP assign:%d\n"</span>,*_refCount);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">~SmartPointer() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_release();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to mimic a real pointer</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>* () &#123;</span><br><span class="line">    <span class="keyword">return</span> *_pRes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to mimic a real pointer</span></span><br><span class="line">  T* <span class="keyword">operator</span>-&gt; () &#123;</span><br><span class="line">    <span class="keyword">return</span> _pRes;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  AClass() &#123; <span class="built_in">printf</span>(<span class="string">"aclass cons\n"</span>); &#125;</span><br><span class="line">  ~AClass() &#123; <span class="built_in">printf</span>(<span class="string">"aclass des\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l2</span><span class="params">(SmartPointer&lt;AClass&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">  SmartPointer&lt;AClass&gt; use3 = p;        <span class="comment">// &gt;&gt; SP copy cons:3</span></span><br><span class="line">&#125;                                       <span class="comment">// &gt;&gt; ---not today:2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l1</span><span class="params">(SmartPointer&lt;AClass&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">  SmartPointer&lt;AClass&gt; use2 = p;        <span class="comment">// &gt;&gt; SP copy cons:2</span></span><br><span class="line">  l2(p);</span><br><span class="line">&#125;                                       <span class="comment">// &gt;&gt; ---not today:1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  AClass *res = <span class="keyword">new</span> AClass();           <span class="comment">// &gt;&gt; aclass cons</span></span><br><span class="line">  <span class="function">SmartPointer&lt;AClass&gt; <span class="title">aSmartP</span><span class="params">(res)</span></span>;    <span class="comment">// &gt;&gt; SP cons:1</span></span><br><span class="line">  l1(aSmartP);</span><br><span class="line">&#125;                                       <span class="comment">// &gt;&gt; ---Valar Morghulis:0</span></span><br><span class="line">                                        <span class="comment">// &gt;&gt; aclass des</span></span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aclass cons</span><br><span class="line">SP cons:<span class="number">1</span></span><br><span class="line">SP copy cons:<span class="number">2</span></span><br><span class="line">SP copy cons:<span class="number">3</span></span><br><span class="line">---<span class="keyword">not</span> today:<span class="number">2</span></span><br><span class="line">---<span class="keyword">not</span> today:<span class="number">1</span></span><br><span class="line">---Valar Morghulis:<span class="number">0</span></span><br><span class="line">aclass des</span><br></pre></td></tr></table></figure><p>To briefly explain the code above:</p><ol><li><code>SmartPointer</code>‘s life-cycle is no more than that of an ordinary class. Thus, logic flow going out of a (function) scope destructs it;</li><li><code>SmartPointer</code> has two properties, <code>_pRes</code> and <code>_refCount</code>, both are allocated from heap. Thus, logic flow going out of a (function) scope DOES NOT destruct them;</li><li>each time a <code>SmartPointer</code> is constructed with a valid <code>_pRes</code> (of type <code>T</code>), the <code>_refCount</code> plus <code>1</code>;</li><li>each time a <code>SmartPointer</code> is destructed, in our case, by a logic flow going out of a scope, the <code>_refCount</code> minus <code>1</code>;</li><li>however, the destruction of <code>SmartPointer</code> does not necessarily lead to a destruction of <code>_pRes</code>:</li></ol><p>a)        when <code>_refCount</code> is still larger than <code>0</code>, <code>SmartPointer</code> simply reduce the <code>_refCount</code> and print</p><p><img src="/gallery/pointers_not_today.jpeg" alt="not today"></p><p>b)        only when <code>_refCount</code> is set to <code>0</code> by the minus, <code>SmartPointer</code> destructs the resource referred by <code>_pRes</code> and and print</p><p><img src="/gallery/pointers_all_die.jpeg" alt="All men must die"></p><p>So <strong>smart pointers</strong> work as handles that are used by different parts of a program to keep track and to control the resource instance. When all handles are destroyed, the resource is considered “not used”, and is deleted as well. In the end of this article, I will show some real handles that embody <strong>smart pointer</strong> in real world.</p><p>The sample showcases the usage of <strong>smart pointer</strong> in program that is linear, which is rarely the case in real scenario. Rather, as mentioned before, the resource (i.e., the instance of <code>AClass</code>) can be shared, by multiple data structure and variables in parallel.</p><h1 id="shared-ptr-C-11"><a href="#shared-ptr-C-11" class="headerlink" title="shared_ptr (C++11)"></a>shared_ptr (C++11)</h1><p><code>shared_ptr</code> is the std’s implementation of <strong>smart pointer</strong> that is more robust than the demo code listed above. And it does not generate dodgy log.</p><h1 id="Automatic-pointer"><a href="#Automatic-pointer" class="headerlink" title="Automatic pointer"></a>Automatic pointer</h1><p>An <strong>automatic pointer</strong>, though looks similar to <strong>smart pointer</strong>, is totally different. It is a convenient helper class that destructs the resource whenever the logic flow going out of the scope, just in case a programmer forgets. To some extent, it makes a pointer (that refers to a memory chunk dynamically allocated in runtime) works similar to a stack variable (statically allocated in compiling time).</p><p>Example, AutoPointer v1.0:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">typename</span> T &gt; <span class="class"><span class="keyword">class</span> <span class="title">AutoPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T* _pRes;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  AutoPointer() : _pRes(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  AutoPointer(T* pRes) : _pRes(pRes) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  AutoPointer(<span class="keyword">const</span> AutoPointer&lt;T&gt;&amp; ap) : _pRes(ap._pRes) &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  AutoPointer&lt;T&gt;&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> AutoPointer&lt;T&gt;&amp; ap) &#123;</span><br><span class="line">    <span class="keyword">delete</span> _pRes;</span><br><span class="line">    _pRes = ap._pRes;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  ~AutoPointer() &#123;</span><br><span class="line">    <span class="keyword">delete</span> _pRes;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// to mimic a real pointer</span></span><br><span class="line">  T&amp; <span class="keyword">operator</span>* () &#123;</span><br><span class="line">    <span class="keyword">return</span> *_pRes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// to mimic a real pointer</span></span><br><span class="line">  T* <span class="keyword">operator</span>-&gt; () &#123;</span><br><span class="line">    <span class="keyword">return</span> _pRes;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  AClass() &#123; <span class="built_in">printf</span>(<span class="string">"cons\n"</span>); &#125;</span><br><span class="line">  ~AClass() &#123; <span class="built_in">printf</span>(<span class="string">"des\n"</span>); &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l1</span><span class="params">(AutoPointer&lt;AClass&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">  AutoPointer&lt;AClass&gt; use2 = p;</span><br><span class="line">&#125;<span class="comment">//the resource has already been deallocated here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  AClass *res = <span class="keyword">new</span> AClass();</span><br><span class="line">  res-&gt;i = <span class="number">5</span>;</span><br><span class="line">  <span class="function">AutoPointer&lt;AClass&gt; <span class="title">use1</span><span class="params">(res)</span></span>;</span><br><span class="line">  l1(use1);</span><br><span class="line">&#125;<span class="comment">// abort, repeat deallocating pointer</span></span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cons</span><br><span class="line">des</span><br><span class="line">des</span><br><span class="line">autop(1148,0x7fff74eff000) malloc: *** error for object 0x7f9940c03240: pointer being freed was not allocated</span><br><span class="line">*** set a breakpoint in malloc_error_break to debug</span><br><span class="line">[1] 1148 abort ./a.out</span><br></pre></td></tr></table></figure><p>As given by the code snippet above, <strong>automatic pointer</strong> works internally like a simplified <strong>smart pointer</strong> that deallocates the resource regardless of the reference count (in fact, there is no reference count at all).</p><p>The coredump shows a major drawback of the <strong>automatic pointer</strong>: the ownership can not be transferred (to l1() ). As a result, even though the resource has been deallocate in l1(), main()still consider itself as the owner of <strong>automatic pointer</strong> and deallocates the pointer one time more.</p><p>How about implementing the copy constructor as well as the assignment operator so the ownership can be properly transferred?</p><p>Example, AutoPointer v2.0:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  AutoPointer(AutoPointer&lt;T&gt;&amp; ap) : _pRes(ap._pRes) &#123;</span><br><span class="line">    ap._pRes = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  AutoPointer&lt;T&gt;&amp; <span class="keyword">operator</span> = (AutoPointer&lt;T&gt;&amp; ap) &#123;</span><br><span class="line">    <span class="keyword">delete</span> _pRes;</span><br><span class="line">    _pRes = ap._pRes;</span><br><span class="line"></span><br><span class="line">    ap._pRes = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cons</span><br><span class="line">des</span><br></pre></td></tr></table></figure><p>All seems good. Yet it is another example of “fixing one bug leads to another”.</p><p>The new problem is that the two semantics, ownership-transferring and copy, are coupled. So it is not compatible to some of the library functions such as <code>std::sort</code> that takes one extra copy (as pivot in quick sort) as it destroys the previous one that is still in use. The detailed explanation of the problem can be found <a href="http://www.gotw.ca/gotw/025.htm" target="_blank" rel="noopener">here</a>, and thanks <a href="https://www.reddit.com/user/" target="_blank" rel="noopener">patatahooligan</a> for pointing out the mistake in the original implementation.</p><p><code>std::auto_ptr</code> is the std implementation of the <strong>automatic pointer</strong>. As discussed above, it is either not very interesting or problematic, so it is now deprecated. And we should use <code>std::unique_ptr</code> instead.</p><h1 id="std-unique-ptr-C-11"><a href="#std-unique-ptr-C-11" class="headerlink" title="std::unique_ptr (C++11)"></a>std::unique_ptr (C++11)</h1><p><code>std::unique_ptr</code> is the std’s replacement of <code>std::auto_ptr</code> in C++11. With the newly added <a href="http://holmeshe.me/cpp-rvalue-and-move/"><strong>rvalue</strong> and <strong>move</strong> semantics</a>, the ownership of a <code>unique_ptr</code> can be safely transferred to another entity. Moreover, the copy semantic is disabled for <code>unique_ptrs</code> to avoid ambiguity we saw in AutoPointer v2.0. Like <strong>automatic pointer</strong>, the last owner of the pointer is responsible for deallocation.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  AClass() &#123;<span class="built_in">printf</span>(<span class="string">"cons\n"</span>);&#125;</span><br><span class="line">  ~AClass() &#123;<span class="built_in">printf</span>(<span class="string">"des\n"</span>);&#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AClass&gt; &gt; v;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AClass&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> AClass())</span></span>;    <span class="comment">// &gt;&gt; cons</span></span><br><span class="line">  p1-&gt;i = <span class="number">1</span>;</span><br><span class="line">  v.push_back(<span class="built_in">std</span>::move(p1));</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;AClass&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> AClass())</span></span>;    <span class="comment">// &gt;&gt; cons</span></span><br><span class="line">  p2-&gt;i = <span class="number">2</span>;</span><br><span class="line">  v.push_back(<span class="built_in">std</span>::move(p2));</span><br><span class="line">&#125; <span class="comment">// p1 and p2 are not destructed here</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  l1();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p: v) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;i);</span><br><span class="line">&#125;                                              <span class="comment">// &gt;&gt; des</span></span><br><span class="line">                                               <span class="comment">// &gt;&gt; des</span></span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cons</span><br><span class="line">cons</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">des</span><br><span class="line">des</span><br></pre></td></tr></table></figure><p>As shown in the code snippet above, the <strong>unique pointer</strong> is preserved across different owners. When the ownership has been <strong>moved</strong> to <code>vector v</code>, <code>l1()</code> does not deallocates the resource anymore. This gains <strong>unique pointer</strong> a much wider usage.</p><p>N.b., I would rather believe <strong>unique pointer</strong> is the major reason of the introduction of the new move semantic. Because compared to the improvement gained here, the <a href="http://holmeshe.me/cpp-rvalue-and-move/">optimization enabled by move and rvalue</a> is less significant.</p><h1 id="Take-home"><a href="#Take-home" class="headerlink" title="Take home"></a>Take home</h1><p>“I can understand the stuffs, but I’m not sure if I still remember them exactly next morning.”</p><p>Sure. I will find some real world counterparts to enhance your memory.</p><p>1) a <code>std::shared_ptr</code> is like a handle of a video game console.</p><p><img src="/gallery/pointers_n64.jpeg" alt></p><p>The console (resource) is “<strong>shared</strong>” by multiple players with handles, and the game should continue even if there is only one player left. Thus, “Game over” only when all players stop playing.</p><p>2) a <code>std::unique_ptr</code> is like a portable game console.</p><p><img src="/gallery/pointers_gb.jpeg" alt></p><p>One player at a time, and one should “<strong>move</strong>” it to let another to play. “Game over” when the LAST player stops playing.</p><p>3) a <code>std::auto_ptr</code> is a</p><p><img src="/gallery/pointers_pqg.jpeg" alt></p><p>as it can not be easily <strong>moved</strong>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objects life-cycle is crucial. A mistake in determining an object’s lifecycle can lead to resource (e.g., memory, fd) leaks as the resource owned cannot be properly released and recycled for future use. When the leak accumulates to a certain level, it crashes the whole system.&lt;/p&gt;
&lt;p&gt;Objects life-cycle is also complicated since the ownership of one object might be relinquished by, transferred to, or shared with different entities which include but are not limited to variables, function arguments, modules, data structures, containers, and threads. Again, the resource has to be released and recycled by one of the owners at some undetermined point.&lt;/p&gt;
&lt;p&gt;There is no de-facto standard to determine objects life-cycle. Utilities like &lt;strong&gt;GC&lt;/strong&gt; (garbage collection) that is used in Java, &lt;strong&gt;ARC&lt;/strong&gt; used in Objective-C and all those pointers (ptrs) in C++, all have their pros and cons. However, this article is not about pros and cons but is focused on C++ resource management helper classes, &lt;strong&gt;Smart Pointer&lt;/strong&gt;, &lt;code&gt;shared_ptr&lt;/code&gt;, &lt;code&gt;auto_ptr&lt;/code&gt; and &lt;code&gt;unique_ptr&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Rvisit C++" scheme="https://holmeshe.me/categories/Rvisit-C/"/>
    
    
      <category term="Smart Pointer" scheme="https://holmeshe.me/tags/Smart-Pointer/"/>
    
      <category term="shared ptr" scheme="https://holmeshe.me/tags/shared-ptr/"/>
    
      <category term="automatic ptr" scheme="https://holmeshe.me/tags/automatic-ptr/"/>
    
      <category term="unique ptr" scheme="https://holmeshe.me/tags/unique-ptr/"/>
    
  </entry>
  
  <entry>
    <title>C++ rvalue, &amp;&amp; and Move</title>
    <link href="https://holmeshe.me/cpp-rvalue-and-move/"/>
    <id>https://holmeshe.me/cpp-rvalue-and-move/</id>
    <published>2017-09-19T12:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++ is hard, the newer versions become even harder. This article will deal with some of the hard parts in C++, rvalue, rvalue reference (&amp;&amp;) and move semantics. And I am going to reverse engineer (not a metaphor) these complex and correlated topics, so you can understand them completely in one shot.</p></blockquote><a id="more"></a><p>Firstly, let’s examine</p><h1 id="What-is-a-rvalue"><a href="#What-is-a-rvalue" class="headerlink" title="What is a rvalue?"></a>What is a rvalue?</h1><p>A rvalue is one that should be on the right side of an equals sign.</p><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var; <span class="comment">// too much JavaScript recently:)</span></span><br><span class="line">var = <span class="number">8</span>; <span class="comment">// OK! lvalue (yes, there is a lvalue) on the left</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span> = var; <span class="comment">// ERROR! rvalue on the left</span></span><br><span class="line">(var + <span class="number">1</span>) = <span class="number">8</span>; <span class="comment">// ERROR! rvalue on the left</span></span><br></pre></td></tr></table></figure><p>Simple enough. Then let’s look at some more subtle rvalues, ones that are returned by functions:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_var = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">returnALvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> g_var; <span class="comment">//here we return a lvalue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">returnARvalue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> g_var; <span class="comment">//here we return a rvalue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d"</span>, returnALvalue()++); <span class="comment">// g_var += 1;</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d"</span>, returnARvalue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>It is worth noting that the way of returning a l-value (in the example) is considered a bad practice. So do not do that in real world programming.</p><h1 id="Beyond-theoretical-level"><a href="#Beyond-theoretical-level" class="headerlink" title="Beyond theoretical level"></a>Beyond theoretical level</h1><p>Whether a variable is a rvalue can make differences in real programming even before <code>&amp;&amp;</code> is invented.</p><p>For example, this line</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; var = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>can be compiled fine while this:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; var = <span class="number">8</span>; <span class="comment">// use a lvalue reference for a rvalue</span></span><br></pre></td></tr></table></figure><p>generates following error:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rvalue.cc:24:6: error: non-const lvalue reference to type &apos;int&apos; cannot bind to a</span><br><span class="line">      temporary of type &apos;int&apos;</span><br></pre></td></tr></table></figure><p>The error message means that the compiler enforces a const reference for rvalue.</p><p>A more interesting example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rvalue detected:%s\n"</span>, name.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"lvalue detected:%s\n"</span>, name.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">"lvalue"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> rvalu = <span class="string">"rvalu"</span>;</span><br><span class="line"></span><br><span class="line">    print(name); <span class="comment">//compiler can detect the right function for lvalue</span></span><br><span class="line">    print(rvalu + <span class="string">"e"</span>); <span class="comment">// likewise for rvalue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvalue detected:lvalue</span><br><span class="line">rvalue detected:rvalue</span><br></pre></td></tr></table></figure><p>The difference is actually significant enough and compiler can determine overloaded functions.</p><h1 id="So-rvalue-is-constant-value"><a href="#So-rvalue-is-constant-value" class="headerlink" title="So rvalue is constant value?"></a>So rvalue is constant value?</h1><p>Not exactly. And this where <code>&amp;&amp;</code> (rvalue reference)comes in.</p><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(“<span class="keyword">const</span> value detected:%s\n”, name.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(“lvalue detected%s\n”, name.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(“rvalue detected:%s\n”, name.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name = “lvalue”;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> cname = “cvalue”;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> rvalu = <span class="string">"rvalu"</span>;</span><br><span class="line"></span><br><span class="line">  print(name);</span><br><span class="line">  print(cname);</span><br><span class="line">  print(rvalu + <span class="string">"e"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lvalue detected:lvalue</span><br><span class="line">const value detected:cvalue</span><br><span class="line">rvalue detected:rvalue</span><br></pre></td></tr></table></figure><p>If the functions are overloaded for rvalue, a rvalue variable choose the more specified version over the version takes a const reference parameter that is compatible for both. Thus, <code>&amp;&amp;</code> can further diversify rvalue from const value.</p><p>In bellow I summarize the compatibility of overloaded function versions to different types in default setting. You can verify the result by selectively commenting out lines in the example above.</p><p><img src="/gallery/compatibility.png" alt="compatibility"></p><p>It sounds cool to further differentiate rvalue and constant value as they are not exactly the same indeed. But what is the practical value?</p><h1 id="What-problem-does-amp-amp-solve-exactly"><a href="#What-problem-does-amp-amp-solve-exactly" class="headerlink" title="What problem does &amp;&amp; solve exactly?"></a>What problem does &amp;&amp; solve exactly?</h1><p>The problem is the unnecessary deep copy when the argument is a rvalue.</p><p>To be more specific. <code>&amp;&amp;</code> notation is provided to specify a rvalue, which can be used to avoid the deep copy when the rvalue, 1) is passed as an argument of either a constructor or an assignment operator, and 2) the class of which contains a pointer (or pointers) referring to dynamically allocated resource (memory).</p><p>It can be more specific with examples:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceOwner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ResourceOwner(<span class="keyword">const</span> <span class="keyword">char</span> res[]) &#123;</span><br><span class="line">    theResource = <span class="keyword">new</span> <span class="built_in">string</span>(res);</span><br><span class="line">  &#125;</span><br><span class="line">  ResourceOwner(<span class="keyword">const</span> ResourceOwner&amp; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"copy %s\n"</span>, other.theResource-&gt;c_str());</span><br><span class="line">    theResource = <span class="keyword">new</span> <span class="built_in">string</span>(other.theResource-&gt;c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  ResourceOwner&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ResourceOwner&amp; other) &#123;</span><br><span class="line">    ResourceOwner tmp(other);</span><br><span class="line">    swap(theResource, tmp.theResource);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"assign %s\n"</span>, other.theResource-&gt;c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  ~ResourceOwner() &#123;</span><br><span class="line">    <span class="keyword">if</span> (theResource) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"destructor %s\n"</span>, theResource-&gt;c_str());</span><br><span class="line">      <span class="keyword">delete</span> theResource;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span>* theResource;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCopy</span><span class="params">()</span> </span>&#123; <span class="comment">// case 1</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"=====start testCopy()=====\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">ResourceOwner <span class="title">res1</span><span class="params">(<span class="string">"res1"</span>)</span></span>;</span><br><span class="line">  ResourceOwner res2 = res1;  <span class="comment">//copy res1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"=====destructors for stack vars, ignore=====\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAssign</span><span class="params">()</span> </span>&#123; <span class="comment">// case 2</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"=====start testAssign()=====\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">ResourceOwner <span class="title">res1</span><span class="params">(<span class="string">"res1"</span>)</span></span>;</span><br><span class="line">  <span class="function">ResourceOwner <span class="title">res2</span><span class="params">(<span class="string">"res2"</span>)</span></span>;</span><br><span class="line">  res2 = res1; <span class="comment">//copy res1, assign res1, destrctor res2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"=====destructors for stack vars, ignore=====\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testRValue</span><span class="params">()</span> </span>&#123; <span class="comment">// case 3</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"=====start testRValue()=====\n"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="function">ResourceOwner <span class="title">res2</span><span class="params">(<span class="string">"res2"</span>)</span></span>;</span><br><span class="line">  res2 = ResourceOwner(<span class="string">"res1"</span>); <span class="comment">//copy res1, assign res1, destructor res2, destructor res1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"=====destructors for stack vars, ignore=====\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  testCopy();</span><br><span class="line">  testAssign();</span><br><span class="line">  testRValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">=====start testCopy()=====</span><br><span class="line">copy res1</span><br><span class="line">=====destructors for stack vars, ignore=====</span><br><span class="line">destructor res1</span><br><span class="line">destructor res1</span><br><span class="line">=====start testAssign()=====</span><br><span class="line">copy res1</span><br><span class="line">assign res1</span><br><span class="line">destructor res2</span><br><span class="line">=====destructors for stack vars, ignore=====</span><br><span class="line">destructor res1</span><br><span class="line">destructor res1</span><br><span class="line">=====start testRValue()=====</span><br><span class="line">copy res1</span><br><span class="line">assign res1</span><br><span class="line">destructor res2</span><br><span class="line">destructor res1</span><br><span class="line">=====destructors for stack vars, ignore=====</span><br><span class="line">destructor res1</span><br></pre></td></tr></table></figure><p>The result are all good for the first two test cases, i.e., <code>testCopy()</code> and <code>testAssign()</code>, in which resource in <code>res1</code> is copied for the <code>res2</code>. It is reasonable to copy the resource because they are two entities both need their unshared resource (a string).</p><p>However, in the third case, the (deep) copying of the resource in <code>res1</code> is superfluous because the anonymous rvalue (returned by ResourceOwner(<code>“res1”</code>)) will be destructed right after the assignment thus it does not need the resource anymore:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res2 = ResourceOwner(&quot;res1&quot;); // Please note that the destructor res1 is called right after this line before the point where stack variables are destructed.</span><br></pre></td></tr></table></figure><p>I think it is a good chance to repeat the problem statement:</p><blockquote><p><code>&amp;&amp;</code> notation is provided to specify a rvalue, which can be used to avoid the deep copy when the rvalue, 1) is passed as an argument of either a constructor or an assignment operator, and 2) the class of which contains a pointer (or pointers) referring to dynamically allocated resource (memory).</p></blockquote><p>If copying of a resource that is about to disappear is not optimal, what is the right operation then? The answer is</p><h1 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h1><p>The idea is pretty straightforward, if the argument is a rvalue, we do not need to copy. Rather, we can simply “move” the resource (that is the memory the rvalue points to). Now let’s overload the assignment operator using the new technique:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResourceOwner&amp; <span class="keyword">operator</span>=(ResourceOwner&amp;&amp; other) &#123;</span><br><span class="line">  theResource = other.theResource;</span><br><span class="line">  other.theResource = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This new assignment operator is called a <strong>move</strong> assignment operator. And a <strong>move</strong> constructor can be programmed in a similar way.</p><p>A good way of understanding this is: when you sell your old property and move to a new house, you do not have to toss all the furniture as we did in case 3 right? Rather, you can simply move the furniture to the new home.</p><p>All good.</p><h1 id="What-is-std-move"><a href="#What-is-std-move" class="headerlink" title="What is std::move?"></a>What is std::move?</h1><p>Besides the <strong>move</strong> assignment operator and <strong>move</strong> constructor discussed above, there is one last missing piece in this puzzle, <code>std::move</code>.</p><p>Again, we look at the problem first:</p><p>when 1) we know a variable is in fact a rvalue, while 2) the compiler does not. The right version of the overloaded functions can not be called.</p><p>A common case is when we add another layer of resource owner, <code>ResourceHolder</code> and the relation of the three entities is given as bellow:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">holder</span><br><span class="line"> |</span><br><span class="line"> |-----&gt;owner</span><br><span class="line">         |</span><br><span class="line">         |-----&gt;resource</span><br></pre></td></tr></table></figure><p>(N.b., in the following example, I complete the implementation of <code>ResourceOwner</code>’s <strong>move</strong> constructor as well)</p><p>Example:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceOwner</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ResourceOwner(<span class="keyword">const</span> <span class="keyword">char</span> res[]) &#123;</span><br><span class="line">    theResource = <span class="keyword">new</span> <span class="built_in">string</span>(res);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ResourceOwner(<span class="keyword">const</span> ResourceOwner&amp; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(“copy %s\n”, other.theResource-&gt;c_str());</span><br><span class="line">    theResource = <span class="keyword">new</span> <span class="built_in">string</span>(other.theResource-&gt;c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">++ResourceOwner(ResourceOwner&amp;&amp; other) &#123;</span><br><span class="line">++ <span class="built_in">printf</span>(“move cons %s\n”, other.theResource-&gt;c_str());</span><br><span class="line">++ theResource = other.theResource;</span><br><span class="line">++ other.theResource = <span class="literal">NULL</span>;</span><br><span class="line">++&#125;</span><br><span class="line"></span><br><span class="line">  ResourceOwner&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ResourceOwner&amp; other) &#123;</span><br><span class="line">    ResourceOwner tmp(other);</span><br><span class="line">    swap(theResource, tmp.theResource);</span><br><span class="line">    <span class="built_in">printf</span>(“assign %s\n”, other.theResource-&gt;c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">++ResourceOwner&amp; <span class="keyword">operator</span>=(ResourceOwner&amp;&amp; other) &#123;</span><br><span class="line">++ <span class="built_in">printf</span>(“move assign %s\n”, other.theResource-&gt;c_str());</span><br><span class="line">++ theResource = other.theResource;</span><br><span class="line">++ other.theResource = <span class="literal">NULL</span>;</span><br><span class="line">++&#125;</span><br><span class="line"></span><br><span class="line">  ~ResourceOwner() &#123;</span><br><span class="line">    <span class="keyword">if</span> (theResource) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(“destructor %s\n”, theResource-&gt;c_str());</span><br><span class="line">      <span class="keyword">delete</span> theResource;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">string</span>* theResource;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceHolder</span> &#123;</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">ResourceHolder&amp; <span class="keyword">operator</span>=(ResourceHolder&amp;&amp; other) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(“move assign %s\n”, other.theResource-&gt;c_str());</span><br><span class="line">  resOwner = other.resOwner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ResourceOwner resOwner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>In <code>ResourceHolder</code>’s <strong>move</strong> assignment operator, we want to call <code>ResourceOwner</code>’s <strong>move</strong> assignment operator since “a no-pointer member of a rvalue should be a rvalue too”. However, when we simply code <code>resOwner = other.resOwner</code>, what gets invoked is actually the <code>ResourceOwner</code>’s normal assignment operator that, again, incurs the extra copy.</p><p>It’s a good chance to repeat the problem statement again:</p><blockquote><p>when 1) we know a variable is in fact a rvalue, while 2) the compiler does not. The right version of the overloaded functions can not be called.</p></blockquote><p>As a solution we use to <code>std::move</code> to cast the variable to rvalue, so the right version of <code>ResourceOwner</code>’s assignment operator can be called.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResourceHolder&amp; operator=(ResourceHolder&amp;&amp; other) &#123;</span><br><span class="line">  printf(“move assign %s\n”, other.theResource-&gt;c_str());</span><br><span class="line">  resOwner = std::move(other.resOwner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="What-is-std-move-exactly"><a href="#What-is-std-move-exactly" class="headerlink" title="What is std::move exactly?"></a>What is std::move exactly?</h1><p>We know that type cast is not simply a compiler placebo telling a compiler that “I know what I am doing”. It effectively generate instructions of <code>mov</code> a value to bigger or smaller registers (e.g.,<code>%eax</code>-&gt;<code>%cl</code>) to conduct the “cast”.</p><p>So what <code>std::move</code> does exactly behind scene. I do not know myself when I am writing this paragraph, so let’s find out together.</p><p>First we modify the main a bit (I tried to make the style consistent)</p><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">ResourceOwner <span class="title">res</span><span class="params">(“res1”)</span></span>;</span><br><span class="line">  <span class="keyword">asm</span>(“nop”); <span class="comment">// remeber me</span></span><br><span class="line">  ResourceOwner &amp;&amp; rvalue = <span class="built_in">std</span>::move(res);</span><br><span class="line">  <span class="keyword">asm</span>(“nop”); <span class="comment">// remeber me</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Compile it, and dissemble the obj using</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ -g -c -std=c++11 -stdlib=libc++ -Weverything move.cc</span><br><span class="line">gobjdump -d -D move.o</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;_main&gt;:</span><br><span class="line"> 0: 55 push %rbp</span><br><span class="line"> 1: 48 89 e5 mov %rsp,%rbp</span><br><span class="line"> 4: 48 83 ec 20 sub $0x20,%rsp</span><br><span class="line"> 8: 48 8d 7d f0 lea -0x10(%rbp),%rdi</span><br><span class="line"> c: 48 8d 35 41 03 00 00 lea 0x341(%rip),%rsi # 354 &lt;GCC_except_table5+0x18&gt;</span><br><span class="line"> 13: e8 00 00 00 00 callq 18 &lt;_main+0x18&gt;</span><br><span class="line"> 18: 90 nop // remember me</span><br><span class="line"> 19: 48 8d 75 f0 lea -0x10(%rbp),%rsi</span><br><span class="line"> 1d: 48 89 75 f8 mov %rsi,-0x8(%rbp)</span><br><span class="line"> 21: 48 8b 75 f8 mov -0x8(%rbp),%rsi</span><br><span class="line"> 25: 48 89 75 e8 mov %rsi,-0x18(%rbp)</span><br><span class="line"> 29: 90 nop // remember me</span><br><span class="line"> 2a: 48 8d 7d f0 lea -0x10(%rbp),%rdi</span><br><span class="line"> 2e: e8 00 00 00 00 callq 33 &lt;_main+0x33&gt;</span><br><span class="line"> 33: 31 c0 xor %eax,%eax</span><br><span class="line"> 35: 48 83 c4 20 add $0x20,%rsp</span><br><span class="line"> 39: 5d pop %rbp</span><br><span class="line"> 3a: c3 retq</span><br><span class="line"> 3b: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><p>between the two <code>nop</code>, we can notice some dummy instructions generated for the <code>move</code> (if looking closely, you can know that they do basically nothing) However, if we turn on <code>O (-O1)</code> for the compiler, all the instructions will be gone.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clang++ -g -c -O1 -std=c++11 -stdlib=libc++ -Weverything move.cc</span><br><span class="line">gobjdump -d -D move.o</span><br></pre></td></tr></table></figure><p>Moreover, if changing the critical line to:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ResourceOwner &amp; rvalue = res;</span><br></pre></td></tr></table></figure><p>The assembly generated is identical.</p><p>That means the <code>move</code> semantics is pure syntax candy and a machine does not care at all.</p><p>To conclude,</p><blockquote><p>The MACHINE thinks it irrelevant, we don’t.<br>-Harold Finch</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;C++ is hard, the newer versions become even harder. This article will deal with some of the hard parts in C++, rvalue, rvalue reference (&amp;amp;&amp;amp;) and move semantics. And I am going to reverse engineer (not a metaphor) these complex and correlated topics, so you can understand them completely in one shot.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Rvisit C++" scheme="https://holmeshe.me/categories/Rvisit-C/"/>
    
    
      <category term="C++" scheme="https://holmeshe.me/tags/C/"/>
    
      <category term="rvalue" scheme="https://holmeshe.me/tags/rvalue/"/>
    
      <category term="move" scheme="https://holmeshe.me/tags/move/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Tutorial for Programmers - Async</title>
    <link href="https://holmeshe.me/javascript-tutorial-for-experienced-programmer-async/"/>
    <id>https://holmeshe.me/javascript-tutorial-for-experienced-programmer-async/</id>
    <published>2017-09-11T10:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I still remember the days of debugging CORS problem when I put together some projects using JavaScript (&amp; ajax), “a very particular programming language” in my first impression. Recently I got a great opportunity. The new role uses JS, the browser-side script that is now winning in all sides, as the major language. So I tooke it as a good chance to learn JS more systematically, and this series will be part of the outcome of my study. As the name implies, I will not cover primary level such as “if, else” (condition), “for” (or any kinds of loops), or basic OOP concepts. Instead, I will focus only on differences so you can learn this versatile language like reviewing a pull request, and use it the next day in your next awesome project.</p></blockquote><a id="more"></a><h1 id="Nothing-new-under-the-sun"><a href="#Nothing-new-under-the-sun" class="headerlink" title="Nothing new under the sun"></a>Nothing new under the sun</h1><p>Basically, asynchronization has two layers of meaning 1) unblocking of slow operations; and 2) triggering events non-linearly. In OS terms, the event is also called an interruption that can represent a coming network packet, a clock tick, or simply a mouse click. Technically, the event interrupts the current process, puts the next CPU instruction on hold, and calls a predefined code block (a.k.a., an event handler), “asynchronously”.</p><p>The concept is essentially the same in application level.</p><h2 id="The-problem-of-blocking-operations"><a href="#The-problem-of-blocking-operations" class="headerlink" title="The problem of blocking operations"></a>The problem of blocking operations</h2><p>In a narrow sense, asynchronization solves a fundamental difficulty in application development: blocking operation (mostly I/O). Why blocking is difficult? Well, no matter what kinds of App (with UI) you are working on (an embedded system, an mobile App, a game, or a web page), there is a underlying “loop” that refreshes the screen in a very high frequency. If the “loop” is blocked by a slow operation, say, a network interaction, your UI will be frozen, and the users might just let the App go. In particular, JavaScript runs as part of the “loop”, so we need to wield this black magic wisely.</p><p>Before we start experimenting on JS, let’s do some preparations.</p><p>Firstly, we download <a href="https://chrome.google.com/webstore/detail/moesif-origin-cors-change/digfbfaphojjndkpccljibejjbppifbc?hl=en" target="_blank" rel="noopener">Moesif Origin &amp; CORS Changer</a> because we are going to make (a lot of) cross-origin HTTP requests. (as briefly mentioned in my <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-some-basics/">first post</a>)</p><p>Secondly, we use python (Flask) to simulate a slow API which sleeps ten seconds for each request to impose noticeable latency:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(<span class="string">"/lazysvr"</span>)</span><br><span class="line">def recv():</span><br><span class="line">  time.sleep(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"ok"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  app.run(host=<span class="string">'***.***.***.***'</span>, threaded=True)</span><br></pre></td></tr></table></figure><p>Now we toggle the CORS plug-in to “on” (otherwise the network request will fail instantly) and run the example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button type="button"&gt;Click Me!&lt;/</span>button&gt; </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xmlHttp.open( <span class="string">"GET"</span>, <span class="string">"http://***.***.***.***:5000/lazysvr"</span>, <span class="literal">false</span> ); <span class="comment">// false for synchronous request</span></span><br><span class="line">    xmlHttp.send( <span class="literal">null</span> ); <span class="comment">// the thread is suspended here</span></span><br><span class="line">    alert(xmlHttp.responseText);</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>By debugging the code, we can observe that that after the network request, the code is suspended at the following line:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.send( <span class="literal">null</span> ); <span class="comment">// it is the aforementioned blocking operation</span></span><br></pre></td></tr></table></figure><p>for &gt;10 seconds and the button is not clickable at all before it displays the result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok</span><br></pre></td></tr></table></figure><p>Moreover, the runtime (I’m using Chrome) complaints:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Deprecation] Synchronous XMLHttpRequest on the main thread is deprecated because of its detrimental effects to the end user’s experience. For more help, check https://xhr.spec.whatwg.org/.</span><br></pre></td></tr></table></figure><p>which can be an official statement of the problem.</p><h2 id="Asynchronization-in-action"><a href="#Asynchronization-in-action" class="headerlink" title="Asynchronization in action"></a>Asynchronization in action</h2><p>Broadly speaking, asychronization can be 1) (slow) operations that are performed from another thread; or 2) events that are triggered from external; or the composite of both. I am introducing three examples to demonstrate asychronization in code:</p><h3 id="The-first-one-a-packet-arrival"><a href="#The-first-one-a-packet-arrival" class="headerlink" title="The first one, a packet arrival"></a>The first one, a packet arrival</h3><p>The code used by this example also can solve the problem discussed in the previous section:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button type="button"&gt;Click Me!&lt;/</span>button&gt; </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">--  xmlHttp.open( <span class="string">"GET"</span>, <span class="string">"http://192.241.212.230:5000/lazysvr"</span>, <span class="literal">false</span> );</span><br><span class="line">++  xmlHttp.open( <span class="string">"GET"</span>, <span class="string">"http://192.241.212.230:5000/lazysvr"</span>, <span class="literal">true</span> ); <span class="comment">// 1) change the param to "true" for asynchronous request</span></span><br><span class="line"></span><br><span class="line">++  xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 2) add the callback</span></span><br><span class="line">++    <span class="keyword">if</span>(xmlHttp.readyState == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>) &#123;</span><br><span class="line">++      alert(xmlHttp.responseText);</span><br><span class="line">++    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xmlHttp.send(); </span><br><span class="line">--  alert(xmlHttp.responseText);</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>In this example, we 1) change the second parameter to “true” so as to offload the slow network interaction to another thread, and 2) register a callback as an event handler for the response packet. The callback will be effectively triggered from the other thread when the network interaction completes.</p><p>This time, the button can respond to a user’s click throughout the process and</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok</span><br></pre></td></tr></table></figure><p>is displayed after the send as expected.</p><h3 id="The-second-a-clock-tick"><a href="#The-second-a-clock-tick" class="headerlink" title="The second, a clock tick"></a>The second, a clock tick</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(callback, <span class="number">3000</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'event triggered'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>N.b., 1, JavaScript does not allow synchronous sleep() from beginning.<br>N.b., 2, unlike OS kernel, the clock tick here will never trigger a process (thread) scheduling. As mentioned before, all the JavaScript code is running in one thread.</p><h3 id="And-the-third-a-mouse-click"><a href="#And-the-third-a-mouse-click" class="headerlink" title="And the third, a mouse click"></a>And the third, a mouse click</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button type="button" onclick="callback()"&gt;Click Me!&lt;/</span>button&gt; </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">'event triggered'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>In all the three examples, we register handlers (a.k.a., callbacks) for certain events occurred outside of the main thread. In the first example, we also offload a slow operation to an external thread to fight the blocking problem. As mentioned, all operations can be abstracted in one word, asynchronization!</p><h1 id="The-new-fetch-API"><a href="#The-new-fetch-API" class="headerlink" title="The new fetch() API"></a>The new fetch() API</h1><p>In the first example, packet arrival, I use a callback to make the operation more obvious as asynchronized. A better practice of sending network request is to use the newer API — fetch(). The function returns a Promise that can call then() in turn, so that</p><ol><li>the asynchronized operation can be coded in a synchronized manner (thus less obvious), and</li><li>the so dubbed “callback hell” can be effectively avoided, and the best part</li><li>all the potential exceptions involved in multiple asynchronized calls can be handled in one place:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button type="button" onclick="callback()"&gt;Click Me!&lt;/</span>button&gt; </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    fetch(<span class="string">"http://192.241.212.230:5000/lazysvr"</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> response.text();</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123; </span><br><span class="line">      alert(text);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'error: '</span> + error.message);</span><br><span class="line">    &#125;);</span><br><span class="line"> &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>The result is the same as the example one, and I leave the button there for you to click.</p><h1 id="Under-the-hood-multi-threaded-event-loop"><a href="#Under-the-hood-multi-threaded-event-loop" class="headerlink" title="Under the hood, multi-threaded + event loop"></a>Under the hood, multi-threaded + event loop</h1><h2 id="Isn’t-JavaScript-single-threaded"><a href="#Isn’t-JavaScript-single-threaded" class="headerlink" title="Isn’t JavaScript single threaded"></a>Isn’t JavaScript single threaded</h2><p>The answer is yes and no. I’ll explain:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xmlHttp.open( <span class="string">"GET"</span>, <span class="string">"http://192.241.212.230:5000/lazysvr"</span>, <span class="literal">true</span> );</span><br><span class="line">  xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xmlHttp.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// end of the callback</span></span><br><span class="line"></span><br><span class="line">  xmlHttp.send( <span class="literal">null</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Assuming the browser’s pid is 666, we can use a simple script (I’m using Mac) to monitor the status of threads belonging to the browser :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while true; do ps -M 666; sleep 1; done</span><br></pre></td></tr></table></figure><p>initial values (I beautified the output a bit by removing the irrelevant columns and rows):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USER     PID ... STIME    UTIME</span><br><span class="line">holmes   666 ... 0:00.42  0:01.47 ...</span><br><span class="line">...</span><br><span class="line">         666     0:00.20  0:00.64</span><br></pre></td></tr></table></figure><p>values when I stop:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">USER     PID ... STIME    UTIME</span><br><span class="line">holmes   666 ... 0:00.50  0:01.88 ...</span><br><span class="line">...</span><br><span class="line">         666     0:00.37  0:01.28</span><br></pre></td></tr></table></figure><p>Besides the main thread, there is another thread that is pretty active during the process, which indicate that one more thread is involved, most likely, by sending the network request and listening to the multiplex socket.</p><p>So JavaScript runs in a single thread indeed. But you take the perspective from the application, it is multi-threaded. Feel free to conduct the same experiment on other JavaScript platforms like Node.js.</p><h2 id="Event-loop-the-coarse-grained-asynchronization"><a href="#Event-loop-the-coarse-grained-asynchronization" class="headerlink" title="Event loop, the coarse-grained asynchronization"></a>Event loop, the coarse-grained asynchronization</h2><p>I hope you still remember that asynchronized exception is triggered in a granularity of CPU instruction in OS level as I mentioned it in the beginning of this article. What about that in JavaScript?</p><p>We look at a frequent example first:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  alert(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(callback, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'event triggered'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We know that the result is:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">event triggered</span><br></pre></td></tr></table></figure><p>To recap, though we register a time event and indicate the callback should be invoked immediately, the runtime still waits for the current “loop” iteration to finish before it executes the callback from an “event queue”.</p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>In this series, I have covered the <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-some-basics/">diversified “equals to” operation and “null” value</a>; as well as the <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-string-and-array/">simplified string, array, object and dictionary</a>, in JavaScript. And I further discussed the object from a low level point of view, prototype in <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-prototype-1/">this</a> and <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-prototype-2/">this</a> post. And I highlighted “this” pitfall throughout the series in three different posts,</p><p><a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-this/">1st time</a></p><p><a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-object-dictionary/">2nd time</a></p><p><a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-prototype-2/">3rd time</a></p><p>which signals its importance.</p><p>Then we come to this one that demystifies the asynchronization operation.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;I still remember the days of debugging CORS problem when I put together some projects using JavaScript (&amp;amp; ajax), “a very particular programming language” in my first impression. Recently I got a great opportunity. The new role uses JS, the browser-side script that is now winning in all sides, as the major language. So I tooke it as a good chance to learn JS more systematically, and this series will be part of the outcome of my study. As the name implies, I will not cover primary level such as “if, else” (condition), “for” (or any kinds of loops), or basic OOP concepts. Instead, I will focus only on differences so you can learn this versatile language like reviewing a pull request, and use it the next day in your next awesome project.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript Tutorial for Programmers" scheme="https://holmeshe.me/categories/JavaScript-Tutorial-for-Programmers/"/>
    
    
      <category term="JavaScript" scheme="https://holmeshe.me/tags/JavaScript/"/>
    
      <category term="async" scheme="https://holmeshe.me/tags/async/"/>
    
      <category term="callback" scheme="https://holmeshe.me/tags/callback/"/>
    
      <category term="promise" scheme="https://holmeshe.me/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Tutorial for Programmers - Prototype(2)</title>
    <link href="https://holmeshe.me/javascript-tutorial-for-experienced-programmer-prototype-2/"/>
    <id>https://holmeshe.me/javascript-tutorial-for-experienced-programmer-prototype-2/</id>
    <published>2017-08-25T10:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I still remember the days of debugging CORS problem when I put together some projects using JavaScript (&amp; ajax), “a very particular programming language” in my first impression. Recently I got a great opportunity. The new role uses JS, the browser-side script that is now winning in all sides, as the major language. So I tooke it as a good chance to learn JS more systematically, and this series will be part of the outcome of my study. As the name implies, I will not cover primary level such as “if, else” (condition), “for” (or any kinds of loops), or basic OOP concepts. Instead, I will focus only on <strong>differences</strong> so you can learn this versatile language like reviewing a pull request, and use it the next day in your next awesome project.</p></blockquote><a id="more"></a><h1 id="Prototype-chain-based-inheritance"><a href="#Prototype-chain-based-inheritance" class="headerlink" title="Prototype chain based inheritance"></a><em>Prototype chain</em> based inheritance</h1><p>Class inheritance can be implemented using a technique called <em>prototype chain</em>. So an object can be traced back to its ancestor(s) using a <code>prototype</code> instance that is embedded (i.e., <code>__proto__</code>) in it, like a gene. For the end purpose of inheritance, i.e., code reusing, <em>prototype chain</em> also enables the accessing of members that only exist in ancestors, hence whenever such a member (method or property) is accessed, the runtime will check upwards the <em>prototype chain</em> that contains members information of the whole inheritance (sub-)tree.</p><h1 id="Simple-but-not-easy"><a href="#Simple-but-not-easy" class="headerlink" title="Simple, but not easy"></a>Simple, but not easy</h1><p>Phew, it’s hard to explain coding concept without code. So next I am going to implement this <em>prototype chain</em> step by step. Moreover, I make it a trial and error process in hope that the read can simulate a real developing experience, and which I hope can be remembered (by you) easier.</p><p>Example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ASuperClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.aproperty = <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">this</span>.amethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'b'</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ASubClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ASubClass.prototype = ASuperClass.prototype; <span class="comment">//let's make the chain</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subobj = <span class="keyword">new</span> ASubClass();</span><br><span class="line"></span><br><span class="line">alert(subobj <span class="keyword">instanceof</span> ASuperClass);</span><br><span class="line">alert(subobj.aproperty);</span><br><span class="line">alert(subobj.amethod());</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p><span style="color:red">Uncaught TypeError: subobj.amethod is not a function</span></p><p>Though the type can be recognized by the runtime, the properties can not be accessed as expected. So I think we need to call the super class constructor to initialize the missing properties. Let’s give it a go.</p><p>Example:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> ASuperClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.aproperty = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">this</span>.amethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'b'</span>;&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> ASubClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">++  ASuperClass();</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  ASubClass.prototype = ASuperClass.prototype;</span><br><span class="line">++SubClass.prototype.constructor = ASubClass;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> subobj = <span class="keyword">new</span> ASubClass();</span><br><span class="line">  alert(subobj <span class="keyword">instanceof</span> ASuperClass);</span><br><span class="line">  alert(subobj.aproperty);</span><br><span class="line">  alert(subobj.amethod());</span><br></pre></td></tr></table></figure></p><p>Unfortunately, the result is the same. Hmmm, this time is the corrupted <code>this</code> in the superclass constructor. If this is not your first reaction, please ⬅ to my <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-this/">previous post</a> that is dedicated to this topic.</p><p>In order to fix <code>this</code>, we can either add:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmpf = ASuperClass.bind(<span class="keyword">this</span>);</span><br><span class="line">tmpf();</span><br></pre></td></tr></table></figure><p>or:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASuperClass.apply(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>, as per discussed in the <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-this/">post</a>. I will use the second method because, well, it’s one line less:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> ASuperClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.aproperty = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">this</span>.amethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'b'</span>;&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> ASubClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">++  ASuperClass.apply(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  ASubClass.prototype = ASuperClass.prototype;</span><br><span class="line">  ASubClass.prototype.constructor = ASubClass;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> subobj = <span class="keyword">new</span> ASubClass();</span><br><span class="line">  alert(subobj <span class="keyword">instanceof</span> ASuperClass);</span><br><span class="line">  alert(subobj.aproperty);</span><br><span class="line">  alert(subobj.amethod());</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>Finally we nailed it! Are we? No:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> ASuperClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.aproperty = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">this</span>.amethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'b'</span>;&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> ASubClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ASuperClass.apply(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  ASubClass.prototype = ASuperClass.prototype;</span><br><span class="line">  ASubClass.prototype.constructor = ASubClass;</span><br><span class="line">  </span><br><span class="line">++ASubClass.prototype.another_property = <span class="string">'c'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> subobj = <span class="keyword">new</span> ASubClass();</span><br><span class="line">++<span class="keyword">var</span> superobj = <span class="keyword">new</span> ASuperClass();</span><br><span class="line">++alert(subobj.another_property);</span><br><span class="line">++alert(superobj.another_property);</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>In fact, we just made something else but inheritance, which does not exist in real world. I tentatively call it <em>coupling</em>. Though we made a wrong decision from the very first step, still the other effort we made can be largely reused. I’ve heard versions of stories about one guy, who failed a kickstart project, one day realized the pain eventually paid off in some other way. This is just like that. So let’s keep up.</p><h1 id="Prototype-DEcoupling"><a href="#Prototype-DEcoupling" class="headerlink" title="Prototype DEcoupling"></a>Prototype DEcoupling</h1><p>In common (and correct) practice, <em>prototype chain</em> is established using <strong>two</strong> entities, an <strong>intermediate class</strong> (which is also an object, first class) and an <strong>intermediate object</strong> (,normal) in order to decouple the “thing” we made just now, and the designated object relation is given below:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Subclass.prototype</span><br><span class="line">           |---intermediate object</span><br><span class="line">                |---.__proto__ </span><br><span class="line">                      |---IntermediateClass.prototype === Superclass.prototype</span><br></pre></td></tr></table></figure><p>in which, the <strong>intermediate object</strong> is an instance of the <strong>intermediate class</strong>.</p><p>Let’s get back to the snippet I showed in the beginning of my <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-prototype-1/">last post</a>: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">ChildClass, ParentClass</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">IntermediateClass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  IntermediateClass.prototype = ParentClass.prototype;</span><br><span class="line">  ChildClass.prototype = <span class="keyword">new</span> IntermediateClass;</span><br><span class="line">  ChildClass.prototype.constructor = ChildClass;</span><br><span class="line">  <span class="keyword">return</span> ChildClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>I hope the above text has made the above function clear now. Then let’s verify the function in code:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> ASuperClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.aproperty = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">this</span>.amethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'b'</span>;&#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> ASubClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ASuperClass.apply(<span class="keyword">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">--ASubClass.prototype = ASuperClass.prototype;</span><br><span class="line">++inherits(ASubClass, ASuperClass);</span><br><span class="line">  </span><br><span class="line">  ASubClass.prototype.another_property = <span class="string">'c'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> subobj = <span class="keyword">new</span> ASubClass();</span><br><span class="line">  <span class="keyword">var</span> superobj = <span class="keyword">new</span> ASuperClass();</span><br><span class="line">  </span><br><span class="line">  alert(subobj <span class="keyword">instanceof</span> ASuperClass);</span><br><span class="line">  alert(subobj <span class="keyword">instanceof</span> ASubClass);</span><br><span class="line">  alert(subobj.aproperty);</span><br><span class="line">  alert(subobj.amethod());</span><br><span class="line">  alert(subobj.another_property);</span><br><span class="line">  </span><br><span class="line">  alert(superobj <span class="keyword">instanceof</span> ASuperClass);</span><br><span class="line">  alert(superobj <span class="keyword">instanceof</span> ASubClass);</span><br><span class="line">  alert(superobj.aproperty);</span><br><span class="line">  alert(superobj.amethod());</span><br><span class="line">  alert(superobj.another_property);</span><br></pre></td></tr></table></figure><p>A better version of the <code>inherits()</code> can be implemented using <code>Object.create()</code> that can simplify the creation of the intermediate entities.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">ChildClass, ParentClass</span>) </span>&#123;</span><br><span class="line">--  <span class="function"><span class="keyword">function</span> <span class="title">IntermediateClass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">--  IntermediateClass.prototype = ParentClass.prototype;</span><br><span class="line">--  ChildClass.prototype = <span class="keyword">new</span> IntermediateClass;</span><br><span class="line">++  ChildClass.prototype = <span class="built_in">Object</span>.create(ParentClass.prototype);</span><br><span class="line">    ChildClass.prototype.constructor = ChildClass;</span><br><span class="line">    <span class="keyword">return</span> ChildClass;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>To be honest, I am feeling a bit exciting when checking the result:)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"><span class="comment">// this line is artificial</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>Allllll good!</p><p>Wait, there is one last piece, what is a</p><h1 id="prototype-constructor"><a href="#prototype-constructor" class="headerlink" title="prototype.constructor"></a>prototype.constructor</h1><p>You may have noticed, I stealthily added the constructor related code from <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-prototype-2/#Simple-but-not-easy">here</a> and omit the explanation. I did it on purpose in order to make the logic flow smooth. Now let’s scrutinize it:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class &lt;----------------|</span><br><span class="line">  |------.prototype.constructor</span><br><span class="line">              |------......(I have drawn this)</span><br></pre></td></tr></table></figure><p>prototype.constructor is a special method referring to the class itself. Normally the link is made by the runtime,</p><p>Example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ASuperClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.aproperty = <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">this</span>.amethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="string">'b'</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(ASuperClass.prototype.constructor === ASuperClass);</span><br></pre></td></tr></table></figure><p>Result:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure></p><p>However, the original <code>ChildClass.prototype.constructor</code> is broken when we chained up the <code>prototype</code>s in</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">ChildClass, ParentClass</span>)</span></span><br></pre></td></tr></table></figure><p>So we need to assign it back to <code>ChildClass</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChildClass.prototype.constructor = ChildClass;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;I still remember the days of debugging CORS problem when I put together some projects using JavaScript (&amp;amp; ajax), “a very particular programming language” in my first impression. Recently I got a great opportunity. The new role uses JS, the browser-side script that is now winning in all sides, as the major language. So I tooke it as a good chance to learn JS more systematically, and this series will be part of the outcome of my study. As the name implies, I will not cover primary level such as “if, else” (condition), “for” (or any kinds of loops), or basic OOP concepts. Instead, I will focus only on &lt;strong&gt;differences&lt;/strong&gt; so you can learn this versatile language like reviewing a pull request, and use it the next day in your next awesome project.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript Tutorial for Programmers" scheme="https://holmeshe.me/categories/JavaScript-Tutorial-for-Programmers/"/>
    
    
      <category term="JavaScript" scheme="https://holmeshe.me/tags/JavaScript/"/>
    
      <category term="prototype" scheme="https://holmeshe.me/tags/prototype/"/>
    
      <category term="inheritance" scheme="https://holmeshe.me/tags/inheritance/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Tutorial for Programmers - Prototype(1)</title>
    <link href="https://holmeshe.me/javascript-tutorial-for-experienced-programmer-prototype-1/"/>
    <id>https://holmeshe.me/javascript-tutorial-for-experienced-programmer-prototype-1/</id>
    <published>2017-08-21T09:30:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>I still remember the days of debugging CORS problem when I put together some projects using JavaScript (&amp; ajax), “a very particular programming language” in my first impression. Recently I got a great opportunity. The new role uses JS, the browser-side script that is now winning in all sides, as the major language. So I tooke it as a good chance to learn JS more systematically, and this series will be part of the outcome of my study. As the name implies, I will not cover primary level such as “if, else” (condition), “for” (or any kinds of loops), or basic OOP concepts. Instead, I will focus only on <strong>differences</strong> so you can learn this versatile language like reviewing a pull request, and use it the next day in your next awesome project.</p></blockquote><a id="more"></a><h1 id="prototype-a-semi-OOP-semantic"><a href="#prototype-a-semi-OOP-semantic" class="headerlink" title="prototype, a semi-OOP semantic"></a><code>prototype</code>, a semi-OOP semantic</h1><p>A <code>prototype</code> is a singleton that is created for each <em>class</em> (by JS runtime), so that instances of the <em>class</em> can be constructed based on the in memory template. I call <code>prototype</code> semi-OOP because it is not normal. For instance, this is how a <code>prototype</code> based inheritance is programmed:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">ChildClass, ParentClass</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">IntermediateClass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  IntermediateClass.prototype = ParentClass.prototype;</span><br><span class="line">  ChildClass.prototype = <span class="keyword">new</span> IntermediateClass;</span><br><span class="line">  ChildClass.prototype.constructor = ChildClass;</span><br><span class="line">  <span class="keyword">return</span> ChildClass;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>I will cover <code>prototype</code> based inheritance in the <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-prototype-2/">next post</a>. For now, we just grasp the idea of how things are different here.</p><h2 id="Practical-implication"><a href="#Practical-implication" class="headerlink" title="Practical implication"></a>Practical implication</h2><p>As per discussed in the <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-object-dictionary/">last post</a>, ES6 has already defined a more standard OOP paradigm in JavaScript. And ES6 code can be <a href="https://babeljs.io/" target="_blank" rel="noopener">“transpiled”</a> (compile into another language or syntax) into ES5 so the two standards are equally compatible with various browsers in practice. Does that mean <code>prototype</code> is not useful anymore? My answer is No, because it still largely exists in a large amount of existing code. For concrete numbers, if <code>grep -R prototype *|wc -l</code>, at the point of time when I am writing, in <a href="https://github.com/angular/angular" target="_blank" rel="noopener">Angular</a>, the output shows there are 286 lines; in <a href="https://github.com/facebook/react" target="_blank" rel="noopener">React</a>, there are 405; and <a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue</a>, 756). As for me, I need to know <code>prototype</code> to understand these 1447 lines of backbones. Last but not least, the frameworks are ordered alphabetically 😅.</p><h1 id="Playaround-with-prototype"><a href="#Playaround-with-prototype" class="headerlink" title="Playaround with prototype"></a>Playaround with <code>prototype</code></h1><p>In the following example, we first define a <em>constructor</em> (If you do not know what is a <em>constructor</em> in JS context, please ⬅ to my <a href="http://holmeshe.me/javascript-tutorial-for-experienced-programmer-object-dictionary/">last post</a>). Then we use it to create an object and examine the <em>prototype</em>(s).</p><p>Example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass;</span><br><span class="line">alert(obj.__proto__ == MyClass.prototype); <span class="comment">//=true</span></span><br><span class="line">alert(obj.prototype == MyClass.prototype); <span class="comment">//=&gt;false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if the object's prototype does not equal to the class' prototype, what is it then</span></span><br><span class="line">alert(obj.prototype); <span class="comment">//=&gt;undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can change the definition of a class on the run</span></span><br><span class="line">MyClass.prototype.a_member = <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// and the object's structure is changed as well</span></span><br><span class="line">alert(obj.a_member); <span class="comment">//=&gt;abc</span></span><br><span class="line">alert(obj.__proto__.a_member); <span class="comment">//=&gt;abc</span></span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">abc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>An initial observation:</p><ol><li><code>prototype</code> only exists in a <em>class</em> (a.k.a., a constructor). If you need to access <code>prototype</code> from a <code>class instance</code> (a.k.a., an object), <code>__proto__</code> is the way to go.</li><li><code>prototype</code> and <code>__proto__</code> are just two sides of one coin. In technical words, they refer to the same instance, i.e., <a href="#prototype-a-semi-OOP">the singleton mentioned in the beginning of this text</a>.</li><li>the <em>prototype</em> of a <em>class</em> can be changed at runtime, and all the <em>instances</em> of this <em>class</em> are affected accordingly.</li></ol><p>Moreover, a modification of <code>__proto__</code> of an instance can change the <code>prototype</code> (definition) of a <em>class</em>, and all the sibling <em>instance</em>s are affected in a cascade manner. </p><p>Example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> MyClass;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> MyClass;</span><br><span class="line"></span><br><span class="line">obj1.__proto__.a_member = <span class="string">'abc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// an instance can change the definition of the class</span></span><br><span class="line">alert(MyClass.prototype.a_member); <span class="comment">//Ooooops...</span></span><br><span class="line"><span class="comment">// so all other instances are affected</span></span><br><span class="line">alert(obj2.a_member);</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p>This operation is dangerous. It will cause side-effect and confusion in a project with reasonable complexity as the definition of a class can not be easily traceable. Hence I highly recommend considering <code>__proto__</code> <em>final</em> (in Java) or <em>constant</em> (in C++) and should be never touched.</p><p>If you really want to modify the behavior of an object, say, add a property, at least modify the object itself rather than <code>__proto__</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> MyClass;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> MyClass;</span><br><span class="line"></span><br><span class="line">obj1.a_member = <span class="string">'abc'</span>; <span class="comment">// change the object behavior at run time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// no effect</span></span><br><span class="line">alert(MyClass.prototype.a_member);</span><br><span class="line"></span><br><span class="line"><span class="comment">// no effect</span></span><br><span class="line">alert(obj2.a_member);</span><br></pre></td></tr></table></figure><p>Result:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></p><p>On the other hand, adding a property to a class effectively creates a static member (in other language term).</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> MyClass;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.a_member = <span class="string">'abc'</span>; <span class="comment">// change the class behavior</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// no effect</span></span><br><span class="line">alert(MyClass.prototype.a_member);</span><br><span class="line"></span><br><span class="line"><span class="comment">// no effect</span></span><br><span class="line">alert(obj1.a_member);</span><br><span class="line">alert(obj2.a_member);</span><br><span class="line"></span><br><span class="line"><span class="comment">// the member has been effectively added</span></span><br><span class="line">alert(MyClass.a_member);</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br><span class="line">undefined</span><br><span class="line">undefined</span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p><strong>I would recommend this usage</strong>.</p><p>So the bright side of this feature is flexibility, empowered by that</p><h1 id="Everything-is-object"><a href="#Everything-is-object" class="headerlink" title="Everything is object"></a>Everything is <em>object</em></h1><p>Everything in JavaScript is <em>object</em>. That includes, <em>function</em>s, <em>constructor</em>s (<em>class</em>)es, <em>instance</em>s, <code>prototype</code>s and <code>__proto__</code>s, etc. Let’s prove it in code.</p><p>Example:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="string">"a"</span>;</span><br><span class="line">  <span class="keyword">this</span>.b = <span class="string">"b"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arry = [];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"something"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(MyClass <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(MyClass.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(MyClass.__proto__ <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(obj.__proto__ <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(arry <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(f1.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(f1.__proto__ <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure></p><p>Result:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true(chorus)</span><br></pre></td></tr></table></figure></p><p>Furthermore, <em>Object</em> is subdivided into two categories, <em>first class objects</em> and all other <em>normal objects</em>. <em>Normal object</em>s are just variables, which can be created, modified, assigned to other variables, and passed as arguments (or return value), all in runtime. Whilst <em>first class object</em> is the “platinum version” of <em>object</em> that unlocks extra privileges. Besides the operations listed above, <em>first class object</em> can be invoked (as a normal function); and it can be invoked to create normal <em>object</em>s (as a constructor). I think those extra privileges can explain from another perspective why <em>first class object</em> is attached one extra member property <code>prototype</code> alongside <code>__proto__</code>.</p><p>More examples:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="string">"a"</span>;</span><br><span class="line">  <span class="keyword">this</span>.b = <span class="string">"b"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> MyClass;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"something"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass is a first class object so...</span></span><br><span class="line">alert(MyClass.prototype); <span class="comment">// it has prototype and</span></span><br><span class="line">alert(MyClass.__proto__); <span class="comment">// __proto__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj is an object so...</span></span><br><span class="line">alert(obj.prototype); <span class="comment">// it does not have prototype but</span></span><br><span class="line">alert(obj.__proto__); <span class="comment">// it has __proto__</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// f1 is a first class object so...</span></span><br><span class="line">alert(f1.prototype); <span class="comment">// it has prototype and</span></span><br><span class="line">alert(f1.__proto__); <span class="comment">// __proto__</span></span><br></pre></td></tr></table></figure></p><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[object Object]</span><br><span class="line">function () &#123;&#125;</span><br><span class="line">undefined</span><br><span class="line">[object Object]</span><br><span class="line">[object Object]</span><br><span class="line">function () &#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="Except-for…"><a href="#Except-for…" class="headerlink" title="Except for…"></a>Except for…</h1><h2 id="Exception-1-primitive-types"><a href="#Exception-1-primitive-types" class="headerlink" title="Exception 1, primitive types"></a>Exception 1, primitive types</h2><p>Did I just said everything is object?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"whatever"</span>;</span><br><span class="line">alert(str <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(str.__proto__ <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>Even though a string literal is not an object, it contains <code>__proto__</code> that is an object?! So either string literal is an object, which is obviously not, or what I said in the last section is just bullshit.</p><p>It is not. What happens here is that a mechanism called <strong>automatic wrapping</strong> kicks in, which wraps the no-object (primitive) variables to its object counterpart , in this case, a String(), as required. <strong>Automatic wrapping</strong> can enable calling methods directly from primitives as well:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"whatever"</span>;</span><br><span class="line">alert(str.indexOf(<span class="string">"tever"</span>));</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>Same phenomenon happens: the runtime wrap the literal to <code>String()</code> automatically and calls the <code>indexOf()</code> method. And the rule applies to other primitive types (int, float) as well.</p><h2 id="Exception-2"><a href="#Exception-2" class="headerlink" title="Exception 2, ???"></a>Exception 2, ???</h2><p>All sounds perfect until I tried this</p><p>Example:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"> a:<span class="string">"abc"</span>,</span><br><span class="line"> b:<span class="string">"bcd"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line">alert(obj.__proto__);</span><br><span class="line">alert(obj.__proto__ <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">[object Object]</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>Apparently <code>var obj</code> and <code>obj.__proto__</code> are <em>objects</em> according to the first two outputs. However, when I want to confirm if <code>obj.__proto__</code> is really an object, runtime gives me a <code>false</code>. I hope I am not the first bloger who writes about things he is not sure himself, but if you have an answer, please let me know in the comments. It does not matter if you don’t, as <code>__proto__</code> is no-standard usage anyway.</p><p>In the next post, I will discuss one of the hardest parts of JavaScript, inheritance based on <em>prototype chain</em>.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;I still remember the days of debugging CORS problem when I put together some projects using JavaScript (&amp;amp; ajax), “a very particular programming language” in my first impression. Recently I got a great opportunity. The new role uses JS, the browser-side script that is now winning in all sides, as the major language. So I tooke it as a good chance to learn JS more systematically, and this series will be part of the outcome of my study. As the name implies, I will not cover primary level such as “if, else” (condition), “for” (or any kinds of loops), or basic OOP concepts. Instead, I will focus only on &lt;strong&gt;differences&lt;/strong&gt; so you can learn this versatile language like reviewing a pull request, and use it the next day in your next awesome project.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript Tutorial for Programmers" scheme="https://holmeshe.me/categories/JavaScript-Tutorial-for-Programmers/"/>
    
    
      <category term="JavaScript" scheme="https://holmeshe.me/tags/JavaScript/"/>
    
      <category term="js" scheme="https://holmeshe.me/tags/js/"/>
    
      <category term="prototype" scheme="https://holmeshe.me/tags/prototype/"/>
    
  </entry>
  
</feed>
