<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Holmes He</title>

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="memcachedcacheLRU">
  
  
  
  
  <meta name="description" content="In previous posts, we have discussed different facets of an item, i.e., slab, hash map and LRU list as well as their associated (CRUD) methods, which build up the internal procedures and perform clien">
<meta name="keywords" content="memcached,cache,LRU">
<meta property="og:type" content="article">
<meta property="og:title" content="Understanding The Memcached Source Code - LRU III">
<meta property="og:url" content="https://holmeshe.me/understanding-memcached-source-code-VI/index.html">
<meta property="og:site_name" content="Holmes He">
<meta property="og:description" content="In previous posts, we have discussed different facets of an item, i.e., slab, hash map and LRU list as well as their associated (CRUD) methods, which build up the internal procedures and perform clien">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://holmeshe.me/gallery/spade.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/heart.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/club.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/diamond.svg">
<meta property="og:updated_time" content="2020-12-28T04:26:05.638Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Understanding The Memcached Source Code - LRU III">
<meta name="twitter:description" content="In previous posts, we have discussed different facets of an item, i.e., slab, hash map and LRU list as well as their associated (CRUD) methods, which build up the internal procedures and perform clien">
<meta name="twitter:image" content="https://holmeshe.me/gallery/spade.svg">
  
  <link rel="icon" href="/gallery/air-balloon.svg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   
>
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Code Talks" src=" /gallery/air-balloon.svg">
              </a>
            
          </h1>
          
          <div class="site-description">
            \{C}0de<t>a1k(s) =>
            <text id="message">
              
            </text>
            ( ͡° ͜ʖ ͡°)
            <a class='ext-link' href="/atom.xml">
              <i class="fas fa-rss fa-lg"></i>
            </a>
          </div>
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Series</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-understanding-memcached-source-code-VI" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Understanding The Memcached Source Code - LRU III
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/understanding-memcached-source-code-VI/" class="article-date">
	  <time datetime="2018-12-23T22:00:00.000Z" itemprop="datePublished">December 24, 2018</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Memcached-Source-Code/">Memcached Source Code</a>
 
      
    </div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p>
<p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I, </text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;"> II, </text></a> <a href="#"><text style="color:black;font-weight:bold;"> III - this article)</text></a> for entry expiration; and an</p>
<p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p>
<p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent hashing (not complete)</text></a> for data distribution,</p>
<p>are built around it.</p>
<p>In previous posts, we have discussed different facets of an <strong>item</strong>, i.e., <strong>slab</strong>, <strong>hash map</strong> and <strong>LRU list</strong> as well as their associated (CRUD) methods, which build up the internal procedures and perform client requests after the corresponding commands are parsed by the <strong>drive machine</strong>. This time we will go through those procedures by issuing <em>telnet commands</em> to a <strong>Memcached</strong> instance and see how the discussed modules work together on various <strong>item</strong> operations. We will also see the whole picture of <strong>LRU list</strong>s that maintain the property of ‘least recently used’ in accordance to those operations.</p>
<a id="more"></a>
<p>On top of standard <strong>LRU</strong> algorithm, the <strong>Memcached</strong> (1.4.28) emploies <code>3</code> lists instead of just <code>1</code>, i.e., hot, warm and cold, a.k.a., <a href="https://memcached.org/blog/modern-lru/" target="_blank" rel="noopener">Segmented LRU</a> for each <strong>slab class</strong>. This heuristic is implemented to reduce the lock contention between <strong>item</strong> <em>bumping</em> (an <a href="/understanding-memcached-source-code-IV/#Linked-list">action</a> that moves recently accessed <strong>item</strong> to the list head) and <strong>item</strong> read. Moreover, unlike a casual implementation (such as the one I coded), <strong>Memcached</strong> does not <em>bump</em> <strong>item</strong> right on <a href="#opt1">read action</a>. Rather, the <em>bumping</em> is delayed to <a href="#opt2">other operations when the resource is in short</a>, which could reflect <strong>Memcached</strong>‘s read-first design decision.</p>
<blockquote>
<p>In normal use cases, let’s say, a social media, the volume of read requests are more than that of other operations combined by orders of magnitude, hence it’s a critical point that worth extensive optimizations, I suppose.</p>
</blockquote>
<p>We start this post by issuing an <strong>item</strong> read command to a <strong>Memcached</strong> instance.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~telnet localhost 11211</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">...// add some items</span><br><span class="line">&gt; get test</span><br></pre></td></tr></table></figure>
<h1 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h1><p>The the normal execution of this procedure,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line">1 |~Drive machine &amp; command parser</span><br><span class="line">    |-process_get_command</span><br><span class="line">++    |-item_get</span><br><span class="line">        |-assoc_find    (LRU II)</span><br><span class="line">      |-item_update</span><br><span class="line">        |-item_unlink_q (LRU I)</span><br><span class="line">        |-item_link_q   (LRU I)</span><br></pre></td></tr></table></figure>
<h2 id="process-get-command"><a href="#process-get-command" class="headerlink" title="process_get_command"></a>process_get_command</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">process_get_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">size_t</span> ntokens, <span class="keyword">bool</span> return_cas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">token_t</span> *key_token = &amp;tokens[KEY_TOKEN];</span><br><span class="line">    <span class="keyword">char</span> *suffix;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(key_token-&gt;length != <span class="number">0</span>) &#123; <span class="comment">// scr: -----------------&gt; *)</span></span><br><span class="line"></span><br><span class="line">            key = key_token-&gt;value;</span><br><span class="line">            nkey = key_token-&gt;length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nkey &gt; KEY_MAX_LENGTH) &#123;</span><br><span class="line">                out_string(c, <span class="string">"CLIENT_ERROR bad command line format"</span>);</span><br><span class="line">                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    item_remove(*(c-&gt;ilist + i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it = item_get(key, nkey, c); <span class="comment">// scr: ----------------&gt; 1)</span></span><br><span class="line">            <span class="keyword">if</span> (settings.detail_enabled) &#123;</span><br><span class="line">                stats_prefix_record_get(key, nkey, <span class="literal">NULL</span> != it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= c-&gt;isize) &#123; <span class="comment">// scr: --------------------&gt; *)</span></span><br><span class="line">                    item **new_list = <span class="built_in">realloc</span>(c-&gt;ilist, <span class="keyword">sizeof</span>(item *) * c-&gt;isize * <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">if</span> (new_list) &#123;</span><br><span class="line">                        c-&gt;isize *= <span class="number">2</span>;</span><br><span class="line">                        c-&gt;ilist = new_list;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">                        item_remove(it);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (return_cas)</span><br><span class="line">                &#123;</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  MEMCACHED_COMMAND_GET(c-&gt;sfd, ITEM_key(it), it-&gt;nkey,</span><br><span class="line">                                        it-&gt;nbytes, ITEM_get_cas(it));</span><br><span class="line">                  <span class="keyword">if</span> (add_iov(c, <span class="string">"VALUE "</span>, <span class="number">6</span>) != <span class="number">0</span> || <span class="comment">// scr: ---&gt; *)</span></span><br><span class="line">                      add_iov(c, ITEM_key(it), it-&gt;nkey) != <span class="number">0</span> ||</span><br><span class="line">                      add_iov(c, ITEM_suffix(it), it-&gt;nsuffix + it-&gt;nbytes) != <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          item_remove(it);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: verbose &amp; stat</span></span><br><span class="line"></span><br><span class="line">                item_update(it); <span class="comment">// scr: ------------------------&gt; 2)</span></span><br><span class="line">                *(c-&gt;ilist + i) = it;</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key_token++; <span class="comment">// scr: --------------------------------&gt; *)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the command string hasn't been fully processed, get the next set</span></span><br><span class="line"><span class="comment">         * of tokens.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(key_token-&gt;value != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: ------------------&gt; *)</span></span><br><span class="line">            ntokens = tokenize_command(key_token-&gt;value, tokens, MAX_TOKENS);</span><br><span class="line">            key_token = tokens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(key_token-&gt;value != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    c-&gt;icurr = c-&gt;ilist;</span><br><span class="line">    c-&gt;ileft = i;</span><br><span class="line">... <span class="comment">// scr: cas &amp; verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key_token-&gt;value != <span class="literal">NULL</span> || add_iov(c, <span class="string">"END\r\n"</span>, <span class="number">5</span>) != <span class="number">0</span></span><br><span class="line">        || (IS_UDP(c-&gt;transport) &amp;&amp; build_udp_headers(c) != <span class="number">0</span>)) &#123;</span><br><span class="line">        out_of_memory(c, <span class="string">"SERVER_ERROR out of memory writing get response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// scr: ----------------------------------------------&gt; *)</span></span><br><span class="line">        conn_set_state(c, conn_mwrite);</span><br><span class="line">        c-&gt;msgcurr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_get_command@memcached.c</text></center>
<p>The only relevant step here are 1) <code>item_get</code> and 2) <code>item_update</code>. Steps marked as *) are mostly command parsing and I/O which will be discussed in later posts when we examine <strong>event driven</strong> mechanism.</p>
<h2 id="do-item-get"><a href="#do-item-get" class="headerlink" title="do_item_get"></a>do_item_get</h2><p>Like other methods discussed before, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_get">item_get</a> is a thread-safe wrapper of <code>do_item_get</code>.</p>
<div id="item_get" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">item_get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, conn *c)</span> </span>&#123;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(key, nkey);</span><br><span class="line">    item_lock(hv);</span><br><span class="line">    it = do_item_get(key, nkey, hv, c);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_get@thread.c</text></center><br></div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">do_item_get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv, conn *c)</span> </span>&#123;</span><br><span class="line">    item *it = assoc_find(key, nkey, hv); <span class="comment">// scr: -----------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        refcount_incr(&amp;it-&gt;refcount); <span class="comment">// scr: ---------------------&gt; 2)</span></span><br><span class="line">...<span class="comment">// scr: comments</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> was_found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        was_found = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (item_is_flushed(it)) &#123;</span><br><span class="line">...<span class="comment">// scr: item flush</span></span><br><span class="line"><span class="comment">// scr: -----------------------------------------------------------&gt; 3)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;exptime != <span class="number">0</span> &amp;&amp; it-&gt;exptime &lt;= current_time) &#123;</span><br><span class="line">            do_item_unlink(it, hv);</span><br><span class="line">            do_item_remove(it);</span><br><span class="line">            it = <span class="literal">NULL</span>;</span><br><span class="line">...<span class="comment">// scr: stat &amp; verbose</span></span><br><span class="line">            was_found = <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ------------------------------------------&gt; 4)</span></span><br><span class="line">            it-&gt;it_flags |= ITEM_FETCHED|ITEM_ACTIVE;</span><br><span class="line">            DEBUG_REFCNT(it, <span class="string">'+'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_get@items.c</text></center>
<p>1) Use the discussed <a href="/understanding-memcached-source-code-V/#assoc-find">assoc_find</a> to locate the <strong>item</strong> using the <em>hash key</em>.</p>
<p>2) Increase the discussed <a href="/understanding-memcached-source-code-IV/#do-item-link">reference count</a>.</p>
<p>3) If the <strong>item</strong> has expired, remove it. Note that <code>do_item_unlink</code> decreases the reference count held by the last step, and <code>do_item_remove</code> actually removes the <strong>item</strong>. These two methods will be discussed soon in <a href="#Delete">item delete</a>.</p>
<a href="#" id="opt1" style="visibility: hidden"></a>
<p>4) Simply mark the <strong>item</strong> as <code>ITEM_ACTIVE</code> rather than perform <strong>item</strong> <em>bumping</em> which is offloaded to other operations associated procedures. This is part of the heuristic discussed in the beginning.</p>
<h2 id="do-item-update"><a href="#do-item-update" class="headerlink" title="do_item_update"></a>do_item_update</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_update">item_update</a> is a thread-safe wrapper of <code>do_item_update</code>.<br><br><div id="item_update" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_update</span><span class="params">(item *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(ITEM_key(item), item-&gt;nkey);</span><br><span class="line"></span><br><span class="line">    item_lock(hv);</span><br><span class="line">    do_item_update(item);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_update@thread.c</text></center>
<p></p></div><p></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_update</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it-&gt;nkey, it-&gt;nbytes);</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;time &lt; current_time - ITEM_UPDATE_INTERVAL) &#123;</span><br><span class="line">        assert((it-&gt;it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">            it-&gt;time = current_time; <span class="comment">// scr: ----------------------&gt; 1)</span></span><br><span class="line">            <span class="keyword">if</span> (!settings.lru_maintainer_thread) &#123;</span><br><span class="line">                item_unlink_q(it);</span><br><span class="line">                item_link_q(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_update@items.c</text></center>
<p>1) The only line effective in this method is to set the access time for the <strong>item</strong> in (passively) an <a href="#" onclick="return false;" data-toggle="collapse" data-target="#interval">interval</a> of 60 seconds. <a href="#" onclick="return false;" data-toggle="collapse" data-target="#lru_maintainer_thread">lru_maintainer_thread</a> is set to <code>true</code> by command line argument <code>modern</code> so the operations inside <code>if (!settings.lru_maintainer_thread)</code> is not applicable.</p>
<div id="interval" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_UPDATE_INTERVAL 60</span></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.h:73</text></center><br></div>

<div id="lru_maintainer_thread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MODERN:</span><br><span class="line">...</span><br><span class="line">    start_lru_maintainer = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5828</text></center><br></div>

<p>Next, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; delete test</span><br></pre></td></tr></table></figure>
<h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>Call stack in normal execution,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line">1 |~Drive machine &amp; command parser</span><br><span class="line">    |-process_delete_command</span><br><span class="line">++    |-do_item_get</span><br><span class="line">      |-do_item_unlink</span><br><span class="line">        |-assoc_delete    (LRU II)</span><br><span class="line">        |-item_unlink_q   (LRU I)</span><br><span class="line">--      |-do_item_remove</span><br><span class="line">--    |-do_item_remove</span><br><span class="line">        |-do_item_free</span><br><span class="line">          |-do_slabs_free (Slab II)</span><br></pre></td></tr></table></figure>
<h2 id="process-delete-command"><a href="#process-delete-command" class="headerlink" title="process_delete_command"></a>process_delete_command</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_delete_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">const</span> <span class="keyword">size_t</span> ntokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    item *it;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    key = tokens[KEY_TOKEN].value;</span><br><span class="line">    nkey = tokens[KEY_TOKEN].length;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: sanity check &amp; stat</span></span><br><span class="line"></span><br><span class="line">    it = item_get(key, nkey, c); <span class="comment">// scr: -------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">if</span> (it) &#123;</span><br><span class="line">        MEMCACHED_COMMAND_DELETE(c-&gt;sfd, ITEM_key(it), it-&gt;nkey);</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">        item_unlink(it); <span class="comment">// scr: ---------------------------------&gt; 2)</span></span><br><span class="line">        item_remove(it);      <span class="comment">/* release our reference */</span></span><br><span class="line">        out_string(c, <span class="string">"DELETED"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">        out_string(c, <span class="string">"NOT_FOUND"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_delete_command@memcached.c</text></center>
<p>1) Get the <strong>item</strong> using <code>item_get</code> discussed in last section. Note that the reference count is increased in <code>item_get</code>.</p>
<p>2) Delete it.</p>
<h2 id="do-item-unlink"><a href="#do-item-unlink" class="headerlink" title="do_item_unlink"></a>do_item_unlink</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_unlink">item_unlink</a> is a thread safe wrapper of <code>do_item_unlink</code>.<br><br><div id="item_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_unlink</span><span class="params">(item *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(ITEM_key(item), item-&gt;nkey);</span><br><span class="line">    item_lock(hv);</span><br><span class="line">    do_item_unlink(item, hv);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_unlink@thread.c</text></center>
<p></p></div><p></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_unlink</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_LINKED;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">        assoc_delete(ITEM_key(it), it-&gt;nkey, hv); <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">        item_unlink_q(it); <span class="comment">// scr: -------------------------------&gt; 2)</span></span><br><span class="line">        do_item_remove(it); <span class="comment">// scr: ------------------------------&gt; 3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@items.c</text></center>
<p>1) As discussed in last post, <a href="/understanding-memcached-source-code-IV/#assoc-delete-remove-from-hash-map">assoc_delete</a> removes the <strong>item</strong> from the <em>hash map</em>; and</p>
<p>2) <a href="/understanding-memcached-source-code-IV/#item-unlink-q-remove-from-linked-list">item_unlink_q</a> removes the <strong>item</strong> from the <strong>LRU list</strong> that the <strong>item</strong> belongs to.</p>
<p>3) This time <code>do_item_remove</code> simply decreases the reference count. The <strong>item</strong> will be removed when <code>do_item_remove</code> is called the second time from</p>
<h2 id="do-item-remove"><a href="#do-item-remove" class="headerlink" title="do_item_remove"></a>do_item_remove</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_remove">item_remove</a> is a thread safe wrapper of <code>do_item_remove</code>.<br><br><div id="item_remove" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_remove</span><span class="params">(item *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(ITEM_key(item), item-&gt;nkey);</span><br><span class="line"></span><br><span class="line">    item_lock(hv);</span><br><span class="line">    do_item_remove(item);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_remove@thread.c</text></center>
<p></p></div><p></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_remove</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (refcount_decr(&amp;it-&gt;refcount) == <span class="number">0</span>) &#123; <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">        item_free(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_free</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ntotal = ITEM_ntotal(it);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> clsid;</span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* so slab size changer can tell later if item is already free or not */</span></span><br><span class="line">    clsid = ITEM_clsid(it); <span class="comment">// scr: -------------------------&gt; 2)</span></span><br><span class="line">    DEBUG_REFCNT(it, <span class="string">'F'</span>);</span><br><span class="line">    slabs_free(it, ntotal, clsid); <span class="comment">// scr: ------------------&gt; 3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_remove@items.c</text></center>
<p>1) Decrease the reference count, if it reaches <code>0</code>, goto 2) and free the <strong>item</strong>.</p>
<p>2) Use <a href="#" onclick="return false;" data-toggle="collapse" data-target="#ITEM_clsid">ITEM_clsid</a> to get the <em>slab class</em> the <strong>item</strong> belongs. This macro removes the <em>list type</em> from <code>slabs_clsid</code>.</p>
<div id="ITEM_clsid" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_clsid(item) ((item)-&gt;slabs_clsid &amp; ~(3&lt;&lt;6))</span></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.h:116</text></center><br></div>

<p>3) Call <a href="/understanding-memcached-source-code-II/#do-slabs-free">slabs_free</a> to release the memory to slab subsystem.</p>
<h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><p>The <strong>Item</strong> creating procedure is divided into several logic fragments by the mentioned <strong>drive machine</strong>, 1) creating an empty <strong>item</strong> object with the <em>key</em> and other <em>meta data</em> sent through; 2) read the value (from the <em>socket</em>) and fill the <strong>item</strong> object with it; and 3) <em>link</em> the <strong>item object</strong>. The workflow controller - <strong>drive machine</strong> will be discussed in the next post.</p>
<p>Now we send an <code>add</code> command to the <strong>Memcached</strong> instance.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; add test 0 60 11 (\r\n)</span><br><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure>
<h2 id="Creating-an-empty-item-object"><a href="#Creating-an-empty-item-object" class="headerlink" title="Creating an empty item object"></a>Creating an empty item object</h2><p>After the first line of the above command</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; add test 0 60 11 (\r\n)</span><br></pre></td></tr></table></figure>
<p>the procedure described in this section starts, the call stack of the hot path is,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line">1 |~Drive machine &amp; command parser</span><br><span class="line">    |-process_update_command</span><br><span class="line">      |-do_item_alloc</span><br><span class="line">        |-slabs_clsid                (Slab III)</span><br><span class="line">++      |-do_slabs_alloc             (Slab III)</span><br><span class="line">        |-lru_pull_tail (on hot list)</span><br><span class="line">          |-do_item_update_nolock    (same to do_item_update)</span><br><span class="line">          |-do_item_remove</span><br><span class="line">          |-item_link_q              (LRU I)</span><br><span class="line">          |-do_item_remove</span><br><span class="line">        |-lru_pull_tail (on warm list)</span><br><span class="line">          |-same as hot list</span><br><span class="line">        |-lru_pull_tail (on cold list)</span><br><span class="line">          |-do_item_unlink_nolock    (same to do_item_unlink LRU I)</span><br></pre></td></tr></table></figure>
<p>We start from</p>
<h3 id="process-update-command"><a href="#process-update-command" class="headerlink" title="process_update_command"></a>process_update_command</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_update_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">const</span> <span class="keyword">size_t</span> ntokens, <span class="keyword">int</span> comm, <span class="keyword">bool</span> handle_cas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int32_t</span> exptime_int = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">time_t</span> exptime;</span><br><span class="line">    <span class="keyword">int</span> vlen;</span><br><span class="line">    <span class="keyword">uint64_t</span> req_cas_id=<span class="number">0</span>;</span><br><span class="line">    item *it;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: irrelevant code &amp; sanity checks</span></span><br><span class="line"></span><br><span class="line">    key = tokens[KEY_TOKEN].value; <span class="comment">// scr: ----------------------&gt; 1)</span></span><br><span class="line">    nkey = tokens[KEY_TOKEN].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! (safe_strtoul(tokens[<span class="number">2</span>].value, (<span class="keyword">uint32_t</span> *)&amp;flags)</span><br><span class="line">           &amp;&amp; safe_strtol(tokens[<span class="number">3</span>].value, &amp;exptime_int)</span><br><span class="line">           &amp;&amp; safe_strtol(tokens[<span class="number">4</span>].value, (<span class="keyword">int32_t</span> *)&amp;vlen))) &#123;</span><br><span class="line">        out_string(c, <span class="string">"CLIENT_ERROR bad command line format"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */</span></span><br><span class="line">    exptime = exptime_int;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: cas &amp; sanity checks</span></span><br><span class="line"></span><br><span class="line">    vlen += <span class="number">2</span>; <span class="comment">// scr: ------------------------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    it = item_alloc(key, nkey, flags, realtime(exptime), vlen); <span class="comment">// 3)</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: cas &amp; error handling</span></span><br><span class="line"></span><br><span class="line">    c-&gt;item = it; <span class="comment">// scr: ---------------------------------------&gt; 4)</span></span><br><span class="line">    c-&gt;ritem = ITEM_data(it);</span><br><span class="line">    c-&gt;rlbytes = it-&gt;nbytes;</span><br><span class="line">    c-&gt;cmd = comm;</span><br><span class="line">    conn_set_state(c, conn_nread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_update_command@memcached.c</text></center>
<p>1) Set the <em>key</em> (i.e., <code>test</code>), as well as the <em>meta data</em> (i.e., <code>flags</code>, <code>0</code>; <code>exptime</code>, <code>60;</code>vlen<code>,</code>11`), to local variables.</p>
<p>2) Increase <code>vlen</code> by <code>2</code>, to populate the <code>\n\r</code> in addition to the <em>key</em> string.</p>
<p>3) Call <code>item_alloc</code> to allocate the memory (from <a href="/understanding-memcached-source-code-III/">slab</a>) for the <strong>item</strong>.</p>
<p>4) After <code>item_alloc</code> is called, set the properties of <code>conn</code>. Here <code>ritem</code> points to the data portion of an <a href="/understanding-memcached-source-code-IV/#Memory-layout-of-an-item-chunk">item chunk</a>; and <code>rlbytes</code> is set to <code>vlen</code>. These two fields will be used to populate the data portion with the content, i.e., <code>hello world</code>, in the next post.</p>
<h3 id="do-item-alloc"><a href="#do-item-alloc" class="headerlink" title="do_item_alloc"></a>do_item_alloc</h3><p>Unlike other methods we have discussed, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_alloc">item_alloc</a> is a wrapper of <code>do_item_alloc</code> without adding any locks. I would assume this wrapper is added simply for consistent code style.</p>
<div id="item_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">size_t</span> nkey, <span class="keyword">int</span> flags, <span class="keyword">rel_time_t</span> exptime, <span class="keyword">int</span> nbytes)</span> </span>&#123;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="comment">/* do_item_alloc handles its own locks */</span></span><br><span class="line">    it = do_item_alloc(key, nkey, flags, exptime, nbytes, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5849</text></center><br></div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">do_item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">rel_time_t</span> exptime, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">uint8_t</span> nsuffix;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> suffix[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> total_chunks;       <span class="comment">// scr: -----------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">size_t</span> ntotal = item_make_header(nkey + <span class="number">1</span>, flags, nbytes, suffix, &amp;nsuffix);</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id = slabs_clsid(ntotal); <span class="comment">// scr: -----------------------&gt; 2)</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If no memory is available, attempt a direct LRU juggle/eviction */</span></span><br><span class="line">    <span class="comment">/* This is a race in order to simplify lru_pull_tail; in cases where</span></span><br><span class="line"><span class="comment">     * locked items are on the tail, you want them to fall out and cause</span></span><br><span class="line"><span class="comment">     * occasional OOM's, rather than internally work around them.</span></span><br><span class="line"><span class="comment">     * This also gives one fewer code path for slab alloc/free</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* Try to reclaim memory first */</span></span><br><span class="line">... <span class="comment">// scr: legacy, no lru_maintainer_thread</span></span><br><span class="line">        it = slabs_alloc(ntotal, id, &amp;total_chunks, <span class="number">0</span>); <span class="comment">// scr: ----------&gt; 3)</span></span><br><span class="line">... <span class="comment">// scr: no-expire setting</span></span><br><span class="line">        <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (settings.lru_maintainer_thread) &#123; <span class="comment">// scr: ----------------&gt; 4)</span></span><br><span class="line">                lru_pull_tail(id, HOT_LRU, total_chunks, <span class="literal">false</span>, cur_hv);</span><br><span class="line">                lru_pull_tail(id, WARM_LRU, total_chunks, <span class="literal">false</span>, cur_hv);</span><br><span class="line">                lru_pull_tail(id, COLD_LRU, total_chunks, <span class="literal">true</span>, cur_hv);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: legacy, no lru_maintainer_thread</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: stat &amp; sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Refcount is seeded to 1 by slabs_alloc() */</span></span><br><span class="line">    it-&gt;next = it-&gt;prev = it-&gt;h_next = <span class="number">0</span>; <span class="comment">// scr: ------------------------&gt; 5)</span></span><br><span class="line">    <span class="comment">/* Items are initially loaded into the HOT_LRU. This is '0' but I want at</span></span><br><span class="line"><span class="comment">     * least a note here. Compiler (hopefully?) optimizes this out.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (settings.lru_maintainer_thread) &#123;</span><br><span class="line">... <span class="comment">// scr: no expire setting</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id |= HOT_LRU; <span class="comment">// scr: ---------------------------------------&gt; 6)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: legacy, no lru_maintainer_thread</span></span><br><span class="line">    &#125;</span><br><span class="line">    it-&gt;slabs_clsid = id; <span class="comment">// scr: ----------------------------------------&gt; 7)</span></span><br><span class="line"></span><br><span class="line">    DEBUG_REFCNT(it, <span class="string">'*'</span>);</span><br><span class="line">    it-&gt;it_flags = settings.use_cas ? ITEM_CAS : <span class="number">0</span>;</span><br><span class="line">    it-&gt;nkey = nkey;</span><br><span class="line">    it-&gt;nbytes = nbytes;</span><br><span class="line">    <span class="built_in">memcpy</span>(ITEM_key(it), key, nkey);</span><br><span class="line">    it-&gt;exptime = exptime;</span><br><span class="line">    <span class="built_in">memcpy</span>(ITEM_suffix(it), suffix, (<span class="keyword">size_t</span>)nsuffix);</span><br><span class="line">    it-&gt;nsuffix = nsuffix;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_alloc@items.c</text></center>
<p>1) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_make_header">item_make_header</a> initializes <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">suffix</a> portion of the <a href="/understanding-memcached-source-code-IV/#Memory-layout-of-an-item-chunk">item chunk</a> using the <em>meta data</em> (<code>flags</code>) and <em>key</em>.</p>
<div id="item_make_header" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">item_make_header</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> nkey, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">char</span> *suffix, <span class="keyword">uint8_t</span> *nsuffix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* suffix is defined at 40 chars elsewhere.. */</span></span><br><span class="line">    *nsuffix = (<span class="keyword">uint8_t</span>) <span class="built_in">snprintf</span>(suffix, <span class="number">40</span>, <span class="string">" %u %d\r\n"</span>, flags, nbytes - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(item) + nkey + *nsuffix + nbytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_make_header@items.c</text></center><br></div>

<p>2), 3) are discussed in detail in <a href="/understanding-memcached-source-code-III/">Slab III</a>. To recap, <a href="/understanding-memcached-source-code-III/#slabs-clsid">slabs_clsid</a> select the most optimal <em>slab class</em> and <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">slab_alloc</a> allocates one <strong>item chunk</strong> from <strong>slab</strong> sub-system.</p>
<p>4) If <code>slab_alloc</code> fails, try to release some memory using <code>lru_pull_tail</code> and retry the allocation for at most <code>5</code> times. <code>lru_pull_tail</code> is the focus of the <a href="#lru-pull-tail">next section</a>.</p>
<p>5) Initialize the <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">pointers</a> of <strong>LRU list</strong> and <em>hash collision list</em>.</p>
<p>6) Set the <em>list type</em> (<code>HOT_LRU</code>) to the <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">slabs_clsid</a>, which indicates that this <strong>item</strong> belongs to the “HOT” <strong>LRU list</strong> of its respective <em>slab class</em>.</p>
<p>7) Initialize <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">other fields</a> of <strong>item</strong>.</p>
<h3 id="lru-pull-tail"><a href="#lru-pull-tail" class="headerlink" title="lru_pull_tail"></a>lru_pull_tail</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lru_pull_tail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> orig_id, <span class="keyword">const</span> <span class="keyword">int</span> cur_lru,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> total_chunks, <span class="keyword">const</span> <span class="keyword">bool</span> do_evict, <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv)</span> </span>&#123;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> id = orig_id; <span class="comment">// scr: ---------------------------------------&gt; p)</span></span><br><span class="line">    <span class="keyword">int</span> removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tries = <span class="number">5</span>;</span><br><span class="line">    item *search;</span><br><span class="line">    item *next_it;</span><br><span class="line">    <span class="keyword">void</span> *hold_lock = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> move_to_lru = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> limit;</span><br><span class="line"></span><br><span class="line">    id |= cur_lru; <span class="comment">// scr: ------------------------------------------&gt; p)</span></span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[id]);</span><br><span class="line">    search = tails[id]; <span class="comment">// scr: -------------------------------------&gt; p)</span></span><br><span class="line">    <span class="comment">/* We walk up *only* for locked items, and if bottom is expired. */</span></span><br><span class="line">    <span class="keyword">for</span> (; tries &gt; <span class="number">0</span> &amp;&amp; search != <span class="literal">NULL</span>; tries--, search=next_it) &#123;<span class="comment">//s: p)</span></span><br><span class="line">        <span class="comment">/* we might relink search mid-loop, so search-&gt;prev isn't reliable */</span></span><br><span class="line">        next_it = search-&gt;prev; <span class="comment">// scr: -----------------------------&gt; p)</span></span><br><span class="line">...<span class="comment">// scr: irrelevant code here</span></span><br><span class="line">        <span class="keyword">uint32_t</span> hv = hash(ITEM_key(search), search-&gt;nkey);</span><br><span class="line">        <span class="comment">/* Attempt to hash item lock the "search" item. If locked, no</span></span><br><span class="line"><span class="comment">         * other callers can incr the refcount. Also skip ourselves. */</span></span><br><span class="line">        <span class="keyword">if</span> (hv == cur_hv || (hold_lock = item_trylock(hv)) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/* Now see if the item is refcount locked */</span></span><br><span class="line">        <span class="keyword">if</span> (refcount_incr(&amp;search-&gt;refcount) != <span class="number">2</span>) &#123; <span class="comment">// scr: --------&gt; s)</span></span><br><span class="line">            <span class="comment">/* Note pathological case with ref'ed items in tail.</span></span><br><span class="line"><span class="comment">             * Can still unlink the item, but it won't be reusable yet */</span></span><br><span class="line">            itemstats[id].lrutail_reflocked++;</span><br><span class="line">            <span class="comment">/* In case of refcount leaks, enable for quick workaround. */</span></span><br><span class="line">            <span class="comment">/* WARNING: This can cause terrible corruption */</span></span><br><span class="line">            <span class="keyword">if</span> (settings.tail_repair_time &amp;&amp;</span><br><span class="line">                    search-&gt;time + settings.tail_repair_time &lt; current_time) &#123;</span><br><span class="line">                itemstats[id].tailrepairs++;</span><br><span class="line">                search-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/* This will call item_remove -&gt; item_free since refcnt is 1 */</span></span><br><span class="line">                do_item_unlink_nolock(search, hv);</span><br><span class="line">                item_trylock_unlock(hold_lock);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Expired or flushed */</span> <span class="comment">// scr: ---------------------------&gt; e1)</span></span><br><span class="line">        <span class="keyword">if</span> ((search-&gt;exptime != <span class="number">0</span> &amp;&amp; search-&gt;exptime &lt; current_time)</span><br><span class="line">            || item_is_flushed(search)) &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">            <span class="comment">/* refcnt 2 -&gt; 1 */</span></span><br><span class="line">            do_item_unlink_nolock(search, hv);</span><br><span class="line">            <span class="comment">/* refcnt 1 -&gt; 0 -&gt; item_free */</span></span><br><span class="line">            do_item_remove(search);</span><br><span class="line">            item_trylock_unlock(hold_lock);</span><br><span class="line">            removed++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If all we're finding are expired, can keep going */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we're HOT_LRU or WARM_LRU and over size limit, send to COLD_LRU.</span></span><br><span class="line"><span class="comment">         * If we're COLD_LRU, send to WARM_LRU unless we need to evict</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (cur_lru) &#123;</span><br><span class="line">            <span class="keyword">case</span> HOT_LRU: <span class="comment">// scr: -----------------------------------&gt; 1)</span></span><br><span class="line">                limit = total_chunks * settings.hot_lru_pct / <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> WARM_LRU:</span><br><span class="line">                limit = total_chunks * settings.warm_lru_pct / <span class="number">100</span>; <span class="comment">// 1)</span></span><br><span class="line">                <span class="keyword">if</span> (sizes[id] &gt; limit) &#123; <span class="comment">// scr: --------------------&gt; 2)</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                    move_to_lru = COLD_LRU;</span><br><span class="line">                    do_item_unlink_q(search);</span><br><span class="line">                    it = search;</span><br><span class="line">                    removed++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((search-&gt;it_flags &amp; ITEM_ACTIVE) != <span class="number">0</span>) &#123; <span class="comment">//e3)</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                    search-&gt;it_flags &amp;= ~ITEM_ACTIVE;</span><br><span class="line">                    do_item_update_nolock(search);</span><br><span class="line">                    do_item_remove(search);</span><br><span class="line">                    item_trylock_unlock(hold_lock);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ------------------------------------&gt; 3)</span></span><br><span class="line">                    <span class="comment">/* Don't want to move to COLD, not active, bail out */</span></span><br><span class="line">                    it = search;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> COLD_LRU:</span><br><span class="line">                it = search; <span class="comment">/* No matter what, we're stopping */</span></span><br><span class="line">                <span class="keyword">if</span> (do_evict) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (settings.evict_to_free == <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applied here</span></span><br><span class="line">                    &#125;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                    LOGGER_LOG(<span class="literal">NULL</span>, LOG_EVICTIONS, LOGGER_EVICTION, search);</span><br><span class="line">                    do_item_unlink_nolock(search, hv); <span class="comment">// scr: ------&gt; 4)</span></span><br><span class="line">                    removed++;</span><br><span class="line">                    <span class="keyword">if</span> (settings.slab_automove == <span class="number">2</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applied here</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">...<span class="comment">// scr: not applied here</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[id]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: --------------------------------------&gt; e2)</span></span><br><span class="line">        <span class="keyword">if</span> (move_to_lru) &#123;</span><br><span class="line">            it-&gt;slabs_clsid = ITEM_clsid(it);</span><br><span class="line">            it-&gt;slabs_clsid |= move_to_lru;</span><br><span class="line">            item_link_q(it);</span><br><span class="line">        &#125;</span><br><span class="line">        do_item_remove(it);</span><br><span class="line">        item_trylock_unlock(hold_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">lru_pull_tail@items.c</text></center>
<p><strong>Method start &amp; end</strong></p>
<p>p) This method starts by selecting the tail element of the designated <strong>LRU list</strong> using the <strong>slab class</strong> id and the <em>list type</em>, assuming that the element can be a release candidate. And it iterates over (at most <code>5</code> entries) the list in reverse order to find a entry in case that elements near the tail are recently <a href="#Read">accessed</a>.</p>
<p>s) For each <strong>item</strong> selected, increase its <em>reference count</em>. In normal situation, the original value of <em>reference count</em> should be <code>1</code> (as you will see in the <a href="#Populate-the-data-amp-Link-the-item">last step</a> of the create operation). Hence a <code>!= 2</code> value after the increment indicates an exception that needs to be corrected. Note that the reference count is now 2 so it is required to decrease at least one time (back to 1) when the processing of the current item is done (e1, e2 or e3 is reached).</p>
<p>e1) Remove the <strong>item</strong> directly when an expiration is detected. Here the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_unlink_nolock">do_item_unlink_nolock</a> is exactly the same as the discussed <a href="#item-unlink">do_item_unlink</a> (I think the code is duplicated to emphasize that this method is not thread-safe), and it follows the same “unlink and remove” routine as in <a href="#Delete">item delete</a>.</p>
<p>e2) When a candidate is found, we might need to relocate it to another <strong>list</strong> (when <code>move_to_lru</code> is set in the <code>switch</code> <code>case</code>) by calling <a href="/understanding-memcached-source-code-IV/#item-link-q-add-to-linked-list">item_link_q</a>. And we do need to call <a href="##item-remove">do_item_remove</a> to reduce the reference count back to <code>1</code>. The decision is made by the steps discussed bellow.</p>
<a href="#" id="opt2" style="visibility: hidden"></a>
<p>e3) If an <strong>item</strong> is recently accessed, reset the <code>ITEM_ACTIVE</code> flag; <em>bump</em> it to the head of the list; decrease its <em>reference count</em> and iterate to the next one (maximum <code>5</code> times). Remember that the flag <code>ITEM_ACTIVE</code> is set by <a href="/understanding-memcached-source-code-VI/#item-get">item_get</a>, and here is the place where the <strong>item</strong> gets <em>bumped</em>.</p>
<p><strong>Hot &amp; warm</strong></p>
<p>1) The only difference of <code>HOT_LRU</code> and <code>WARM_LRU</code> is the threshold (<code>limit</code>) which are indicated by their respective configurations <a href="#" onclick="return false;" data-toggle="collapse" data-target="#hot_lru_pct">hot_lru_pct</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#warm_lru_pct">warm_lru_pct</a>.</p>
<div id="hot_lru_pct" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.hot_lru_pct = <span class="number">32</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> HOT_LRU_PCT:</span><br><span class="line">    <span class="keyword">if</span> (subopts_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Missing hot_lru_pct argument\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    settings.hot_lru_pct = atoi(subopts_value);</span><br><span class="line">    <span class="keyword">if</span> (settings.hot_lru_pct &lt; <span class="number">1</span> || settings.hot_lru_pct &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"hot_lru_pct must be &gt; 1 and &lt; 80\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">hot_lru_pct@memcached.c</text></center><br></div>

<div id="warm_lru_pct" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.warm_lru_pct = <span class="number">32</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> WARM_LRU_PCT:</span><br><span class="line">    <span class="keyword">if</span> (subopts_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Missing warm_lru_pct argument\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    settings.warm_lru_pct = atoi(subopts_value);</span><br><span class="line">    <span class="keyword">if</span> (settings.warm_lru_pct &lt; <span class="number">1</span> || settings.warm_lru_pct &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"warm_lru_pct must be &gt; 1 and &lt; 80\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">warm_lru_pct@memcached.c</text></center><br></div>


<p>2) If the threshold of <code>HOT_LRU</code> or <code>WARM_LRU</code> is reached, remove the <strong>item</strong> from the current list using <a href="/understanding-memcached-source-code-IV/#item-unlink-q-remove-from-linked-list">do_item_unlink_q</a>, and goto e2). Therefore, e2) is responsible to relink it to the <code>COLD_LRU</code> and decrease the reference count.</p>
<p>3) If the current <strong>item</strong> is not “active”, and the threshold is not reached, finish this method without any <strong>item</strong> relocation, nor release.</p>
<p><strong>Cold</strong></p>
<p>4) If there are any <strong>item</strong> in the list, evict it directly with the discussed <code>do_item_unlink_nolock</code> to free up its resource, and goto e1). Note that the default values of <a href="#" onclick="return false;" data-toggle="collapse" data-target="#evict_to_free">evict_to_free</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_automove">slab_automove</a> are set to values that disable their respective <code>if</code> blocks.</p>
<div id="evict_to_free" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.evict_to_free = <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:215</text></center><br></div>

<div id="slab_automove" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> MODERN:</span><br><span class="line">    <span class="comment">/* Modernized defaults. Need to add equivalent no_* flags</span></span><br><span class="line"><span class="comment">     * before making truly default. */</span></span><br><span class="line">...</span><br><span class="line">    settings.slab_automove = <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5824</text></center><br></div>

<p>Now we input the second line of the command</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure>
<p>and trigger the following procedures.</p>
<h2 id="Populate-the-item-with-content"><a href="#Populate-the-item-with-content" class="headerlink" title="Populate the item with content"></a>Populate the item with content</h2><p>As mentioned in <a href="#process-update-command">process_update_command</a>, the content we input is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#populated">populated</a> to <code>conn.item</code> using <code>conn.ritem</code> and <code>conn.rlbytes</code>. This step is handled by <strong>drive machine</strong> which will be discussed in detail in the next post.</p>
<div id="populated" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">res = read(c-&gt;sfd, c-&gt;ritem, c-&gt;rlbytes);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4421</text></center><br></div>

<p>Now we consider <code>conn.item</code> is filled with all relevant information, hence the next and final step is to</p>
<h2 id="Link-the-item"><a href="#Link-the-item" class="headerlink" title="Link the item"></a>Link the item</h2><p>the call stack of this step is</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line"><span class="number">2</span> |~Drive machine &amp; command parser</span><br><span class="line">    |-complete_nread</span><br><span class="line">      |-complete_nread_ascii</span><br><span class="line">        |-do_store_item</span><br><span class="line">        |=do_item_link      (LRU I)</span><br><span class="line">--      |-do_item_remove</span><br></pre></td></tr></table></figure>
<a href="#" onclick="return false;" data-toggle="collapse" data-target="#complete_nread">complete_nread</a> checks the protocol in use and moves directly to<br><br><div id="complete_nread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete_nread</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">    assert(c-&gt;protocol == ascii_prot</span><br><span class="line">           || c-&gt;protocol == binary_prot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;protocol == ascii_prot) &#123;</span><br><span class="line">        complete_nread_ascii(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;protocol == binary_prot) &#123;</span><br><span class="line">        complete_nread_binary(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">complete_nread@memcached.c</text></center>
<p></p></div><p></p>
<h3 id="complete-nread-ascii"><a href="#complete-nread-ascii" class="headerlink" title="complete_nread_ascii"></a>complete_nread_ascii</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete_nread_ascii</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    item *it = c-&gt;item;</span><br><span class="line">    <span class="keyword">int</span> comm = c-&gt;cmd;</span><br><span class="line">    <span class="keyword">enum</span> store_item_type ret;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(ITEM_data(it) + it-&gt;nbytes - <span class="number">2</span>, <span class="string">"\r\n"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        out_string(c, <span class="string">"CLIENT_ERROR bad data chunk"</span>); <span class="comment">// scr: -----&gt; 1)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret = store_item(it, comm, c);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">      <span class="keyword">case</span> STORED:</span><br><span class="line">          out_string(c, <span class="string">"STORED"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> EXISTS:</span><br><span class="line">          out_string(c, <span class="string">"EXISTS"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NOT_FOUND:</span><br><span class="line">          out_string(c, <span class="string">"NOT_FOUND"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NOT_STORED:</span><br><span class="line">          out_string(c, <span class="string">"NOT_STORED"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          out_string(c, <span class="string">"SERVER_ERROR Unhandled storage type."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scr: -------------------------------------------------------&gt; 2)</span></span><br><span class="line">    item_remove(c-&gt;item);       <span class="comment">/* release the c-&gt;item reference */</span></span><br><span class="line">    c-&gt;item = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_store_item@items.c</text></center>
<p>1) Call <code>store_item</code> to link the <strong>item</strong> to the <strong>LRU list</strong> and <strong>hash map</strong>.</p>
<p>2) The <em>reference count</em> is set to <code>1</code> by <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slab_alloc</a> in <a href="#do-item-alloc">do_item_alloc</a> and increased by <a href="/understanding-memcached-source-code-IV/#do-item-link">do_item_link</a> in <a href="#do-store-item">do_store_item</a>. So reduce it to the normal value, <code>1</code>, with <a href="#do-item-remove">item_remove</a>. The methods of those have all been discussed in detail.</p>
<h3 id="do-store-item"><a href="#do-store-item" class="headerlink" title="do_store_item"></a>do_store_item</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> store_item_type <span class="title">do_store_item</span><span class="params">(item *it, <span class="keyword">int</span> comm, conn *c, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key = ITEM_key(it);</span><br><span class="line">    item *old_it = do_item_get(key, it-&gt;nkey, hv, c); <span class="comment">// scr: ------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">enum</span> store_item_type stored = NOT_STORED;</span><br><span class="line"></span><br><span class="line">    item *new_it = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_it != <span class="literal">NULL</span> &amp;&amp; comm == NREAD_ADD) &#123;</span><br><span class="line">... <span class="comment">// scr: update logic</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!old_it &amp;&amp; (comm == NREAD_REPLACE</span><br><span class="line">        || comm == NREAD_APPEND || comm == NREAD_PREPEND))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* replace only replaces an existing value; don't store */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comm == NREAD_CAS) &#123;</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (comm == NREAD_APPEND || comm == NREAD_PREPEND) &#123;</span><br><span class="line">... <span class="comment">// scr: comm is NREAD_ADD (1)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stored == NOT_STORED &amp;&amp; failed_alloc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (old_it != <span class="literal">NULL</span>)</span><br><span class="line">                item_replace(old_it, it, hv);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                do_item_link(it, hv); <span class="comment">// scr: ----------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            stored = STORED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: irrelevant code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: cas</span></span><br><span class="line">    LOGGER_LOG(c-&gt;thread-&gt;l, LOG_MUTATIONS, LOGGER_ITEM_STORE, <span class="literal">NULL</span>,</span><br><span class="line">            stored, comm, ITEM_key(it), it-&gt;nkey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_store_item@items.c</text></center>
<p>1) The newly created <strong>item</strong> exists only in the <strong>slab</strong> subsystem, hence <a href="#do-item-get">do_item_get</a> returns <code>null</code> as there is no such record in <strong>hash map</strong> yet.</p>
<p>2) So in the context of <em>item creation</em>, <code>do_store_item</code> is essentially the same as <a href="/understanding-memcached-source-code-IV/#do-item-link">do_item_link</a>.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://memcached.org/blog/modern-lru/" target="_blank" rel="noopener">Replacing the cache replacement algorithm in memcached</a></p>
<p><a href="http://hourlyapps.blogspot.com/2010/06/examples-of-memcached-commands.html" target="_blank" rel="noopener">Examples of Memcached telnet commands</a></p>
<p><a href="https://blog.elijaa.org/2010/05/21/memcached-telnet-command-summary/#delete" target="_blank" rel="noopener">Memcached telnet command summary</a></p>

      
    </div>
    
    <p>
    <div>
        
          That's it. Did I make a serious mistake? or miss out on anything important? Or you simply like the read. Link me on <a class="ext-link" href='https://medium.com/source-code/understanding-the-memcached-source-code-lru-iii-87d1c7497cb9'>
            <i class="fa fa-medium" aria-hidden="true"></i>
          </a>  -- I'd be chuffed to hear your feedback.
        
    </div>
    
    <p>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Memcached-Source-Code/">Memcached Source Code</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LRU/">LRU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cache/">cache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcached/">memcached</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/understanding-memcached-source-code-VII/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Understanding The Memcached Source Code - Event Driven I
        
      </div>
    </a>
  
  
    <a href="/understanding-memcached-source-code-V/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Understanding The Memcached Source Code - LRU II</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Read"><span class="nav-number">1.</span> <span class="nav-text">Read</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#process-get-command"><span class="nav-number">1.1.</span> <span class="nav-text">process_get_command</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do-item-get"><span class="nav-number">1.2.</span> <span class="nav-text">do_item_get</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do-item-update"><span class="nav-number">1.3.</span> <span class="nav-text">do_item_update</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Delete"><span class="nav-number">2.</span> <span class="nav-text">Delete</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#process-delete-command"><span class="nav-number">2.1.</span> <span class="nav-text">process_delete_command</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do-item-unlink"><span class="nav-number">2.2.</span> <span class="nav-text">do_item_unlink</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#do-item-remove"><span class="nav-number">2.3.</span> <span class="nav-text">do_item_remove</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Create"><span class="nav-number">3.</span> <span class="nav-text">Create</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Creating-an-empty-item-object"><span class="nav-number">3.1.</span> <span class="nav-text">Creating an empty item object</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#process-update-command"><span class="nav-number">3.1.1.</span> <span class="nav-text">process_update_command</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-item-alloc"><span class="nav-number">3.1.2.</span> <span class="nav-text">do_item_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lru-pull-tail"><span class="nav-number">3.1.3.</span> <span class="nav-text">lru_pull_tail</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Populate-the-item-with-content"><span class="nav-number">3.2.</span> <span class="nav-text">Populate the item with content</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Link-the-item"><span class="nav-number">3.3.</span> <span class="nav-text">Link the item</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#complete-nread-ascii"><span class="nav-number">3.3.1.</span> <span class="nav-text">complete_nread_ascii</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#do-store-item"><span class="nav-number">3.3.2.</span> <span class="nav-text">do_store_item</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">4.</span> <span class="nav-text">Reference</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2020 Holmes He 
        
              <a class='ext-link' href="https://creativecommons.org/licenses/by-nd/4.0/">
                <img style="padding-bottom:4px" src="https://mirrors.creativecommons.org/presskit/buttons/80x15/svg/by-nd.svg"/>
              </a>
              <a class='ext-link' href="mailto:holmeshe@hotmail.com">
                <i style="color:#9ea6a6;" class="fas fa-envelope"></i>
              </a>
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>, icons by <a href="https://www.flaticon.com/authors/prettycons" title="prettycons">prettycons</a>, <a href="https://www.freepik.com/" title="Freepik">Freepik</a> and <a href="https://www.flaticon.com/authors/google" title="Google">Google</a> on <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>

    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-104935393-1', 'auto');
ga('send', 'pageview');

</script>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-5381847417546942",
    enable_page_level_ads: true
  });
</script>
<!-- End Google Analytics -->
<!--<script type="text/javascript"> var infolinks_pid = 3169448; var infolinks_wsid = 0; </script> <script type="text/javascript" src="//resources.infolinks.com/js/infolinks_main.js"></script> -->





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  <script type="text/javascript" src="/js/cust.js" async=""></script>
</body>
</html>
