<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Holmes He</title>
  
  <subtitle>Holmes&#39; Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://holmeshe.me/"/>
  <updated>2020-12-22T10:48:38.121Z</updated>
  <id>https://holmeshe.me/</id>
  
  <author>
    <name>Holmes He</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Understanding The Memcached Source Code-Event Driven III</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-IX/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-IX/</id>
    <published>2019-06-01T22:30:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="#"><text style="color:black;font-weight:bold;">, III - this article)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>We continue examining the other two operations, i.e., create and delete, in the <strong>event driven</strong> context. Now it’s a good chance to revisit the <a href="/understanding-memcached-source-code-VIII/#Core-data-structure-conn">core data structure</a> and look at the</p><h1 id="Properties-in-discussion"><a href="#Properties-in-discussion" class="headerlink" title="Properties in discussion"></a>Properties in discussion</h1><a id="more"></a><p><code>wbuf</code> - the address for <em>write buffer</em> for simple response output (e.g., STORED). used by <a href="#out-string">out_string</a></p><p><code>wcurr</code> - not very useful as it points to the same address as <code>wbuf</code>. used by <a href="#conn-write">conn_write</a></p><p><code>wsize</code> - the total size of <em>write buffer</em>. used by <a href="#out-string">out_string</a> to determine buff overflow</p><p><code>wbytes</code> - the length of data populated in <em>write buffer</em>. value is set in <a href="#out-string">out_string</a>; used by <a href="#conn-write">conn_write</a> when writing it to the “real” output buffer <a href="/understanding-memcached-source-code-VIII/#add-iov">iov</a></p><p><code>write_and_go</code> - set to <code>conn_new_cmd</code> in the <a href="#out-string">very last step</a> to form a “state loop”</p><p><code>ritem</code> - one of the essential properties for <a href="#conn-nread">data reading</a>. it is set to the address of the data portion of the actual <strong>item</strong> created by <a href="#process-update-command">create command</a></p><p><code>rlbytes</code> - one of the essential properties for <a href="#conn-nread">data reading</a>. it is set to the length of the data in need</p><p><code>item</code> - record of the actual <strong>item</strong> created by <a href="#process-update-command">create command</a></p><p><code>noreply</code> - determined by the command. we assume it is set to <code>false</code></p><h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><p>As usual, we start with a command sent to a <strong>Memcached</strong> server.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; add test 0 60 11 (\r\n)</span><br><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure><p>As mentioned in <a href="/understanding-memcached-source-code-VI/#Create">LRU III</a>, two passes are involved in the command processing, the first pass creates an empty object after reading the first line, and the second populates the object with the concrete value contained in the second line. Such division is for the multiple <em>I/O</em> triggered by line breaks in <em>telnet</em>.</p><p class="back"><br>In fact, most of the logic involved in this post has been discussed before such as in <a href="/understanding-memcached-source-code-VI">LRU III</a> and <a href="/understanding-memcached-source-code-VIII">Event Driven II</a>. Hence this post will only resolve the missing parts and linking points.<br></p><p>For the first command,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; add test 0 60 11 (\r\n)</span><br></pre></td></tr></table></figure><p>The <strong>Memcached</strong> instance outputs the following lines. This time we omit the output for accepting the new connection</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27: going from conn_new_cmd to conn_waiting</span><br><span class="line">27: going from conn_waiting to conn_read</span><br><span class="line">27: going from conn_read to conn_parse_cmd</span><br><span class="line">27: Client using the ascii protocol</span><br><span class="line">&lt;27 add test 0 60 11</span><br><span class="line">27: going from conn_parse_cmd to conn_nread</span><br></pre></td></tr></table></figure><p>The logic for command reading and parsing (<code>conn_new_cmd</code> to <code>conn_parse_cmd</code>) are the same as what described in <a href="/understanding-memcached-source-code-VIII/#conn-new-cmd">Event Driven II</a>. The difference is that </p><h2 id="process-update-command"><a href="#process-update-command" class="headerlink" title="process_update_command"></a>process_update_command</h2><p>is invoked after the command parsing. Though the method has been examined in <a href="/understanding-memcached-source-code-VI/#process-update-command">LRU III</a>, it is worth reminding that the last step is to update the <em>session context</em> for the next <strong>state</strong> (<code>conn_nread</code>) which handles the actual data reading.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_update_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">const</span> <span class="keyword">size_t</span> ntokens, <span class="keyword">int</span> comm, <span class="keyword">bool</span> handle_cas)</span> </span>&#123;</span><br><span class="line">... <span class="comment">// LRU III</span></span><br><span class="line">    c-&gt;item = it;</span><br><span class="line">    c-&gt;ritem = ITEM_data(it);</span><br><span class="line">    c-&gt;rlbytes = it-&gt;nbytes;</span><br><span class="line">    c-&gt;cmd = comm;</span><br><span class="line">    conn_set_state(c, conn_nread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_update_command@memcached.c</text></center><p>Next we look at the second command</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure><p>and its associated output</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; NOT FOUND test</span><br><span class="line">&gt;27 STORED</span><br><span class="line">27: going from conn_nread to conn_write</span><br><span class="line">27: going from conn_write to conn_new_cmd</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>The key code fragment for the <strong>state</strong> switching above is</p><h2 id="conn-nread"><a href="#conn-nread" class="headerlink" title="conn_nread"></a>conn_nread</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_nread:</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;rlbytes == <span class="number">0</span>) &#123; <span class="comment">// scr: ---------------------------&gt; 5)</span></span><br><span class="line">                complete_nread(c);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* first check if we have leftovers in the conn_read buffer */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;rbytes &gt; <span class="number">0</span>) &#123; <span class="comment">// scr: -----------------------------&gt; 1)</span></span><br><span class="line">                <span class="keyword">int</span> tocopy = c-&gt;rbytes &gt; c-&gt;rlbytes ? c-&gt;rlbytes : c-&gt;rbytes;</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;ritem != c-&gt;rcurr) &#123;</span><br><span class="line">                    memmove(c-&gt;ritem, c-&gt;rcurr, tocopy);</span><br><span class="line">                &#125;</span><br><span class="line">                c-&gt;ritem += tocopy;</span><br><span class="line">                c-&gt;rlbytes -= tocopy;</span><br><span class="line">                c-&gt;rcurr += tocopy;</span><br><span class="line">                c-&gt;rbytes -= tocopy;</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;rlbytes == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*  now try reading from the socket */</span></span><br><span class="line">            res = read(c-&gt;sfd, c-&gt;ritem, c-&gt;rlbytes); <span class="comment">// scr: --------&gt; 2)</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                <span class="keyword">if</span> (c-&gt;rcurr == c-&gt;ritem) &#123;</span><br><span class="line">                    c-&gt;rcurr += res;</span><br><span class="line">                &#125;</span><br><span class="line">                c-&gt;ritem += res;</span><br><span class="line">                c-&gt;rlbytes -= res;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">0</span>) &#123; <span class="comment">/* end of stream */</span> <span class="comment">// scr: --------------&gt; 3)</span></span><br><span class="line">                conn_set_state(c, conn_closing);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="comment">// scr: ------------------------------------------------&gt; 4)</span></span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">-1</span> &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!update_event(c, EV_READ | EV_PERSIST)) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">                &#125;</span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_update_command@memcached.c</text></center><p>1) Check if there are some leftover data (from the <a href="/understanding-memcached-source-code-VIII/#try-read-network">command read</a> phase). If so, read directly.</p><p class="back"><br>More specific, say, if you can enter the command above fast enough (maybe copy paste it directly to <em>telnet</em>), the data portion will be coalesced in with the command by <a href="/understanding-memcached-source-code-VIII/#try-read-network">read</a>.<br></p><p>2) Read the data to the memory pointed by <code>ritem</code>.</p><p>3) If the connection is closed (<em>FIN</em>) in the middle of the read, close the session.</p><p>4) If the data is separated into multiple <code>read</code>s, then set the <em>drive machine</em> to listen to more data and suspend.</p><p>5) Normal termination - <code>read</code> finished, call <a href="/understanding-memcached-source-code-VI/#complete-nread-ascii">complete_nread</a> which is covered in <a href="/understanding-memcached-source-code-VI">LRU III</a>.</p><p>The missing part in <a href="/understanding-memcached-source-code-VI">LRU III</a> is <code>out_string</code>. Combined with <code>conn_write</code>, it functions as a simpler version of <a href="/understanding-memcached-source-code-VIII/#process-get-command">process_get_command</a> for “simple response”, and the actual data writing is handled by <a href="/understanding-memcached-source-code-VIII/#conn-mwrite">conn_mwrite</a> (note the <code>fall through...</code> in the <code>switch case</code>) block which, as discussed, changes the <strong>state</strong> back to <code>conn_new_cmd</code>. Next we discuss the process in detail.</p><h2 id="out-string"><a href="#out-string" class="headerlink" title="out_string"></a>out_string</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">out_string</span><span class="params">(conn *c, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    </span><br><span class="line">...<span class="comment">//scr: not applicable</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"&gt;%d %s\n"</span>, c-&gt;sfd, str);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* Nuke a partial output... */</span></span><br><span class="line">    c-&gt;msgcurr = <span class="number">0</span>; <span class="comment">// scr: ---------------------------&gt; 1)</span></span><br><span class="line">    c-&gt;msgused = <span class="number">0</span>;</span><br><span class="line">    c-&gt;iovused = <span class="number">0</span>;</span><br><span class="line">    add_msghdr(c);</span><br><span class="line">    </span><br><span class="line">    len = <span class="built_in">strlen</span>(str); <span class="comment">// scr: ------------------------&gt; 2)</span></span><br><span class="line">    <span class="keyword">if</span> ((len + <span class="number">2</span>) &gt; c-&gt;wsize) &#123;</span><br><span class="line">        <span class="comment">/* ought to be always enough. just fail for simplicity */</span></span><br><span class="line">        str = <span class="string">"SERVER_ERROR output line too long"</span>;</span><br><span class="line">        len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;wbuf, str, len); <span class="comment">// scr: ----------------&gt; 3)</span></span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;wbuf + len, <span class="string">"\r\n"</span>, <span class="number">2</span>);</span><br><span class="line">    c-&gt;wbytes = len + <span class="number">2</span>;</span><br><span class="line">    c-&gt;wcurr = c-&gt;wbuf;</span><br><span class="line">    </span><br><span class="line">    conn_set_state(c, conn_write); <span class="comment">// scr: ------------&gt; 4)</span></span><br><span class="line">    c-&gt;write_and_go = conn_new_cmd; <span class="comment">// scr: -----------&gt; 5)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:out_string</text></center><p>1) Initialize the <code>iov</code>. the mechanism and <a href="/understanding-memcached-source-code-VIII/#add-msghdr">add_msghdr</a> has been discussed in the <a href="/understanding-memcached-source-code-VIII/">last post</a></p><p>2) Calculate string length, and be paranoid for survival.</p><p>3) Populate <code>wbuf</code> with the output string and point <code>wcurr</code> to <code>wbuf</code>.</p><p>4) Indicate the next <strong>state</strong> <code>conn_write</code>.</p><p>5) Set the last <strong>state</strong> to <code>conn_new_cmd</code> and form the “loop”.</p><h2 id="conn-write"><a href="#conn-write" class="headerlink" title="conn_write"></a>conn_write</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_write:</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * We want to write out a simple response. If we haven't already,</span></span><br><span class="line"><span class="comment">             * assemble it into a msgbuf list (this will be a single-entry</span></span><br><span class="line"><span class="comment">             * list for TCP or a two-entry list for UDP).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;iovused == <span class="number">0</span> || (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;iovused == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (add_iov(c, c-&gt;wcurr, c-&gt;wbytes) != <span class="number">0</span>) &#123; <span class="comment">// scr: ---&gt; 1)</span></span><br><span class="line">                    <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">                        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Couldn't build response\n"</span>);</span><br><span class="line">                    conn_set_state(c, conn_closing);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* fall through... */</span></span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">...<span class="comment">// scr: discussed</span></span><br><span class="line">            <span class="keyword">switch</span> (transmit(c)) &#123;</span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_COMPLETE:</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;state == conn_mwrite) &#123;</span><br><span class="line">...<span class="comment">// scr: discussed</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;state == conn_write) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c-&gt;write_and_free) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    conn_set_state(c, c-&gt;write_and_go); <span class="comment">// scr: -------&gt; 2)</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: discussed</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4507</text></center><p>1) Add the content of “write buffer” to the actual <code>iov</code>.</p><p>2) Pick up the <code>write_and_go</code> (i.e., conn_new_cmd) and set it to the next <strong>state</strong>.</p><p>Next, we send the</p><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>command to delete the entry we just added.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; delete test</span><br></pre></td></tr></table></figure><p>And the output this time is</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">28: going from conn_read to conn_parse_cmd</span><br><span class="line">&lt;28 delete test</span><br><span class="line">&gt; FOUND KEY test</span><br><span class="line">&gt;28 DELETED</span><br><span class="line">28: going from conn_parse_cmd to conn_write</span><br><span class="line">28: going from conn_write to conn_new_cmd</span><br><span class="line">28: going from conn_new_cmd to conn_waiting</span><br><span class="line">28: going from conn_waiting to conn_read</span><br></pre></td></tr></table></figure><p>Like <a href="#create">add</a> the entry point of this command (after parsed) is <a href="/understanding-memcached-source-code-VI/#process-delete-command">process_delete_command</a> which has been fully covered in <a href="/understanding-memcached-source-code-VI">LRU III</a>. Furthermore, <code>out_string</code> is called within <code>process_delete_command</code> to trigger the <strong>state</strong> switches from <code>conn_write</code>, and back to <code>conn_new_cmd</code>.</p><h1 id="To-go"><a href="#To-go" class="headerlink" title="To go"></a>To go</h1><p><img src="/gallery/memcached-state-machine.png" alt="Memcached state machine"></p>]]></content>
    
    <summary type="html">
    
      We continue examining the other two operations, i.e., create and delete, in the event driven context. As usual, we start with a command sent to a Memcached server. In fact, most of the logic involved in this post has been discussed before such as in LRU III and Event Driven II. Hence this post will only resolve the missing parts and linking points.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="socket" scheme="https://holmeshe.me/tags/socket/"/>
    
      <category term="event driven" scheme="https://holmeshe.me/tags/event-driven/"/>
    
      <category term="state machine" scheme="https://holmeshe.me/tags/state-machine/"/>
    
      <category term="memecached" scheme="https://holmeshe.me/tags/memecached/"/>
    
  </entry>
  
  <entry>
    <title>理解 Memcached 源码 - LRU I</title>
    <link href="https://holmeshe.me/cn/understanding-memcached-source-code-IV/"/>
    <id>https://holmeshe.me/cn/understanding-memcached-source-code-IV/</id>
    <published>2019-05-17T22:28:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<p>多半情况下，<strong>LRU</strong> 会和 哈希表一起使用，然后我们把这个组合称为</p><h1 id="LRU-缓存"><a href="#LRU-缓存" class="headerlink" title="LRU 缓存"></a>LRU 缓存</h1><p>在 <strong>LRU缓存</strong> 中，哈希表提供了快速随机访问对象的能力；而<strong>LRU</strong>（算法）则用于淘汰<strong>很久没用</strong> (<strong>least recently used</strong>) 的对象，来避免缓存无限增加。我们先大致看下 <strong>LRU</strong> 组成。</p><a id="more"></a><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>从技术上来说，<strong>LRU</strong> 算法是在链表上完成的 - 当一个表项被使用（访问或更新），<strong>LRU</strong> 会先做移除，然后把它重新插入到表头。这样，越接近表尾的对象就是 <strong>越久没使用</strong> (<strong>least recently used</strong>)，淘汰起来比较简单。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>链表是不支持快速的随机访问的，所以需要和 <strong>哈希表</strong> 一起使用。之前我们之前已经读过，<strong>板</strong> 子系统的空闲列表是通过链表把 <strong>板</strong> 里的 <strong>块</strong> (chuck) 串起来形成的。在 <strong>LRU缓存</strong> 里也差不多，而这次用链表串起来的是表项。大致看起来是这样：</p><p><img src="/gallery/lru.png" alt="hash map perspective"></p><p>从另外一个维度看起来可能会更直观一点：</p><p><img src="/gallery/lru-linked-list.png" alt="linked list perspective"></p><h1 id="核心数据结构-item"><a href="#核心数据结构-item" class="headerlink" title="核心数据结构 - item"></a>核心数据结构 - item</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protected by LRU locks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">/* Rest are protected by an item lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">h_next</span>;</span>    <span class="comment">/* hash chain next */</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      time;       <span class="comment">/* least recent access */</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      exptime;    <span class="comment">/* expire time */</span></span><br><span class="line">    <span class="keyword">int</span>             nbytes;     <span class="comment">/* size of data */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  refcount;</span><br><span class="line">    <span class="keyword">uint8_t</span>         nsuffix;    <span class="comment">/* length of flags-and-length string */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         nkey;       <span class="comment">/* key length, w/terminating null and padding */</span></span><br><span class="line">    <span class="comment">/* this odd type prevents type-punning issues when we do</span></span><br><span class="line"><span class="comment">     * the little shuffle to save space when not using CAS. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">        <span class="keyword">char</span> end; <span class="comment">// scr: flexible array member indicating the item header "end"</span></span><br><span class="line">    &#125; data[];</span><br><span class="line">    <span class="comment">/* if it_flags &amp; ITEM_CAS we have 8 bytes CAS */</span></span><br><span class="line">    <span class="comment">/* then null-terminated key */</span></span><br><span class="line">    <span class="comment">/* then " flags length\r\n" (no terminating null) */</span></span><br><span class="line">    <span class="comment">/* then data with terminating \r\n (no terminating null; it's binary!) */</span></span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@item.c</text></center><h2 id="使用到的字段"><a href="#使用到的字段" class="headerlink" title="使用到的字段"></a>使用到的字段</h2><p><code>next</code>, <code>prev</code> - <strong>LRU 链表</strong> 指针, 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 初始化, 被 <a href="#item-link-q-add-to-linked-list">item_link_q</a>, <a href="#item-unlink-q-remove-from-linked-list">item_unlink_q</a> 使用。</p><p><code>h_next</code> - <em>hash 冲突链表</em> 的指针, 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 初始化, 被 <a href="#assoc-insert-add-to-hash-map">assoc_insert</a>, <a href="#assoc-delete-remove-from-hash-map">assoc_delete</a>, <a href="/understanding-memcached-source-code-II">多个模块 (LRU II)</a> 使用。</p><p><code>time</code> - 最后访问时间, 在 <a href="#do-item-link">do_item_link</a> 中设置, 被 <a href="/understanding-memcached-source-code-VI/#lru-pull-tail">lru_pull_tail (LRU III)</a> 使用。</p><p><code>exptime</code> - 超时时间（由请求参数指定）, 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 初始化, 被 <a href="/understanding-memcached-source-code-VI/#lru-pull-tail">lru_pull_tail (LRU III)</a> 使用。</p><p><code>nbytes</code> - 数据大小（由请求参数指定），在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>  初始化。</p><p><code>refcount</code> - 引用计数, 在 <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc (Slab III)</a> 初始化, 被 <a href="#do-item-link">do_item_link</a> 使用。</p><p><code>nsuffix</code> - 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 用 <code>item_make_header</code> 初始化。</p><p><code>it_flags</code> - 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 初始化, 被 <a href="#do-item-link">do_item_link</a>, <a href="#do-item-unlink">do_item_unlink</a> 使用。</p><p><code>slabs_clsid</code> - 当前对象存在的具体的 <strong>LRU 链表</strong> , 被 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 初始化, 在 <a href="#item-link-q-add-to-linked-list">item_link_q</a>, <a href="#item-unlink-q-remove-from-linked-list">item_unlink_q</a> 使用。</p><p><code>nkey</code> - 键大小, 在 <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> 中计算, 被 <a href="#assoc-delete-remove-from-hash-map">assoc_delete</a> 使用。</p><h2 id="块的内存布局"><a href="#块的内存布局" class="headerlink" title="块的内存布局"></a>块的内存布局</h2><p>我们在 <a href="/understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a> 提到过 <strong>块</strong>。这次我们直接通过数据结构来看下它的构造。</p><p><img src="/gallery/item-chunk.png" alt="item chunk"></p><p>下面我们来读直接操作 <strong>LRU</strong> 的相关代码。</p><h1 id="do-item-link"><a href="#do-item-link" class="headerlink" title="do_item_link"></a>do_item_link</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_item_link</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123; <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">    it-&gt;it_flags |= ITEM_LINKED;                <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">    it-&gt;time = current_time;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate a new CAS ID on link. */</span></span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">    assoc_insert(it, hv);                       <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    item_link_q(it);                            <span class="comment">// scr: -------------------&gt; 4)</span></span><br><span class="line">    refcount_incr(&amp;it-&gt;refcount);               <span class="comment">// scr: -------------------&gt; 5)</span></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_link@item.c</text></center><p>1) 正常理解， <code>hv</code> 应该就是哈希值 “hashed value” 的缩写。</p><p>2) 设置 <code>it-&gt;it_flags</code> 的 <code>ITEM_LINKED</code> 标志, 然后将当前时间赋值给 <code>it-&gt;time</code>。</p><p class="back"><br>The field <code>it_flags</code> is used in <a href="/understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a> and <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc</a><br></p><p>3) 将 <strong>对象</strong> 添加到哈系表。</p><p>4) 将 <strong>对象</strong> 添加到链表。</p><p>5) 递增 <em>reference count</em>。</p><p class="back"><br>这个字段的初始值是 <code>1</code>，<a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc</a><br></p><p>要注意 <em>引用计数</em> 代表了有几个子模块同时在使用该资源。这个字段是决定是否回收该资源的关键参考 （在这里，<strong>对象</strong> 同时被 <strong>板</strong> 和 <strong>LRU</strong> 在使用）。我在 <a href="/cpp-pointers/">另一篇文章</a> 里详细讨论了C++里相似的机制。</p><h2 id="item-link-q-添加至链表"><a href="#item-link-q-添加至链表" class="headerlink" title="item_link_q - 添加至链表"></a>item_link_q - 添加至链表</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_link_q">item_link_q</a> 是主力函数 <code>do_item_link_q</code> 的线程安全的简单包装。<br><br><div id="item_link_q" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">item_link_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">    do_item_link_q(it);</span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_link_q@item.c</text></center><p></p></div><p></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_item_link_q</span><span class="params">(item *it)</span> </span>&#123; <span class="comment">/* item is the new head */</span></span><br><span class="line">    item **head, **tail;</span><br><span class="line">    assert((it-&gt;it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    head = &amp;heads[it-&gt;slabs_clsid];           <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">    tail = &amp;tails[it-&gt;slabs_clsid];</span><br><span class="line">    assert(it != *head);</span><br><span class="line">    assert((*head &amp;&amp; *tail) || (*head == <span class="number">0</span> &amp;&amp; *tail == <span class="number">0</span>));</span><br><span class="line">    it-&gt;prev = <span class="number">0</span>;                             <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">    it-&gt;next = *head;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it;</span><br><span class="line">    *head = it;</span><br><span class="line">    <span class="keyword">if</span> (*tail == <span class="number">0</span>) *tail = it;</span><br><span class="line">    sizes[it-&gt;slabs_clsid]++;                 <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_link_q@item.c</text></center><p>1) 从对应的 <strong>LRU 链表</strong> （由<code>slabs_clsid</code>指定）获取 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">head</a> 和 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">tail</a>。注意 <code>slabs_clsid</code> 是用队列类型加过盐的，所以每个 <strong>板组</strong> 可能会包含复数个列表。</p><p>2) 标准动作，”添加表头项”。</p><p>3) 增加全局的数组 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">大小</a>。</p><div id="globals" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item *heads[LARGEST_ID];</span><br><span class="line"><span class="keyword">static</span> item *tails[LARGEST_ID];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> sizes[LARGEST_ID];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item.c:59</text></center><br></div><h2 id="assoc-insert-添加至哈希表"><a href="#assoc-insert-添加至哈希表" class="headerlink" title="assoc_insert - 添加至哈希表"></a>assoc_insert - 添加至哈希表</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">assoc_insert</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123; <span class="comment">// scr: again, hv -&gt; hash value</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;h_next = primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr:  1)</span></span><br><span class="line">        primary_hashtable[hv &amp; hashmask(hashpower)] = it;         // scr:  2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_insert@assoc.c</text></center><p>1) 冲突处理。没冲突？将 <code>h_next</code> 直接设置为 <code>null</code>。</p><p>2) 将 <strong>对象</strong> 添加到 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#primary_hashtable">primary_hashtable</a> 的桶。</p><div id="primary_hashtable" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> item** primary_hashtable = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc.c:42</text></center><br></div><p>扩容的逻辑先留个坑，<a href="/understanding-memcached-source-code-V/#Scale-up-amp-entry-migration">下篇</a> 再来讲。</p><h1 id="do-item-unlink"><a href="#do-item-unlink" class="headerlink" title="do_item_unlink"></a>do_item_unlink</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_unlink</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it-&gt;nkey, it-&gt;nbytes);</span><br><span class="line">    <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_LINKED;         <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">        assoc_delete(ITEM_key(it), it-&gt;nkey, hv); <span class="comment">// scr: ---------------&gt; 2)</span></span><br><span class="line">        item_unlink_q(it);                    <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">        do_item_remove(it);                   <span class="comment">// scr: -------------------&gt; *)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@item.c</text></center><p>1) 清除 <code>it-&gt;it_flags</code> 的 <code>ITEM_LINKED</code> 位。</p><p>2) 从哈希表移除 <strong>对象</strong>。</p><p>3) 从链表移除 <strong>对象</strong>。</p><p>*) 实际释放 <strong>对象</strong> 的逻辑后面会讲。</p><h2 id="item-unlink-q-从链表移除"><a href="#item-unlink-q-从链表移除" class="headerlink" title="item_unlink_q - 从链表移除"></a>item_unlink_q - 从链表移除</h2><p>同上，<a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_unlink_q">item_unlink_q</a> 只是一个对于实调函数 <code>do_item_unlink_q</code> 线程安全的简单封装。</p><div id="item_unlink_q" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">item_link_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">    do_item_link_q(it);</span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_unlink_q@item.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_item_unlink_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    item **head, **tail;</span><br><span class="line">    head = &amp;heads[it-&gt;slabs_clsid];           <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">    tail = &amp;tails[it-&gt;slabs_clsid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*head == it) &#123;                        <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">        assert(it-&gt;prev == <span class="number">0</span>);</span><br><span class="line">        *head = it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*tail == it) &#123;</span><br><span class="line">        assert(it-&gt;next == <span class="number">0</span>);</span><br><span class="line">        *tail = it-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(it-&gt;next != it);</span><br><span class="line">    assert(it-&gt;prev != it);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;prev) it-&gt;prev-&gt;next = it-&gt;next;</span><br><span class="line">    sizes[it-&gt;slabs_clsid]--;                 <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink_q@item.c</text></center><p>1) 同样, 获取 由 <code>slabs_clsid</code> 指定的 <strong>LUR 链表</strong> 的 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">head</a> 和 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">tail</a>。 </p><p>2) 标准的 “移除链表项” 操作。</p><p>3) 减少全局的数组 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">大小</a>。</p><div id="globals1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item *heads[LARGEST_ID];</span><br><span class="line"><span class="keyword">static</span> item *tails[LARGEST_ID];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> sizes[LARGEST_ID];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item.c:59</text></center><br></div><h2 id="assoc-delete-从哈希表移除"><a href="#assoc-delete-从哈希表移除" class="headerlink" title="assoc_delete - 从哈希表移除"></a>assoc_delete - 从哈希表移除</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item** _hashitem_before (<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv) &#123;</span><br><span class="line">    item **pos;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = &amp;primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr: -----&gt; 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*pos &amp;&amp; ((nkey != (*pos)-&gt;nkey) || <span class="built_in">memcmp</span>(key, ITEM_key(*pos), nkey))) &#123;</span><br><span class="line">        pos = &amp;(*pos)-&gt;h_next; <span class="comment">// scr: ----------------------------------&gt; 2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assoc_delete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    item **before = _hashitem_before(key, nkey, hv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*before) &#123;</span><br><span class="line">        item *nxt;</span><br><span class="line">...</span><br><span class="line">        nxt = (*before)-&gt;h_next; <span class="comment">// scr: --------------------------------&gt; 3)</span></span><br><span class="line">        (*before)-&gt;h_next = <span class="number">0</span>;   <span class="comment">/* probably pointless, but whatever. */</span></span><br><span class="line">        *before = nxt; <span class="comment">// scr: ------------------------------------------&gt; 4)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Note:  we never actually get here.  the callers don't delete things</span></span><br><span class="line"><span class="comment">       they can't find. */</span></span><br><span class="line">    assert(*before != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_delete@assoc.c</text></center><p>1) 通过 <code>hv</code> 获取桶。</p><p>2) 遍历冲突链表并比较 <code>key</code>。注意这里的返回值是 <strong>指定元素上一个元素的 <code>next</code> 字段的地址</strong>。而当没有冲突时，这个地址就是桶本身。</p><p>3) 将找到的下一个元素赋值给 <code>nxt</code>。</p><p>4) 更新 <strong>指定元素上一个元素的 <code>next</code> 字段</strong>。</p><h1 id="打包带走"><a href="#打包带走" class="headerlink" title="打包带走"></a>打包带走</h1><p>试下<a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">这个</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多半情况下，&lt;strong&gt;LRU&lt;/strong&gt; 会和 哈希表一起使用，然后我们把这个组合称为&lt;/p&gt;
&lt;h1 id=&quot;LRU-缓存&quot;&gt;&lt;a href=&quot;#LRU-缓存&quot; class=&quot;headerlink&quot; title=&quot;LRU 缓存&quot;&gt;&lt;/a&gt;LRU 缓存&lt;/h1&gt;&lt;p&gt;在 &lt;strong&gt;LRU缓存&lt;/strong&gt; 中，哈希表提供了快速随机访问对象的能力；而&lt;strong&gt;LRU&lt;/strong&gt;（算法）则用于淘汰&lt;strong&gt;很久没用&lt;/strong&gt; (&lt;strong&gt;least recently used&lt;/strong&gt;) 的对象，来避免缓存无限增加。我们先大致看下 &lt;strong&gt;LRU&lt;/strong&gt; 组成。&lt;/p&gt;
    
    </summary>
    
      <category term="Memcached 源码分析" scheme="https://holmeshe.me/categories/Memcached-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="LRU" scheme="https://holmeshe.me/tags/LRU/"/>
    
      <category term="源码" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码分析" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="缓存" scheme="https://holmeshe.me/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>理解 Memcached 源码 - Slab III</title>
    <link href="https://holmeshe.me/cn/understanding-memcached-source-code-III/"/>
    <id>https://holmeshe.me/cn/understanding-memcached-source-code-III/</id>
    <published>2019-03-24T02:30:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<p>上次我们看完了内存分配，以及形成待分配列表（<em>free list</em>，即<code>slots</code>）的过程。本篇我们继续查看如何使用建立好的数据结构来分配/回收块内存，并将它们用于存储<strong>对象</strong>。</p><h1 id="板配给"><a href="#板配给" class="headerlink" title="板配给"></a>板配给</h1><p>首先，我们来看</p><h2 id="do-slabs-alloc"><a href="#do-slabs-alloc" class="headerlink" title="do_slabs_alloc"></a>do_slabs_alloc</h2><a id="more"></a><p class="back"><br>这个函数对应讨论过的<a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>.<br></p><p>这里<code>do_slabs_alloc</code>的“公有”接口是<a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_alloc">slabs_alloc</a>。<a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_alloc">slabs_alloc</a>除了提供了对外接口外，还对核心数据结构加了线程锁以保证此函数（在<strong>Memcached</strong>被配置为多线程时，<a href="#" onclick="return false;" data-toggle="collapse" data-target="#multithreaded">multithreaded</a>）线程安全。</p><div id="slabs_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">slabs_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">int</span> *total_chunks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;slabs_lock);</span><br><span class="line">    ret = do_slabs_alloc(size, id, total_chunks, flags);</span><br><span class="line">    pthread_mutex_unlock(&amp;slabs_lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_alloc@slabs.c</text></center><br></div><div id="multithreaded" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            settings.num_threads = atoi(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Number of threads must be greater than 0\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* There're other problems when you get above 64 threads.</span></span><br><span class="line"><span class="comment">             * In the future we should portably detect # of cores for the</span></span><br><span class="line"><span class="comment">             * default.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &gt; <span class="number">64</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting a high number of worker"</span></span><br><span class="line">                                <span class="string">"threads is not recommended.\n"</span></span><br><span class="line">                                <span class="string">" Set this value to the number of cores in"</span></span><br><span class="line">                                <span class="string">" your machine or less.\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5572</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">do_slabs_alloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">int</span> *total_chunks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p;</span><br><span class="line">    <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br><span class="line">    p = &amp;slabclass[id]; <span class="comment">// scr: ----------------------------------------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (total_chunks != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *total_chunks = p-&gt;slabs * p-&gt;perslab; <span class="comment">// scr: -----------------&gt; 2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* fail unless we have space at the end of a recently allocated page,</span></span><br><span class="line"><span class="comment">       we have something on our freelist, or we could allocate a new page */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sl_curr == <span class="number">0</span> &amp;&amp; flags != SLABS_ALLOC_NO_NEWPAGE) &#123; <span class="comment">// scr: --&gt; *)</span></span><br><span class="line">        do_slabs_newslab(id); <span class="comment">// scr: ----------------------------------&gt; 3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sl_curr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* return off our freelist */</span></span><br><span class="line">        it = (item *)p-&gt;slots; <span class="comment">// scr: ---------------------------------&gt; 4)</span></span><br><span class="line">        p-&gt;slots = it-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Kill flag and initialize refcount here for lock safety in slab</span></span><br><span class="line"><span class="comment">         * mover's freeness detection. */</span></span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_SLABBED; <span class="comment">// scr: -------------------------&gt; 5)</span></span><br><span class="line">        it-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">        p-&gt;sl_curr--;</span><br><span class="line">        ret = (<span class="keyword">void</span> *)it; <span class="comment">// scr: --------------------------------------&gt; 6)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_alloc@slabs.c</text></center><p>1）<code>id</code>代表 <strong>板组</strong>。之前提到过，不同大小的对象会用不同的 <strong>板组</strong> 来存储。换句话说，<code>id</code> 的值由<em>对象大小</em>决定。这个过程后面会讨论。</p><p>2）<code>total_chunks</code> 是出参，用于存储当前 <strong>板组</strong> 的空闲<em>内存块</em>（<em>memory chunk</em>），或者说是待分配列表里还有多少空位。<code>if (total_chunks != NULL)</code> 则说明这个是可选参数。</p><p>*）和字面意思一样，<code>SLABS_ALLOC_NO_NEWPAGE</code>（<code>flags</code>）即使在没有空闲内存块时也不会额外分配新的 <strong>板</strong> 来满足后续分配需要。这个选项并不属于<em>对象分配</em>的通常路径，所以暂时忽略。</p><p>3）没有空闲内存块时分配新 <strong>板</strong>。这里很容易看到<code>p-&gt;sl_curr</code> 表示空闲<em>内存块</em>的数量。这个变量的值会在每次调用这个函数时递减（看第5步）。</p><p class="back"><br>另一方面, 这个字段在<a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>里自增。 注意 <em>new slab</em> 在<a href="../understanding-memcached-source-code-II/#New-slab">这篇</a>也提到过。<br></p><p>4）从待分配列表（<em>free list</em>，即<em>slots</em>）表头干掉一个元素（<strong>f</strong>），并将其赋值给<code>it</code>。</p><p class="back"><br>在<a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>, 内存块也是从表头加入的。<br></p><p>5) 清除对应<em>内存块</em>(<strong>f</strong>)的<code>ITEM_SLABBED</code>标志，将引用次数设置为1，并且内存块的数量<code>p-&gt;sl_curr</code> 减少<code>1</code>。</p><p class="back"><br>同样，这个标志在<a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>中被设置。<br></p><p>6) 返回(<strong>f</strong>).</p><p>下面我们来看如何通过对象大小来决定id，对应的函数是</p><h2 id="slabs-clsid"><a href="#slabs-clsid" class="headerlink" title="slabs_clsid"></a>slabs_clsid</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">slabs_clsid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = POWER_SMALLEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; slabclass[res].size)</span><br><span class="line">        <span class="keyword">if</span> (res++ == power_largest)     <span class="comment">/* won't fit in the biggest slab */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_alloc@slabs.c</text></center><p><code>slabs_clsid</code> 主要由一个 <code>while</code> 循环组成，这个循环会渐次找到最小的 <strong>板组</strong> 来刚好达到申请对象的大小要求。这个函数是在 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_alloc">do_item_alloc</a> 中先于 <code>slabs_alloc</code> 被调用。 我们会在后面的文章中讨论 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_alloc">do_item_alloc</a>。</p><div id="do_item_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">do_item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">rel_time_t</span> exptime, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id = slabs_clsid(ntotal);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">        it = slabs_alloc(ntotal, id, &amp;total_chunks, <span class="number">0</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_alloc@items.c</text></center><br></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次我们看完了内存分配，以及形成待分配列表（&lt;em&gt;free list&lt;/em&gt;，即&lt;code&gt;slots&lt;/code&gt;）的过程。本篇我们继续查看如何使用建立好的数据结构来分配/回收块内存，并将它们用于存储&lt;strong&gt;对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&quot;板配给&quot;&gt;&lt;a href=&quot;#板配给&quot; class=&quot;headerlink&quot; title=&quot;板配给&quot;&gt;&lt;/a&gt;板配给&lt;/h1&gt;&lt;p&gt;首先，我们来看&lt;/p&gt;
&lt;h2 id=&quot;do-slabs-alloc&quot;&gt;&lt;a href=&quot;#do-slabs-alloc&quot; class=&quot;headerlink&quot; title=&quot;do_slabs_alloc&quot;&gt;&lt;/a&gt;do_slabs_alloc&lt;/h2&gt;
    
    </summary>
    
      <category term="Memcached 源码分析" scheme="https://holmeshe.me/categories/Memcached-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="源码" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码分析" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>理解 Memcached 源码- Slab II</title>
    <link href="https://holmeshe.me/cn/understanding-memcached-source-code-II/"/>
    <id>https://holmeshe.me/cn/understanding-memcached-source-code-II/</id>
    <published>2019-03-23T22:23:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<p>这次我们继续看用于 <strong>板</strong> 的内存是如何分配的。</p><p>首先我们继续看 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init">slabs_init</a> 的两个实参。第一个是 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_maxbytes">settings.maxbytes</a> - 控制这个 <strong>Memcached</strong> 实例可以使用的总内存大小。在传入 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init">slabs_init</a> 之前，这个参数被赋值为全局变量 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#mem_limit">mem_limit</a>。</p><a id="more"></a><div id="slabs_init" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    mem_limit = limit; <span class="comment">// scr: here</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@memcached.c</text></center><br></div><div id="settings_maxbytes" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">  settings.maxbytes = <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">/* default is 64MB */</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">            settings.maxbytes = ((<span class="keyword">size_t</span>)atoi(optarg)) * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:210,5493</text></center><br></div><div id="mem_limit" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> mem_limit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:43</text></center><br></div><p>另外一个怎是 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#preallocate">preallocate</a>。它决定了是否为（各个）<strong>板组</strong> 预分配 内存。这个参数的值由 <code>L</code> 命令行参数来决定。</p><div id="preallocate" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="keyword">bool</span> preallocate = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span> :</span><br><span class="line">            <span class="keyword">if</span> (enable_large_pages() == <span class="number">0</span>) &#123;</span><br><span class="line">                preallocate = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot enable large pages on this system\n"</span></span><br><span class="line">                    <span class="string">"(There is no Linux support as of this version)\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5350,5597</text></center><br></div><p>下面我们来看 slabs 的内存分配函数。</p><h1 id="新建板"><a href="#新建板" class="headerlink" title="新建板"></a>新建板</h1><h2 id="do-slabs-newslab"><a href="#do-slabs-newslab" class="headerlink" title="do_slabs_newslab"></a>do_slabs_newslab</h2><p>具体来说，这个函数用于给 <strong>板组</strong> 分配大小为1M的内存块。而 <strong>板组</strong> 由参数 <code>id</code> 指定。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_slabs_newslab</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id]; <span class="comment">// scr: ----------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">slabclass_t</span> *g = &amp;slabclass[SLAB_GLOBAL_PAGE_POOL]; <span class="comment">// scr: ---------&gt; *)</span></span><br><span class="line">    <span class="keyword">int</span> len = settings.slab_reassign ? settings.item_size_max <span class="comment">// scr: ---&gt; 2)</span></span><br><span class="line">        : p-&gt;size * p-&gt;perslab;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mem_limit &amp;&amp; mem_malloced + len &gt; mem_limit &amp;&amp; p-&gt;slabs &gt; <span class="number">0</span> <span class="comment">// -&gt; 3)</span></span><br><span class="line">         &amp;&amp; g-&gt;slabs == <span class="number">0</span>)) &#123;</span><br><span class="line">        mem_limit_reached = <span class="literal">true</span>;</span><br><span class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((grow_slab_list(id) == <span class="number">0</span>) || <span class="comment">// scr: ----------------------------&gt; 4)</span></span><br><span class="line">        (((ptr = get_page_from_global_pool()) == <span class="literal">NULL</span>) &amp;&amp; <span class="comment">// scr: -------&gt; *)</span></span><br><span class="line">        ((ptr = memory_allocate((<span class="keyword">size_t</span>)len)) == <span class="number">0</span>))) &#123; <span class="comment">// scr: ---------&gt; 5)</span></span><br><span class="line"></span><br><span class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ptr, <span class="number">0</span>, (<span class="keyword">size_t</span>)len);</span><br><span class="line">    split_slab_page_into_freelist(ptr, id); <span class="comment">// scr: ---------------------&gt; 6)</span></span><br><span class="line"></span><br><span class="line">    p-&gt;slab_list[p-&gt;slabs++] = ptr; <span class="comment">// scr: -----------------------------&gt; 7)</span></span><br><span class="line">    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_newslab@slabs.c</text></center><p>1）<code>slabclass[id]</code> 是 <strong>板组</strong> 的数据结构。<a href="../understanding-memcached-source-code-I/#Module-initialization">上篇</a>讨论了这个数组的初始化。</p><p>2）<a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_slab_reassign">settings.slab_reassign</a> 决定是否启用 再平衡 策略。如果启用，未使用的 <strong>板</strong> 不会被立即释放，而是分配给其他 <strong>板组</strong> 使用，这就产生了一个问题，即所有 <strong>板组</strong> 都需要使用统一大小的 <strong>板</strong>。所以这个设置同时也决定了是否使用 <em>同种板</em> （大小为 <code>settings.item_size_max</code>，或者上述的1M），还是 <em>异种板</em> （<code>p-&gt;size * p-&gt;perslab</code>）。除了用命令行参数 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_slab_reassign">"slab_reassign"</a> 以外，<a href="#" onclick="return false;" data-toggle="collapse" data-target="#modern">"modern"</a> 也会设置这个值，而本文也会用1M作为 <strong>板</strong> 的大小。</p><div id="settings_slab_reassign" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    settings.slab_reassign = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> SLAB_REASSIGN:</span><br><span class="line">                settings.slab_reassign = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:238,5694</text></center><br></div><div id="modern" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> MODERN:</span><br><span class="line">                <span class="comment">/* Modernized defaults. Need to add equivalent no_* flags</span></span><br><span class="line"><span class="comment">                 * before making truly default. */</span></span><br><span class="line">                settings.slab_reassign = <span class="literal">true</span>;</span><br><span class="line">                settings.slab_automove = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5820</text></center><br></div><a href="#" id="nb_rebalancing" style="visibility: hidden"></a><p>N.b. *, <em>rebalancing mechanism</em> will be discussed later when we have a better understanding of the LRU module. </p><a href="#" id="do_slabs_newslab_mem_limit" style="visibility: hidden"></a><p>3）检查内存使用是否超出上线。</p><p>4）<a href="#" onclick="return false;" data-toggle="collapse" data-target="#grow_slab_list">grow_slab_list</a> 检查是否增长 <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slab_list</a>，如果需要，则增长之。</p><div id="grow_slab_list" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">grow_slab_list</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id];</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;slabs == p-&gt;list_size) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> new_size =  (p-&gt;list_size != <span class="number">0</span>) ? p-&gt;list_size * <span class="number">2</span> : <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">void</span> *new_list = <span class="built_in">realloc</span>(p-&gt;slab_list, new_size * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">        <span class="keyword">if</span> (new_list == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p-&gt;list_size = new_size;</span><br><span class="line">        p-&gt;slab_list = new_list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">grow_slab_list@slabs.c</text></center><br></div><p>5）<a href="#" onclick="return false;" data-toggle="collapse" data-target="#memory_allocate">memory_allocate</a> 是真正分配 <strong>板</strong> 内存的函数。如上述，这里的 <code>len</code> 是1M。</p><div id="memory_allocate" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">memory_allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* We are not using a preallocated large memory chunk */</span></span><br><span class="line">        ret = <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: when preallocate is set to true</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memory_allocate@slabs.c</text></center><br></div><p>6）<code>split_slab_page_into_freelist</code> 初始化 （或者是 free）刚刚分配的 <strong>板</strong> 内存用作对象存储。这个函数会在下一节讨论。</p><p>7) 将刚刚分配的 <strong>板</strong> 加入到 <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slab_list</a>.</p><p>下图总结了这个过程（我们想象 <code>do_slabs_newslab(n)</code> 被调用了两次）</p><p><img src="../../gallery/slab_alloc.png" alt="new slabs"></p><p>接下来我们来看在第6）步中一块 <strong>板</strong> 是如何被初始化的。</p><h2 id="split-slab-page-into-freelist"><a href="#split-slab-page-into-freelist" class="headerlink" title="split_slab_page_into_freelist"></a>split_slab_page_into_freelist</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_slab_page_into_freelist</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id];</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; p-&gt;perslab; x++) &#123;</span><br><span class="line">        do_slabs_free(ptr, <span class="number">0</span>, id);</span><br><span class="line">        ptr += p-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">split_slab_page_into_freelist@slabs.c</text></center><p>这个函数会遍历 <strong>板</strong> 里的所有 <strong>块</strong>（<a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.size</a>），然后调用 <code>do_slabs_free</code> 来初始化每个 <strong>块</strong> 的元数据。换一个说法，就是 “拆分 slab到待分配列表”-“split a slab into item free list”。你也许已经猜到了，这个 <em>待分配列表</em> 会被直接用于 <strong>对象</strong>分配，这个过程后面会详细讨论。</p><h2 id="do-slabs-free"><a href="#do-slabs-free" class="headerlink" title="do_slabs_free"></a>do_slabs_free</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_slabs_free</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p;</span><br><span class="line">    item *it;</span><br><span class="line">...</span><br><span class="line">    p = &amp;slabclass[id];</span><br><span class="line"></span><br><span class="line">    it = (item *)ptr;</span><br><span class="line">    it-&gt;it_flags = ITEM_SLABBED; <span class="comment">// scr: ---------------&gt; 1)</span></span><br><span class="line">    it-&gt;slabs_clsid = <span class="number">0</span>;</span><br><span class="line">    it-&gt;prev = <span class="number">0</span>; <span class="comment">// scr: ------------------------------&gt; 2)</span></span><br><span class="line">    it-&gt;next = p-&gt;slots;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it;</span><br><span class="line">    p-&gt;slots = it;</span><br><span class="line"></span><br><span class="line">    p-&gt;sl_curr++; <span class="comment">// scr: ------------------------------&gt; 3)</span></span><br><span class="line">    p-&gt;requested -= size;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_free@slabs.c</text></center><p>技术上讲，这个函数处理的 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item">元数据</a> 元数据存在于每个 <strong>块</strong>的开始。</p><div id="item" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protected by LRU locks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></span><br><span class="line">...</span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5820</text></center><br></div><p>1）初始化一些域。这里 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item">item</a> 是另一个核心数据结构，后续会讨论。</p><p>2）将 <strong>item</strong> 加入到上述的 待分配列表 ，并且更新链表表头，<a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slots</a>。</p><p>3）更新可分配项目数量，<a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.sl_curr</a>；并且更新 <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.requested</a> 负责统计。注意这里并没有真正的释放对象，所以传入的 <code>size</code> 是<code>0</code>。</p><p><img src="../../gallery/slab_free_list.png" alt="free list"></p><h1 id="板预分配"><a href="#板预分配" class="headerlink" title="板预分配"></a>板预分配</h1><p>下面我们来看 <code>do_slabs_newslab</code> 怎么使用。其中一个地方是之前看到过的 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init_1">slabs_init</a>（<code>preallocate</code> 设置为 <code>true</code>），</p><div id="slabs_init_1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (prealloc) &#123;</span><br><span class="line">        slabs_preallocate(power_largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@slabs.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slabs_preallocate</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> maxslabs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prealloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pre-allocate a 1MB slab in every size class so people don't get</span></span><br><span class="line"><span class="comment">       confused by non-intuitive "SERVER_ERROR out of memory"</span></span><br><span class="line"><span class="comment">       messages.  this is the most common question on the mailing</span></span><br><span class="line"><span class="comment">       list.  if you really don't want this, you can rebuild without</span></span><br><span class="line"><span class="comment">       these three lines.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = POWER_SMALLEST <span class="comment">/* scr: 1 */</span>; i &lt; MAX_NUMBER_OF_SLAB_CLASSES; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++prealloc &gt; maxslabs)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (do_slabs_newslab(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error while preallocating slab memory!\n"</span></span><br><span class="line">                <span class="string">"If using -L or other prealloc options, max memory must be "</span></span><br><span class="line">                <span class="string">"at least %d megabytes.\n"</span>, power_largest);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_preallocate@slabs.c</text></center><p>这个方法从<a href="#" onclick="return false;" data-toggle="collapse" data-target="#defines">POWER_SMALLEST</a>（1）开始遍历所有的  <a href="../understanding-memcached-source-code-I/#core_ds">slabclass</a>，然后给每个 <strong>板组</strong> 预分配一个 <strong>板</strong>。（下标为<a href="#" onclick="return false;" data-toggle="collapse" data-target="#defines">0th</a> 的 <strong>板组</strong> 是一个特殊的组，存储空闲的 <strong>板</strong> 用于上面提到的 <em>再平衡</em> 策略）。</p><div id="defines" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_SMALLEST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_LARGEST 256 <span class="comment">/* actual cap is 255 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLAB_GLOBAL_PAGE_POOL 0 <span class="comment">/* magic slab class for storing pages for reassignment */</span></span></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.h:88</text></center><br></div><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>和<a href="../understanding-memcached-source-code-I/#References">上文</a>一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我们继续看用于 &lt;strong&gt;板&lt;/strong&gt; 的内存是如何分配的。&lt;/p&gt;
&lt;p&gt;首先我们继续看 &lt;a href=&quot;#&quot; onclick=&quot;return false;&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#slabs_init&quot;&gt;slabs_init&lt;/a&gt; 的两个实参。第一个是 &lt;a href=&quot;#&quot; onclick=&quot;return false;&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#settings_maxbytes&quot;&gt;settings.maxbytes&lt;/a&gt; - 控制这个 &lt;strong&gt;Memcached&lt;/strong&gt; 实例可以使用的总内存大小。在传入 &lt;a href=&quot;#&quot; onclick=&quot;return false;&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#slabs_init&quot;&gt;slabs_init&lt;/a&gt; 之前，这个参数被赋值为全局变量 &lt;a href=&quot;#&quot; onclick=&quot;return false;&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#mem_limit&quot;&gt;mem_limit&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Memcached 源码分析" scheme="https://holmeshe.me/categories/Memcached-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="source code analysis" scheme="https://holmeshe.me/tags/source-code-analysis/"/>
    
      <category term="源码" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码分析" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>理解 Memcached 源码- Slab I</title>
    <link href="https://holmeshe.me/cn/understanding-memcached-source-code-I/"/>
    <id>https://holmeshe.me/cn/understanding-memcached-source-code-I/</id>
    <published>2019-03-22T23:30:00.000Z</published>
    <updated>2020-12-22T10:48:38.109Z</updated>
    
    <content type="html"><![CDATA[<p>Slab分配器是这个缓存系统的核心，并在很大程度上决定了核心资源 - 内存 - 的利用效率。其它的三个部分，用来淘汰（超时）对象的LRU算法；和基于libevent的事件驱动；以及用于分布数据的一致性哈希，可以看作是围绕Slab来开发的。</p><p>在其他系统，比如内核，都能看到 Slab 分配器 的身影。无论它出现在哪里，都是为了对抗同一个性能问题，内存碎片。而本文就主要讨论 Slab 分配器 在memcached 中的实现（废话）。</p><p><strong>memcached version: 1.4.28</strong></p><p>首先我们来回答一些问题。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="啥是Slab"><a href="#啥是Slab" class="headerlink" title="啥是Slab"></a>啥是Slab</h2><p><strong>Slab</strong>翻译过来就是（一块）<strong>板</strong>，具体来说，它是是被预先分配好的，大小为1M的内存块。这些 <strong>板</strong> 可以被进一步分割成一些相同大小的 <strong>块</strong> (<strong>chunk</strong>)，对象就存写在每一个 <strong>块</strong> 上面。所有的 <strong>板</strong> 会根据所存储对象的大小分成 <strong>板组</strong>（<strong>slab class</strong>）。</p><h2 id="刚刚提到的内存碎片是啥"><a href="#刚刚提到的内存碎片是啥" class="headerlink" title="刚刚提到的内存碎片是啥"></a>刚刚提到的内存碎片是啥</h2><p>具体来说，<strong>板分配器</strong> 解决的其实是 内在碎片 （internal memory fragmentation）。这种碎片存在于分配的内存单元的内部。拿内核来说，内存的分配单元叫页（page），所有的内存分配的请求本质上都是在页里面拿走一块，同时产生的碎片也就自然产生于每页的内部了。</p><blockquote><p>和内在碎片不一样，外在碎片（external memory fragmentation）则存在于分配的内存单元之间。解决外在碎片的一般做法则是用buddy，就不在本文范围内了。</p></blockquote><p>我们再看下制造内存碎片过程，</p><p>1）malloc一堆小对象，</p><p>2）随机free一些上述小对象。</p><p>于是本来是整片的内存就会出现很多空洞，这些空洞，或者说碎片，因为太小而且分散，大概率永远无法被后续的malloc利用。</p><h2 id="内存碎片引起的问题"><a href="#内存碎片引起的问题" class="headerlink" title="内存碎片引起的问题"></a>内存碎片引起的问题</h2><p>继续往后说。这些碎片由于不能被 malloc 使用，基本也就和 内存泄漏 差不多了。引发的具体问题也差不多 - 定期重启。</p><h2 id="怎么办"><a href="#怎么办" class="headerlink" title="怎么办"></a>怎么办</h2><p><strong>板分配器</strong> 并不消除内存碎片，而是将它们收敛起来，并锁定在某个固定的内存区域。具体来说，1）将大小相近的对象分<strong>组</strong>；2）同一<strong>组</strong>的的对象只会用对应的<strong>板组</strong>（<strong>slab class</strong>）来分配内存。</p><p>接下来看代码。</p><p><strong>reminder: memcached version is 1.4.28</strong></p><p>核心数据结构：</p><a href="#" id="core_ds" style="visibility: hidden"></a><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;      <span class="comment">/* sizes of items */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> perslab;   <span class="comment">/* how many items per slab */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *slots;           <span class="comment">/* list of item ptrs */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sl_curr;   <span class="comment">/* total free items in list */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> slabs;     <span class="comment">/* how many slabs were allocated for this class */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> **slab_list;       <span class="comment">/* array of slab pointers */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> list_size; <span class="comment">/* size of prev array */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> requested; <span class="comment">/* The number of requested bytes */</span></span><br><span class="line">&#125; <span class="keyword">slabclass_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">slabclass_t</span> slabclass[MAX_NUMBER_OF_SLAB_CLASSES];</span><br><span class="line"></span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabclass_t@slabs.c</text></center><h1 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h1><p>本节我们来看<code>slabs_init</code>，和 <code>slabclass[MAX_NUMBER_OF_SLAB_CLASSES]</code> 的初始化。 这个函数主要给 <code>slabclass_t.size ，和 slabclass_t.perslab</code> 赋值。第一个域表示 <code>Slab</code> 组 所对应的对象大小，第二个域则表示一个 <code>Slab</code> 上可以放多少个该类的对象。最后，<code>slabs_init</code> 是在系统初始化的过程被调用（如以下代码），</p><div id="snippet1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    assoc_init(settings.hashpower_init);</span><br><span class="line">    conn_init();</span><br><span class="line">    slabs_init(settings.maxbytes, settings.factor, preallocate,</span><br><span class="line">               use_slab_sizes ? slab_sizes : <span class="literal">NULL</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5977</text></center><br></div><p>在这个阶段，<a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_sizes">slab_sizes</a> 和 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_factor">settings.factor</a> 共同决定了后续逻辑的走向，并且确定各个 <strong>板组</strong> 所存储的对象大小，</p><div id="slab_sizes" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5372</text></center><br></div><div id="settings_factor" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.factor = <span class="number">1.25</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">settings_init@memcached.c:217</text></center><br></div><p>如果 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_sizes">slab_sizes</a> 不是 <code>NULL</code>, 用此数组的里面的值直接初始化各 <strong>板组</strong> 所对应的对象大小（支线a）；</p><p>反之，则用base size×n×settings.factor 来初始化上述的目标。这里 n 是 slabclass 的下标（支线b）。</p><p>除了写死的默认值，上述两个变量也能用 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet2">命令行参数赋值</a> 。</p><div id="snippet2" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">            settings.factor = atof(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.factor &lt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Factor must be greater than 1\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'o'</span>: <span class="comment">/* It's sub-opts time! */</span></span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> SLAB_SIZES:</span><br><span class="line">                <span class="keyword">if</span> (_parse_slab_sizes(subopts_value, slab_sizes)) &#123;</span><br><span class="line">                    use_slab_sizes = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5558, 5810</text></center><br></div><p>本函数的另外两个参数 <code>settings.maxbytes</code> 和 <code>preallocate</code> ，会在 <a href="../understanding-memcached-source-code-II">后续</a> 讨论。这里我们假设 <code>preallocate</code> 为 <code>false</code>，并忽略其对应的逻辑。</p><p>下面我们来看 <code>slabs_init</code> 本身。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = POWER_SMALLEST <span class="comment">/* scr: 1 */</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(item) + settings.chunk_size; <span class="comment">// scr: ---------&gt; b 1)</span></span><br><span class="line">...</span><br><span class="line">    <span class="built_in">memset</span>(slabclass, <span class="number">0</span>, <span class="keyword">sizeof</span>(slabclass));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (++i &lt; MAX_NUMBER_OF_SLAB_CLASSES<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slab_sizes != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: -----------------------------------&gt; a 1)</span></span><br><span class="line">            <span class="keyword">if</span> (slab_sizes[i<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            size = slab_sizes[i<span class="number">-1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt;= settings.item_size_max / factor) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Make sure items are always n-byte aligned */</span></span><br><span class="line">        <span class="keyword">if</span> (size % CHUNK_ALIGN_BYTES) <span class="comment">// scr: ---------------------------------&gt; 2)</span></span><br><span class="line">            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);</span><br><span class="line"></span><br><span class="line">        slabclass[i].size = size;</span><br><span class="line">        slabclass[i].perslab = settings.item_size_max / slabclass[i].size; <span class="comment">// -&gt; 3)</span></span><br><span class="line">        <span class="keyword">if</span> (slab_sizes == <span class="literal">NULL</span>)</span><br><span class="line">            size *= factor; <span class="comment">// scr: -----------------------------------------&gt; b 4)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"slab class %3d: chunk size %9u perslab %7u\n"</span>,</span><br><span class="line">                    i, slabclass[i].size, slabclass[i].perslab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scr: -------------------------------------------------------------------&gt; 5)</span></span><br><span class="line">    power_largest = i;</span><br><span class="line">    slabclass[power_largest].size = settings.item_size_max;</span><br><span class="line">    slabclass[power_largest].perslab = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@slabs.c</text></center><h2 id="支线-a"><a href="#支线-a" class="headerlink" title="支线 a"></a>支线 a</h2><p>1) 使用 <code>slab_sizes</code> 里面的值；</p><p>2) 将 <code>size</code> 用 <code>CHUNK_ALIGN_BYTES</code> 对其，并赋值给 <code>slabclass[i].size</code>；</p><p>3) 计算 <code>slabclass[i].perslab</code>;</p><p>5) 用 <code>settings.item_size_max</code> 初始化最后一个 <strong>板组</strong>。</p><p>这里要注意 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_item_size_max">settings.item_size_max</a> 是 <strong>slab</strong> 本身的大小，也即是 <strong>memcached</strong> 能存的最大对象。类似的，<a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_item_size_max">settings.item_size_max</a> 也可以在 <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet3">运行时</a> 确定</p><div id="settings_item_size_max" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.item_size_max = <span class="number">1024</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">settings_init@memcached.c:226</text></center><br></div><div id="snippet3" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">    buf = strdup(optarg);</span><br><span class="line">    unit = buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="string">'k'</span> || unit == <span class="string">'m'</span> ||</span><br><span class="line">        unit == <span class="string">'K'</span> || unit == <span class="string">'M'</span>) &#123;</span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        size_max = atoi(buf);</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="string">'k'</span> || unit == <span class="string">'K'</span>)</span><br><span class="line">            size_max *= <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="string">'m'</span> || unit == <span class="string">'M'</span>)</span><br><span class="line">            size_max *= <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        settings.item_size_max = size_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        settings.item_size_max = atoi(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Item max size cannot be less than 1024 bytes.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &gt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">128</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot set item size limit higher than 128 mb.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &gt; <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting item max size above 1MB is not"</span></span><br><span class="line">            <span class="string">" recommended!\n"</span></span><br><span class="line">            <span class="string">" Raising this limit increases the minimum memory requirements\n"</span></span><br><span class="line">            <span class="string">" and will decrease your memory efficiency.\n"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5626</text></center><br></div><h2 id="支线-b"><a href="#支线-b" class="headerlink" title="支线 b"></a>支线 b</h2><p>1) 用 <code>settings.chunk_size</code> 加上给每个对象附着的元数据（meta data）来计算基础大小（对象 <code>item</code> 会在后面讨论）；</p><p>2) 将 <code>size</code> 用 <code>CHUNK_ALIGN_BYTES</code> 对其，并赋值给 <code>slabclass[i].size</code>（同支线a）；</p><p>3) 计算 <code>slabclass[i].perslab</code>（同支线a）；</p><p>4) 用 <code>factor(settings.factor)</code> 计算下一个 <strong>板组</strong> 的大小；</p><p>5) 用 <code>settings.item_size_max</code> 初始化最后一个 <strong>板组</strong>。</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://github.com/memcached/memcached/wiki" target="_blank" rel="noopener">memcached wiki</a></p><p><a href="http://gihyo.jp/dev/feature/01/memcached/0002" target="_blank" rel="noopener">第2回　memcachedのメモリストレージを理解する</a></p><p><a href="https://blog.csdn.net/initphp/article/details/44888555" target="_blank" rel="noopener">Memcached源码分析之存储机制Slabs（7）</a></p><p><a href="https://gokulvasanblog.wordpress.com/2016/07/11/understanding-malloc-part1/" target="_blank" rel="noopener">Understanding Malloc</a></p><p><a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html" target="_blank" rel="noopener">Ch8 - Slab Allocator</a></p><p><a href="https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a" target="_blank" rel="noopener">The Slab Allocator:An Object-Caching Kernel Memory Allocator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Slab分配器是这个缓存系统的核心，并在很大程度上决定了核心资源 - 内存 - 的利用效率。其它的三个部分，用来淘汰（超时）对象的LRU算法；和基于libevent的事件驱动；以及用于分布数据的一致性哈希，可以看作是围绕Slab来开发的。&lt;/p&gt;
&lt;p&gt;在其他系统，比如内核，都能看到 Slab 分配器 的身影。无论它出现在哪里，都是为了对抗同一个性能问题，内存碎片。而本文就主要讨论 Slab 分配器 在memcached 中的实现（废话）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;memcached version: 1.4.28&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们来回答一些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Memcached 源码分析" scheme="https://holmeshe.me/categories/Memcached-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="源码" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="源码分析" scheme="https://holmeshe.me/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code-Event Driven II</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-VIII/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-VIII/</id>
    <published>2019-01-27T20:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="#"><text style="color:black;font-weight:bold;">, II - this article</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>In classic <em>multithreading</em>, blocking I/O operations constrain the maximum number of requests a server can handle. Hence asynchronous <strong>event driven</strong> model is used to eliminate the throughput bottleneck. As such, the synchronous and potentially slow process is divided into logic segments that are free of I/O, and are executed asynchronously.</p><p>When it comes to asynchronization, extra space is required to store <em>context</em>s. This is because the logic segments, that could be associated with different <em>session</em>s, are executed in an interleaved way. For instance, in the case when asynchronization is implemented (emulated) using synchronous <em>multithreading</em>, the “extra space” is in the form of thread stack. Whilst <em>context</em>s are maintained in user land in <strong>event driven</strong>.</p><p><code>conn</code> is the representative of those <em>context</em>s in <strong>Memcached</strong>.</p><a id="more"></a><h1 id="Core-data-structure-conn"><a href="#Core-data-structure-conn" class="headerlink" title="Core data structure - conn"></a>Core data structure - conn</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> <span class="title">conn</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>    sfd;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> conn_states  state;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">event</span>;</span></span><br><span class="line">    short  ev_flags;</span><br><span class="line">    short  which;   <span class="comment">/** which events were just triggered */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>   *rbuf;   <span class="comment">/** buffer to read commands into */</span></span><br><span class="line">    <span class="keyword">char</span>   *rcurr;  <span class="comment">/** but if we parsed some already, this is where we stopped */</span></span><br><span class="line">    <span class="keyword">int</span>    rsize;   <span class="comment">/** total allocated size of rbuf */</span></span><br><span class="line">    <span class="keyword">int</span>    rbytes;  <span class="comment">/** how much data, starting from rcur, do we have unparsed */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>   *wbuf;</span><br><span class="line">    <span class="keyword">char</span>   *wcurr;</span><br><span class="line">    <span class="keyword">int</span>    wsize;</span><br><span class="line">    <span class="keyword">int</span>    wbytes;</span><br><span class="line">    <span class="comment">/** which state to go into after finishing current write */</span></span><br><span class="line">    <span class="keyword">enum</span> conn_states  write_and_go;</span><br><span class="line">    <span class="keyword">void</span>   *write_and_free; <span class="comment">/** free this memory after finishing writing */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>   *ritem;  <span class="comment">/** when we read in an item's value, it goes here */</span></span><br><span class="line">    <span class="keyword">int</span>    rlbytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data for the nread state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * item is used to hold an item structure created after reading the command</span></span><br><span class="line"><span class="comment">     * line of set/add/replace commands, but before we finished reading the actual</span></span><br><span class="line"><span class="comment">     * data. The data is read into ITEM_data(item) to avoid extra copying.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>   *item;     <span class="comment">/* for commands set/add/replace  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data for the swallow state */</span></span><br><span class="line">    <span class="keyword">int</span>    sbytes;    <span class="comment">/* how many bytes to swallow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data for the mwrite state */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line">    <span class="keyword">int</span>    iovsize;   <span class="comment">/* number of elements allocated in iov[] */</span></span><br><span class="line">    <span class="keyword">int</span>    iovused;   <span class="comment">/* number of elements used in iov[] */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">msglist</span>;</span></span><br><span class="line">    <span class="keyword">int</span>    msgsize;   <span class="comment">/* number of elements allocated in msglist[] */</span></span><br><span class="line">    <span class="keyword">int</span>    msgused;   <span class="comment">/* number of elements used in msglist[] */</span></span><br><span class="line">    <span class="keyword">int</span>    msgcurr;   <span class="comment">/* element in msglist[] being transmitted now */</span></span><br><span class="line">    <span class="keyword">int</span>    msgbytes;  <span class="comment">/* number of bytes in current msg */</span></span><br><span class="line"></span><br><span class="line">    item   **ilist;   <span class="comment">/* list of items to write out */</span></span><br><span class="line">    <span class="keyword">int</span>    isize;</span><br><span class="line">    item   **icurr;</span><br><span class="line">    <span class="keyword">int</span>    ileft;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> protocol protocol;   <span class="comment">/* which protocol this connection speaks */</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> request_addr_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *hdrbuf; <span class="comment">/* udp packet headers */</span></span><br><span class="line">    <span class="keyword">int</span>    hdrsize;   <span class="comment">/* number of headers' worth of space is allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>   noreply;   <span class="comment">/* True if the reply should not be sent. */</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    short cmd; <span class="comment">/* current command being processed */</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> keylen;</span><br><span class="line">    conn   *next;     <span class="comment">/* Used for generating a list of conn structures */</span></span><br><span class="line">    LIBEVENT_THREAD *thread; <span class="comment">/* Pointer to the thread object serving this connection */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Properties-in-discussion"><a href="#Properties-in-discussion" class="headerlink" title="Properties in discussion"></a>Properties in discussion</h2><p><code>fd</code> - the file descriptor a <strong>event</strong> is rooted. used by <a href="../understanding-memcached-source-code-VII/">last post</a></p><p><code>state</code> - the main focus of this post</p><p><code>rbuf</code> - <em>read buffer</em> address. used by <a href="#try-read-network">try_read_network</a></p><p><code>rcurr</code> - address of unprocessed data. used by <a href="#try-read-network">try_read_network</a></p><p><code>rsize</code> - current size of the <em>read buffer</em>. used by <a href="#try-read-network">try_read_network</a></p><p><code>rbytes</code> - size of data to be processed (it is also used as an indicator for leftover data in various places). initialised by <a href="#try-read-network">try_read_network</a>, updated by <a href="#process-get-command">process_get_command</a>, used by <a href="#try-read-command">try_read_command</a></p><p><code>last_cmd_time</code> - updated when start processing a command. used by <a href="#try-read-network">try_read_network</a></p><p><code>ilist</code> - the <strong>item</strong> list that is associated with the context; <code>icurr</code> and <code>ileft</code> indicate the current entry and number of entries left. used by <a href="#process-get-command">process_get_command</a>, <a href="#Finish-read">conn_release_items</a></p><p><code>iov</code> - the actual storage for pointers of output data, which is used by <code>msglist</code>; <code>iovsize</code>, and <code>iovused</code> are its allocated size and used size respectively. initialised by <a href="#try-read-command">process_command</a>, used by <a href="#add-iov">add_iov</a>, <a href="#add-iov">ensure_iov_space</a></p><p class="back"><br>Here the data structures (<code>struct msghdr</code> and <code>struct iovec</code>) is required by <a href="http://man7.org/linux/man-pages/man3/sendmsg.3p.html" target="_blank" rel="noopener">sendmsg</a>. The relevant text about the API is pasted bellow.<br></p><blockquote><p>The msg_iov and msg_iovlen fields of message specify zero or more buffers containing the data to be sent.  msg_iov points to an array of iovec structures; msg_iovlen shall be set to the dimension of this array. In each iovec structure, the iov_base field specifies a storage area and the iov_len field gives its size in bytes. Some of these sizes can be zero. The data from each storage area indicated by msg_iov is sent in turn.<br>…</p></blockquote><p><code>msglist</code> - the list that stores the <code>struct msghdr</code> themselves; <code>msgsize</code> and <code>msgused</code> are its allocated size and used size respectively; <code>msgbytes</code> indicates totall size of the output data size; <code>msgcurr</code> points to the index that has been processed (written).</p><blockquote><p>Yet nothing is bette than a chart to demonstrate the data structures and the layout in memory.</p></blockquote><a href="#" id="fig_core_ds" style="visibility: hidden"></a><p><img src="/gallery/msglist.png" alt="msglist &amp; iov"></p><h2 id="State-switch"><a href="#State-switch" class="headerlink" title="State switch"></a>State switch</h2><p>An <strong>event</strong> triggers cascading changes of <code>state</code>s which in turn invokes various procedures, before <strong>drive machine</strong> relinquishes control and waits for a new <strong>event</strong> arrival. In <a href="../understanding-memcached-source-code-VII/">last post</a>, we have seen this process on <em>dispatch thread</em>, in which </p><p>1) <code>conn_listening</code> is triggered by a new connection;</p><p>2) <a href="/understanding-memcached-source-code-VII/#dispatch-conn-new">dispatch_conn_new</a> is invoked, which transfer the new accepted <code>fd</code>, as well as succeeding <strong>event</strong>s to one of the <em>worker thread</em>s;</p><p>3) <em>dispatch thread</em> gives up CPU and waits for new “new connection” <strong>event</strong>s.</p><p>In this post, we are going to see more complex <em>state switch</em>es that effectively link together the procedures we discussed in <a href="/understanding-memcached-source-code-VI/">LRU III</a>,</p><p class="back"><br>The <strong>state</strong> of a given session is represented by <code>conn.state</code> of its associated <em>context</em>.<br></p><p>and this time we are going to adopt a similar approach as <a href="/understanding-memcached-source-code-VI/">LRU III</a>, i.e., sending <em>telnet commands</em> to a <strong>Memcached</strong> instance, to navigate the outermost layer of the <strong>Memcached</strong> application.</p><p class="back"><br>We will also switch ON the convenient <a href="#" onclick="return false;" data-toggle="collapse" data-target="#verbose">verbose</a> with <code>-vvv</code> to better observe the internal state transitions.<br></p><div id="verbose" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">    settings.verbose++;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5518</text></center><br></div><h1 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h1><p>Firstly (as usual) we <em>telnet</em> to the <strong>Memcached</strong> instance, and add some <strong>item</strong>s</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...<span class="comment">// add some items</span></span><br><span class="line">~telnet localhost <span class="number">11211</span></span><br><span class="line">Trying <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is '^]'.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Telnet input</text></center><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;<span class="number">36</span> <span class="keyword">new</span> <span class="keyword">auto</span>-negotiating client connection</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Server verbose</text></center><p class="back"><br>Here <code>36</code> is the accepted <code>fd</code>. As mentioned, the following operations will be on this <code>fd</code>.<br></p><p>Next we send the exact same read command to the <strong>Memcached</strong> instance as in <a href="/understanding-memcached-source-code-VI/#Read">LRU III</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; get test</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Telnet input</text></center><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">36</span>: going from conn_new_cmd to conn_waiting</span><br><span class="line"><span class="number">36</span>: going from conn_waiting to conn_read</span><br><span class="line"><span class="number">36</span>: going from conn_read to conn_parse_cmd</span><br><span class="line"><span class="number">36</span>: Client <span class="keyword">using</span> the ascii protocol</span><br><span class="line">&lt;<span class="number">36</span> get test</span><br><span class="line">&gt; FOUND KEY test</span><br><span class="line">&gt;<span class="number">36</span> sending key test</span><br><span class="line">&gt;<span class="number">36</span> END</span><br><span class="line"><span class="number">36</span>: going from conn_parse_cmd to conn_mwrite</span><br><span class="line"><span class="number">36</span>: going from conn_mwrite to conn_new_cmd</span><br><span class="line"><span class="number">36</span>: going from conn_new_cmd to conn_waiting</span><br><span class="line"><span class="number">36</span>: going from conn_waiting to conn_read</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Server verbose</text></center><p>As mentioned in <a href="/understanding-memcached-source-code-VII/#event-handler">last post</a>, the initial state of <em>worker thread</em>s is</p><h2 id="conn-new-cmd"><a href="#conn-new-cmd" class="headerlink" title="conn_new_cmd"></a>conn_new_cmd</h2><p>so we get started from here.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nreqs = settings.reqs_per_event; <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_new_cmd:</span><br><span class="line">            <span class="comment">/* Only process nreqs at a time to avoid starving other</span></span><br><span class="line"><span class="comment">               connections */</span></span><br><span class="line">            --nreqs; <span class="comment">// scr: ----------------------------&gt; 1)</span></span><br><span class="line">            <span class="keyword">if</span> (nreqs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                reset_cmd_handler(c); <span class="comment">// scr: -----------&gt; 2)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;c-&gt;thread-&gt;stats.mutex);</span><br><span class="line">                c-&gt;thread-&gt;stats.conn_yields++;</span><br><span class="line">                pthread_mutex_unlock(&amp;c-&gt;thread-&gt;stats.mutex);</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;rbytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">                &#125;</span><br><span class="line">                stop = <span class="literal">true</span>; <span class="comment">// scr: --------------------&gt; 3)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset_cmd_handler</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;cmd = <span class="number">-1</span>;</span><br><span class="line">    c-&gt;substate = bin_no_state;</span><br><span class="line">    <span class="keyword">if</span>(c-&gt;item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        item_remove(c-&gt;item);</span><br><span class="line">        c-&gt;item = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    conn_shrink(c);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;rbytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        conn_set_state(c, conn_parse_cmd); <span class="comment">// scr: -----&gt; 2a)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        conn_set_state(c, conn_waiting); <span class="comment">// scr: -------&gt; 2b)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4361 & reset_cmd_handler</text></center><p>1) <code>nreqs</code> (<a href="#" onclick="return false;" data-toggle="collapse" data-target="#reqs_per_event">settings.reqs_per_event</a>) is the maximum requests one <em>event loop</em> iteration should handle. Note that the threshold is needed because new connections will not be handled if one <em>event loop</em> iteration takes too long to complete. Note also that the connection being interrupted will be fired again and get the chance to enter the <strong>drive machine</strong> with a “read” event since the descriptor is set with <code>EV_PERSIST</code> in the <a href="/understanding-memcached-source-code-VII/#event-handler">last post</a>.</p><div id="reqs_per_event" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.reqs_per_event = <span class="number">20</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">    settings.reqs_per_event = atoi(optarg);</span><br><span class="line">    <span class="keyword">if</span> (settings.reqs_per_event == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Number of requests per event must be greater than 0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5545, 6112</text></center><br></div><p>2) Initializes the relevant properties in the <em>context</em> for a new command.</p><p>2a) If there are leftover data, then switch to <code>conn_parse_cmd</code> directly.</p><p>2b) If it is a fresh <em>session</em>, then switch to <code>conn_waiting</code>.</p><p>3) Yield the current iteration when the threshold is reached.</p><h2 id="conn-waiting"><a href="#conn-waiting" class="headerlink" title="conn_waiting"></a>conn_waiting</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_waiting:</span><br><span class="line">            <span class="keyword">if</span> (!update_event(c, EV_READ | EV_PERSIST)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Couldn't update event\n"</span>);</span><br><span class="line">                conn_set_state(c, conn_closing);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            conn_set_state(c, conn_read);</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4322</text></center><p>Simply reset the descriptor with the original flags (i.e., <code>EV_READ</code>, <code>EV_PERSIST</code>), update the state of the <em>context</em> to the next hop (<code>conn_read</code>), and relinquish the CPU.</p><h2 id="conn-read"><a href="#conn-read" class="headerlink" title="conn_read"></a>conn_read</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> conn_read:</span><br><span class="line">    res = IS_UDP(c-&gt;transport) ? try_read_udp(c) : try_read_network(c); <span class="comment">//1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">    <span class="keyword">case</span> READ_NO_DATA_RECEIVED:</span><br><span class="line">        conn_set_state(c, conn_waiting);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ_DATA_RECEIVED:</span><br><span class="line">        conn_set_state(c, conn_parse_cmd); <span class="comment">// scr: ---------------------&gt; 2)</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ_ERROR:</span><br><span class="line">        conn_set_state(c, conn_closing);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ_MEMORY_ERROR: <span class="comment">/* Failed to allocate more memory */</span></span><br><span class="line">        <span class="comment">/* State already set by try_read_network */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4334</text></center><p>1) Read from the file descriptor and save the data to the <em>context</em>.</p><p>2) Switch to the next state, <code>conn_parse_cmd</code>.</p><h3 id="try-read-network"><a href="#try-read-network" class="headerlink" title="try_read_network"></a>try_read_network</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> try_read_result <span class="title">try_read_network</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> try_read_result gotdata = READ_NO_DATA_RECEIVED;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span> num_allocs = <span class="number">0</span>;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;rcurr != c-&gt;rbuf) &#123; <span class="comment">// scr: -------------------------&gt; 1)</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;rbytes != <span class="number">0</span>) <span class="comment">/* otherwise there's nothing to copy */</span></span><br><span class="line">            memmove(c-&gt;rbuf, c-&gt;rcurr, c-&gt;rbytes);</span><br><span class="line">        c-&gt;rcurr = c-&gt;rbuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;rbytes &gt;= c-&gt;rsize) &#123; <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">            <span class="keyword">if</span> (num_allocs == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> gotdata;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num_allocs;</span><br><span class="line">            <span class="keyword">char</span> *new_rbuf = <span class="built_in">realloc</span>(c-&gt;rbuf, c-&gt;rsize * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (!new_rbuf) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            c-&gt;rcurr = c-&gt;rbuf = new_rbuf;</span><br><span class="line">            c-&gt;rsize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> avail = c-&gt;rsize - c-&gt;rbytes; <span class="comment">// scr: --------------&gt; 3)</span></span><br><span class="line">        res = read(c-&gt;sfd, c-&gt;rbuf + c-&gt;rbytes, avail);</span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">            gotdata = READ_DATA_RECEIVED;</span><br><span class="line">            c-&gt;rbytes += res;</span><br><span class="line">            <span class="keyword">if</span> (res == avail) &#123; <span class="comment">// scr: -----------------------&gt; 3a)</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// scr: --------------------------------&gt; 3b)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> READ_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123; <span class="comment">//src:3b)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> READ_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotdata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:try_read_network</text></center><p>Here the <code>while (1)</code> is used to handle logic flow for buffer expanding instead of loop.</p><p>1) Move <code>rcurr</code> to the beginning of the <em>read buffer</em>.</p><p>2) If the data size exceeds the <em>read buffer</em> size, try expanding the buffer (for at most 4 times).</p><p>3) Calculate the available buffer space for <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener">read</a>ing from the socket, and update <code>rbytes</code> accordingly.</p><p>3a) Goto 2) if the buffer is full.</p><p>3b) Return <code>READ_DATA_RECEIVED</code>, which switches the state to <code>conn_parse_cmd</code> in the <strong>state machine</strong> pass through.</p><h2 id="conn-parse-cmd"><a href="#conn-parse-cmd" class="headerlink" title="conn_parse_cmd"></a>conn_parse_cmd</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> conn_parse_cmd :</span><br><span class="line">    <span class="keyword">if</span> (try_read_command(c) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* wee need more data! */</span></span><br><span class="line">        conn_set_state(c, conn_waiting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:try_read_network</text></center><h3 id="try-read-command"><a href="#try-read-command" class="headerlink" title="try_read_command"></a>try_read_command</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_read_command</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">    assert(c-&gt;rcurr &lt;= (c-&gt;rbuf + c-&gt;rsize));</span><br><span class="line">    assert(c-&gt;rbytes &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;protocol == negotiating_prot || c-&gt;transport == udp_transport)  &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)c-&gt;rbuf[<span class="number">0</span>] == (<span class="keyword">unsigned</span> <span class="keyword">char</span>)PROTOCOL_BINARY_REQ) &#123;</span><br><span class="line">            c-&gt;protocol = binary_prot;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c-&gt;protocol = ascii_prot; <span class="comment">// scr: -------------------------&gt; 1)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123; <span class="comment">// scr: ---------------------------&gt; ~)</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%d: Client using the %s protocol\n"</span>, c-&gt;sfd,</span><br><span class="line">                    prot_text(c-&gt;protocol));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;protocol == binary_prot) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> *el, *cont;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;rbytes == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        el = <span class="built_in">memchr</span>(c-&gt;rcurr, <span class="string">'\n'</span>, c-&gt;rbytes); <span class="comment">// scr: ---------------&gt; 2)</span></span><br><span class="line">        <span class="keyword">if</span> (!el) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125;</span><br><span class="line">        cont = el + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((el - c-&gt;rcurr) &gt; <span class="number">1</span> &amp;&amp; *(el - <span class="number">1</span>) == <span class="string">'\r'</span>) &#123;</span><br><span class="line">            el--;</span><br><span class="line">        &#125;</span><br><span class="line">        *el = <span class="string">'\0'</span>; <span class="comment">// scr: -------------------------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">        assert(cont &lt;= (c-&gt;rcurr + c-&gt;rbytes));</span><br><span class="line"></span><br><span class="line">        c-&gt;last_cmd_time = current_time; <span class="comment">// scr: ----------------------&gt; 3)</span></span><br><span class="line">        process_command(c, c-&gt;rcurr); <span class="comment">// scr: -------------------------&gt; 4)</span></span><br><span class="line"></span><br><span class="line">        c-&gt;rbytes -= (cont - c-&gt;rcurr); <span class="comment">// scr: -----------------------&gt; 5)</span></span><br><span class="line">        c-&gt;rcurr = cont; <span class="comment">// scr: --------------------------------------&gt; 6)</span></span><br><span class="line"></span><br><span class="line">        assert(c-&gt;rcurr &lt;= (c-&gt;rbuf + c-&gt;rsize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:try_read_command</text></center><p>1) Determine the protocol type, in this case is <code>ascii_prot</code>.</p><p>~) Verbose message we saw in the beginning.</p><p>2) Trim all the <code>&#39;\n&#39;</code> and <code>&#39;\r&#39;</code> in the end, store the position of the command last character to <code>el</code>, and store the command end to <code>cont</code>.</p><p>3) Update <code>last_cmd_time</code>.</p><p>4) Call <a href="#" onclick="return false;" data-toggle="collapse" data-target="#process_command">process_command</a> which locates the “get” command and call <code>process_get_command</code>. In <a href="#" onclick="return false;" data-toggle="collapse" data-target="#process_command">process_command</a>, a) <code>tokenize_command</code> is a string parsing method that stores command (i.e., “get”) in <code>tokens[COMMAND_TOKEN]</code> and key (i.e., test) in <code>tokens[KEY_TOKEN]</code>; b) initialization of <code>msgcurr</code>, <code>msgused</code>, <code>iovused</code>; c) initialization other fields in <a href="#add-msghdr">add_msghdr</a>; and d) <a href="#process-get-command">process_get_command</a> is the next step.</p><div id="process_command" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">c-&gt;msgcurr = <span class="number">0</span>; <span class="comment">// scr: ---------------------------------------------&gt; b)</span></span><br><span class="line">c-&gt;msgused = <span class="number">0</span>;</span><br><span class="line">c-&gt;iovused = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (add_msghdr(c) != <span class="number">0</span>) &#123;</span><br><span class="line">    out_of_memory(c, <span class="string">"SERVER_ERROR out of memory preparing response"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ntokens = tokenize_command(command, tokens, MAX_TOKENS); <span class="comment">// scr: ----&gt; a)</span></span><br><span class="line"><span class="keyword">if</span> (ntokens &gt;= <span class="number">3</span> &amp;&amp;</span><br><span class="line">    ((<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"get"</span>) == <span class="number">0</span>) || </span><br><span class="line">     (<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"bget"</span>) == <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">    process_get_command(c, tokens, ntokens, <span class="literal">false</span>); <span class="comment">// scr: ---------&gt; c)</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:process_command</text></center><br></div><p>5) Update <code>rbytes</code> with the length of the command that has been processed (<code>cont - c-&gt;rcurr</code>).</p><p>6) Move the <code>rcurr</code> to the unprocessed data located at end of the command portion.</p><h3 id="add-msghdr"><a href="#add-msghdr" class="headerlink" title="add_msghdr"></a>add_msghdr</h3><p>Before the logic reaches <a href="#process-get-command">process_get_command</a>, an entry should be initialised in <code>msglist</code> for the current command.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_msghdr</span><span class="params">(conn *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;msgsize == c-&gt;msgused) &#123; <span class="comment">// scr: --------------------&gt; 1)</span></span><br><span class="line">        msg = <span class="built_in">realloc</span>(c-&gt;msglist, c-&gt;msgsize * <span class="number">2</span> * <span class="keyword">sizeof</span>(struct msghdr));</span><br><span class="line">        <span class="keyword">if</span> (! msg) &#123;</span><br><span class="line">            STATS_LOCK();</span><br><span class="line">            stats.malloc_fails++;</span><br><span class="line">            STATS_UNLOCK();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c-&gt;msglist = msg;</span><br><span class="line">        c-&gt;msgsize *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg = c-&gt;msglist + c-&gt;msgused; <span class="comment">// scr: ---------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this wipes msg_iovlen, msg_control, msg_controllen, and</span></span><br><span class="line"><span class="comment">       msg_flags, the last 3 of which aren't defined on solaris: */</span></span><br><span class="line">    <span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct msghdr)); <span class="comment">// scr: -------------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    msg-&gt;msg_iov = &amp;c-&gt;iov[c-&gt;iovused]; <span class="comment">// scr: ----------------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;request_addr_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;msgbytes = <span class="number">0</span>; <span class="comment">// scr: -----------------------------------&gt; 4)</span></span><br><span class="line">    c-&gt;msgused++; <span class="comment">// scr: --------------------------------------&gt; 5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_UDP(c-&gt;transport)) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">add_msghdr@memcached.c</text></center><p>1) Expand the <code>msglist</code> when required.</p><p>2) Point to the next empty entry in <code>msglist</code> with <code>msg</code>.</p><p>3) Initialise the entry pointed by <code>msg</code>. Here the critical operation is <code>msg-&gt;msg_iov = &amp;c-&gt;iov[c-&gt;iovused];</code> which links the <code>msglist</code> to the specific entry in <code>iov</code>. (<a href="#fig_core_ds">Figure - msglist &amp; iov</a>)</p><p>4) Initialise <code>msgbytes</code> to <code>0</code>.</p><p>5) Update <code>msgused</code> accordingly.</p><h3 id="process-get-command"><a href="#process-get-command" class="headerlink" title="process_get_command"></a>process_get_command</h3><p>We have seen this method in beginning of <a href="/understanding-memcached-source-code-VI/#process-get-command">LRU III</a>. This time, we will complete its pass through with the context of <strong>event driven</strong>.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">process_get_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">size_t</span> ntokens, <span class="keyword">bool</span> return_cas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">token_t</span> *key_token = &amp;tokens[KEY_TOKEN];</span><br><span class="line">    <span class="keyword">char</span> *suffix;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(key_token-&gt;length != <span class="number">0</span>) &#123; <span class="comment">// scr: -----------------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">            key = key_token-&gt;value;</span><br><span class="line">            nkey = key_token-&gt;length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nkey &gt; KEY_MAX_LENGTH) &#123;</span><br><span class="line">                out_string(c, <span class="string">"CLIENT_ERROR bad command line format"</span>);</span><br><span class="line">                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    item_remove(*(c-&gt;ilist + i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it = item_get(key, nkey, c); <span class="comment">// scr: ----------------&gt; 2)</span></span><br><span class="line">            <span class="keyword">if</span> (settings.detail_enabled) &#123;</span><br><span class="line">                stats_prefix_record_get(key, nkey, <span class="literal">NULL</span> != it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= c-&gt;isize) &#123; <span class="comment">// scr: --------------------&gt; 3)</span></span><br><span class="line">                    item **new_list = <span class="built_in">realloc</span>(c-&gt;ilist, <span class="keyword">sizeof</span>(item *) * c-&gt;isize * <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">if</span> (new_list) &#123;</span><br><span class="line">                        c-&gt;isize *= <span class="number">2</span>;</span><br><span class="line">                        c-&gt;ilist = new_list;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                        item_remove(it);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (return_cas)</span><br><span class="line">                &#123;</span><br><span class="line">...<span class="comment">// scr: cas</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  MEMCACHED_COMMAND_GET(c-&gt;sfd, ITEM_key(it), it-&gt;nkey,</span><br><span class="line">                                        it-&gt;nbytes, ITEM_get_cas(it));</span><br><span class="line">                  <span class="keyword">if</span> (add_iov(c, <span class="string">"VALUE "</span>, <span class="number">6</span>) != <span class="number">0</span> || <span class="comment">// scr: ---&gt; 4)</span></span><br><span class="line">                      add_iov(c, ITEM_key(it), it-&gt;nkey) != <span class="number">0</span> ||</span><br><span class="line">                      add_iov(c, ITEM_suffix(it), it-&gt;nsuffix + it-&gt;nbytes) != <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          item_remove(it);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: verbose &amp; stat</span></span><br><span class="line"></span><br><span class="line">                item_update(it); <span class="comment">// scr: ------------------------&gt; 5)</span></span><br><span class="line">                *(c-&gt;ilist + i) = it; <span class="comment">// scr: -------------------&gt; 6)</span></span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key_token++; <span class="comment">// scr: --------------------------------&gt; 1)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the command string hasn't been fully processed, get the next set</span></span><br><span class="line"><span class="comment">         * of tokens.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(key_token-&gt;value != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: ------------------&gt; 1)</span></span><br><span class="line">            ntokens = tokenize_command(key_token-&gt;value, tokens, MAX_TOKENS);</span><br><span class="line">            key_token = tokens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(key_token-&gt;value != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    c-&gt;icurr = c-&gt;ilist; <span class="comment">// scr: --------------------------------&gt; 6)</span></span><br><span class="line">    c-&gt;ileft = i; scr: ------------------------------------------&gt; <span class="number">6</span>)</span><br><span class="line">...<span class="comment">// scr: cas &amp; verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key_token-&gt;value != <span class="literal">NULL</span> || add_iov(c, <span class="string">"END\r\n"</span>, <span class="number">5</span>) != <span class="number">0</span></span><br><span class="line">        || (IS_UDP(c-&gt;transport) &amp;&amp; build_udp_headers(c) != <span class="number">0</span>)) &#123;</span><br><span class="line">        out_of_memory(c, <span class="string">"SERVER_ERROR out of memory writing get response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// scr: ----------------------------------------------&gt; 7)</span></span><br><span class="line">        conn_set_state(c, conn_mwrite);</span><br><span class="line">        c-&gt;msgcurr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_get_command@memcached.c</text></center><p>1) Iterate through key token array. Here we got one key token ‘test’.</p><p>2) Call <a href="/understanding-memcached-source-code-VI/#do-item-get">item_get</a> for the <strong>item</strong> pointer.</p><p>3) Increase the <code>ilist</code> size if it is full, and . Here <code>ilist</code> stores the <strong>item</strong> being processed. In the <a href="#Finish-read">end of the current command processing</a>,  this list is used to batch release the <strong>item</strong>s reference counts.</p><p>4) <code>add_iov</code> prepares the output of this session.</p><p>5) Call <a href="/understanding-memcached-source-code-VI/#do-item-update">item_update</a> to manipulate the <em>LRU</em> lists.</p><p>6) Link the <strong>item</strong> currently being processed to <code>ilist</code>, and update the associated fields.</p><p>7) Move on to the next state <a href="#conn-mwrite">conn_mwrite</a>.</p><h3 id="add-iov"><a href="#add-iov" class="headerlink" title="add_iov"></a>add_iov</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_iov</span><span class="params">(conn *c, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">m</span>;</span></span><br><span class="line">    <span class="keyword">int</span> leftover;</span><br><span class="line">    <span class="keyword">bool</span> limit_to_mtu;</span><br><span class="line"></span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = &amp;c-&gt;msglist[c-&gt;msgused - <span class="number">1</span>]; <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Limit UDP packets, and the first payloads of TCP replies, to</span></span><br><span class="line"><span class="comment">         * UDP_MAX_PAYLOAD_SIZE bytes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        limit_to_mtu = IS_UDP(c-&gt;transport) || (<span class="number">1</span> == c-&gt;msgused);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We may need to start a new msghdr if this one is full. */</span></span><br><span class="line">        <span class="keyword">if</span> (m-&gt;msg_iovlen == IOV_MAX ||</span><br><span class="line">            (limit_to_mtu &amp;&amp; c-&gt;msgbytes &gt;= UDP_MAX_PAYLOAD_SIZE)) &#123;</span><br><span class="line">            add_msghdr(c);</span><br><span class="line">            m = &amp;c-&gt;msglist[c-&gt;msgused - <span class="number">1</span>]; <span class="comment">// scr: ---------------&gt; 7)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ensure_iov_space(c) != <span class="number">0</span>) <span class="comment">// scr: ----------------------&gt; 2)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the fragment is too big to fit in the datagram, split it up */</span></span><br><span class="line">        <span class="keyword">if</span> (limit_to_mtu &amp;&amp; len + c-&gt;msgbytes &gt; UDP_MAX_PAYLOAD_SIZE) &#123;</span><br><span class="line">            leftover = len + c-&gt;msgbytes - UDP_MAX_PAYLOAD_SIZE; <span class="comment">//scr*)</span></span><br><span class="line">            len -= leftover;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftover = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m = &amp;c-&gt;msglist[c-&gt;msgused - <span class="number">1</span>]; <span class="comment">// scr: ------------------&gt; 1)</span></span><br><span class="line">        m-&gt;msg_iov[m-&gt;msg_iovlen].iov_base = (<span class="keyword">void</span> *)buf; <span class="comment">// scr: -&gt; 3)</span></span><br><span class="line">        m-&gt;msg_iov[m-&gt;msg_iovlen].iov_len = len;</span><br><span class="line"></span><br><span class="line">        c-&gt;msgbytes += len; <span class="comment">// scr: -------------------------------&gt; 4)</span></span><br><span class="line">        c-&gt;iovused++; <span class="comment">// scr: -------------------------------------&gt; 5)</span></span><br><span class="line">        m-&gt;msg_iovlen++; <span class="comment">// scr: ----------------------------------&gt; 6)</span></span><br><span class="line"></span><br><span class="line">        buf = ((<span class="keyword">char</span> *)buf) + len;</span><br><span class="line">        len = leftover;</span><br><span class="line">    &#125; <span class="keyword">while</span> (leftover &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">add_iov@memcached.c</text></center><p>This method initialised an entry on <code>iov</code> list and add it to the last in-use item in msglist (<a href="#fig_core_ds">Figure - msglist &amp; iov</a>).</p><p>1) Get the tail of the in use portion of <code>msglist</code>.</p><p>2) Expend <code>iov</code> if necessary.</p><p>3) Initialize the <code>iov_base</code> and <code>iov_len</code> fields within the <code>iov</code> entry. Note that the <code>msg_iov</code> has been linked to the position of specific entry in <code>iov</code>, hence operations on <code>msg_iov</code> change the content of <code>iov</code> as well.</p><p>4) Update <code>msgbytes</code> with the total <strong>item</strong> size.</p><p>5, 6) Update <code>iovused</code> and <code>msg_iovlen</code> accordingly.</p><p>7) Handle <strong>MTU</strong> with the assistance of <code>do while</code> loop.</p><h2 id="conn-mwrite"><a href="#conn-mwrite" class="headerlink" title="conn_mwrite"></a>conn_mwrite</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">          <span class="keyword">if</span> (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;msgcurr == <span class="number">0</span> &amp;&amp; build_udp_headers(c) != <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">switch</span> (transmit(c)) &#123;</span><br><span class="line">...<span class="comment">// scr: state processing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4521</text></center><p>Before explaining the logic <a href="#Back-to-state-processing">process of conn_mwrite state</a>, we look at the essential within first, which is</p><h3 id="transmit"><a href="#transmit" class="headerlink" title="transmit"></a>transmit</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> transmit_result <span class="title">transmit</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;msgcurr &lt; c-&gt;msgused &amp;&amp;</span><br><span class="line">            c-&gt;msglist[c-&gt;msgcurr].msg_iovlen == <span class="number">0</span>) &#123; <span class="comment">// scr: ---------&gt; 1)</span></span><br><span class="line">        <span class="comment">/* Finished writing the current msg; advance to the next. */</span></span><br><span class="line">        c-&gt;msgcurr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;msgcurr &lt; c-&gt;msgused) &#123; <span class="comment">// scr: ----------------------------&gt; 2)</span></span><br><span class="line">        <span class="keyword">ssize_t</span> res;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">m</span> = &amp;<span class="title">c</span>-&gt;<span class="title">msglist</span>[<span class="title">c</span>-&gt;<span class="title">msgcurr</span>];</span></span><br><span class="line">            </span><br><span class="line">        res = sendmsg(c-&gt;sfd, m, <span class="number">0</span>); </span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: state</span></span><br><span class="line">            <span class="comment">/* We've written some of the data. Remove the completed</span></span><br><span class="line"><span class="comment">               iovec entries from the list of pending writes. */</span></span><br><span class="line">            <span class="keyword">while</span> (m-&gt;msg_iovlen &gt; <span class="number">0</span> &amp;&amp; res &gt;= m-&gt;msg_iov-&gt;iov_len) &#123;</span><br><span class="line">                res -= m-&gt;msg_iov-&gt;iov_len;</span><br><span class="line">                m-&gt;msg_iovlen--;</span><br><span class="line">                m-&gt;msg_iov++;</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Might have written just part of the last iovec entry;</span></span><br><span class="line"><span class="comment">               adjust it so the next write will do the rest. */</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                m-&gt;msg_iov-&gt;iov_base = (<span class="keyword">caddr_t</span>)m-&gt;msg_iov-&gt;iov_base + res;</span><br><span class="line">                m-&gt;msg_iov-&gt;iov_len -= res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> TRANSMIT_INCOMPLETE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span> &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)) &#123; <span class="comment">// 3)</span></span><br><span class="line">            <span class="keyword">if</span> (!update_event(c, EV_WRITE | EV_PERSIST)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Couldn't update event\n"</span>);</span><br><span class="line">                conn_set_state(c, conn_closing);</span><br><span class="line">                <span class="keyword">return</span> TRANSMIT_HARD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> TRANSMIT_SOFT_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,</span></span><br><span class="line"><span class="comment">           we have a real error, on which we close the connection */</span></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">"Failed to write, and not due to blocking"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IS_UDP(c-&gt;transport))</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            conn_set_state(c, conn_closing);</span><br><span class="line">        <span class="keyword">return</span> TRANSMIT_HARD_ERROR; <span class="comment">// scr: --------------------------&gt; 4)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> TRANSMIT_COMPLETE; <span class="comment">// scr: ----------------------------&gt; 5)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">transmit@memcached.c</text></center><p>As the essential method of state <code>conn_mwrite</code> processing, <code>transmit</code> goes through the <code>msglist</code> (starting from <code>0</code>, the initial value) and tries its best to send out all the pending data accumulated in the current session. This is done within itself or in subsequent passes through the <em>event loop</em>. Only when blocking operation is indicated by <code>EAGAIN</code> or <code>EWOULDBLOCK</code>, the <strong>state machine</strong> stops the current <em>event loop</em> iteration, and the same session will be resumed when the buffer space becomes available again.</p><p>1) If the <code>msg_iovlen</code> is <code>0</code>, the writing of <code>msgcurr</code> slot has finished, hence move to the next slot.</p><p>2) Call <a href="http://man7.org/linux/man-pages/man3/sendmsg.3p.html" target="_blank" rel="noopener">sendmsg</a> and move <code>msg_iov</code>, <code>iov_base</code> and <code>iov_len</code> according to the data length (<code>res</code>) that has been written successfully. This leads to case b) of the <a href="#Back-to-state-processing">state processing</a>.</p><p>3) As mentioned, <code>EAGAIN</code> or <code>EWOULDBLOCK</code> returned by <a href="http://man7.org/linux/man-pages/man3/sendmsg.3p.html" target="_blank" rel="noopener">sendmsg</a> leads to case c) of <a href="#Back-to-state-processing">state processing</a>.</p><p>4) Errors other than the above two lead to case c) of <a href="#Back-to-state-processing">state processing</a>.</p><p>5) <code>c-&gt;msgcurr &gt;= c-&gt;msgused</code> means <code>write</code> of all data of the session finished, which leads to b) of the <a href="#Back-to-state-processing">state processing</a>.</p><h3 id="Back-to-state-processing"><a href="#Back-to-state-processing" class="headerlink" title="Back to state processing"></a>Back to state processing</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">          <span class="keyword">if</span> (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;msgcurr == <span class="number">0</span> &amp;&amp; build_udp_headers(c) != <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">switch</span> (transmit(c)) &#123;</span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_COMPLETE:</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;state == conn_mwrite) &#123; <span class="comment">// scr: ------------&gt; a)</span></span><br><span class="line">                    conn_release_items(c);</span><br><span class="line">                    <span class="comment">/* <span class="doctag">XXX:</span>  I don't know why this wasn't the general case */</span></span><br><span class="line">                    <span class="keyword">if</span>(c-&gt;protocol == binary_prot) &#123;</span><br><span class="line">                        conn_set_state(c, c-&gt;write_and_go);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        conn_set_state(c, conn_new_cmd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;state == conn_write) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_INCOMPLETE: <span class="comment">// scr: ---------------------&gt; b)</span></span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_HARD_ERROR:</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">/* Continue in state machine. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_SOFT_ERROR: <span class="comment">// scr: ---------------------&gt; c)</span></span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4521</text></center><p>According to the result of <code>transmit</code>, the logic flows to the following 3 branches,</p><p>a) If the result is <code>TRANSMIT_COMPLETE</code>, 1) finalise the current command processing with <a href="#Finish-read">conn_release_items</a>; 2) switch the <code>state</code> to <a href="#conn-new-cmd">conn_new_cmd</a> which 3) eventually falls to <code>conn_waiting</code> and, <a href="#conn-waiting">as discussed</a>, finishes the current <em>event loop</em>.</p><p>b) If the result is <code>TRANSMIT_INCOMPLETE</code> and <code>TRANSMIT_HARD_ERROR</code>, the <strong>state machine</strong> keeps the same <strong>state</strong>, and the subsequent passes through the <em>event loop</em> continues consuming more data in <code>msglist</code>. Unlike <code>read</code> operation, <code>TRANSMIT_INCOMPLETE</code> does not lead to immediate <em>event loop</em> finish because write operation does not block until buffer is full.</p><p>c) <code>TRANSMIT_SOFT_ERROR</code> means the buffer is full, hence finish the current <em>event loop</em> iteration straight away.</p><h3 id="Finish-read"><a href="#Finish-read" class="headerlink" title="Finish read"></a>Finish read</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_release_items</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;item) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (c-&gt;ileft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item *it = *(c-&gt;icurr);</span><br><span class="line">        assert((it-&gt;it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</span><br><span class="line">        item_remove(it); <span class="comment">// scr: ---------------------&gt; 1)</span></span><br><span class="line">        c-&gt;icurr++;</span><br><span class="line">        c-&gt;ileft--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: cas</span></span><br><span class="line"></span><br><span class="line">    c-&gt;icurr = c-&gt;ilist;</span><br><span class="line">...<span class="comment">// scr: cas</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">conn_release_items@memcached.c</text></center><p>Not sure if you noticed or not, there is a subtle bug in the <a href="/understanding-memcached-source-code-VI/#Read">LRU III</a>, the <em>reference count</em> of the <strong>item</strong> in <a href="/understanding-memcached-source-code-VI/#Read">read</a> operation is not returned to 0 as in other operations. This is because </p><p>1) all <strong>item</strong>s ownership are batched released here at the end the (<code>read</code>) command processing.</p>]]></content>
    
    <summary type="html">
    
      In classic multithreading, blocking I/O operations constrain the maximum number of requests a server can handle. Hence asynchronous event driven model is used to eliminate the throughput bottleneck. As such, the synchronous and potentially slow process is divided into logic segments that are free of I/O, and are executed asynchronously. When it comes to asynchronization, extra space is required to store contexts. This is because the logic segments, that could be associated with different sessions, are executed in an interleaved way. For instance, in the case when asynchronization is implemented (emulated) using synchronous multithreading, the “extra space” is in the form of thread stack. Whilst contexts are maintained in user land in event driven.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="socket" scheme="https://holmeshe.me/tags/socket/"/>
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="event driven" scheme="https://holmeshe.me/tags/event-driven/"/>
    
      <category term="state machine" scheme="https://holmeshe.me/tags/state-machine/"/>
    
      <category term="multithreading" scheme="https://holmeshe.me/tags/multithreading/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - Event Driven I</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-VII/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-VII/</id>
    <published>2019-01-17T20:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I - this article</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>In classic <em>multithreading</em>, large amounts of slow and blocking operations, mostly, I/O, can easily drain out available thread resources, which severely constrains the maximum number of requests a server can handle per unit time. More specific, threads are scheduled out and put into sleep in the middle of procedures that contain blocking I/O, despite piling up requests packets queuing within the network stack. In such situation, server side will show low throughput, low CPU saturation and high latency. </p><a id="more"></a><p class="back"><br>Here is a <a href="https://hackernoon.com/back-end-performance-those-metrics-we-care-about-ade678e87969" target="_blank" rel="noopener">post</a> around server side performance. Feel free to check it out.<br></p><h1 id="An-introduction-to-event-driven"><a href="#An-introduction-to-event-driven" class="headerlink" title="An introduction to event driven"></a>An introduction to event driven</h1><p>This is where asynchronous <strong>event driven</strong> model comes in, which drops the idea that <em>context</em> of a <em>session</em> must be coupled with a thread. In such model, <em>session</em> contexts are contained within and managed by a <strong>drive machine</strong> and a thread is fully unleashed with unblocking I/O operations. More specific, 1) when I/O occurs in the middle of a procedure, a thread does not block but instantly switch to the processing of another <em>request</em>; and 2) when the I/O completes, the <em>context</em> will be picked up by the <strong>drive machine</strong> to resume the interrupted <em>session</em>. As such, a potentially slow procedure is effectively divided into multiple manageable pieces, and the cutting points are marked by I/O operations. This results in more performant single threaded architecture in comparison to those employ thousands of threads.</p><p class="back"><br>In my understanding, <strong>event driven</strong> model, in its essential, is yet another instance of “divide and conquer” and “trade space for time” in a not very obvious way.<br></p><p>On the other hand, <em>multithreading</em> can be still used in <strong>event driven</strong> model purely for the purpose of parallelism. Thus, in practice, the number of threads employed does not exceed that of CPU cores. I will discuss the <strong>Memcached</strong> <em>multithreading</em> soon in <a href="#Thread-model">Thread model</a>.</p><h1 id="The-drive-machine"><a href="#The-drive-machine" class="headerlink" title="The drive machine"></a>The drive machine</h1><p>From a developer’s point of view, there are numerous ways to program an asynchronous <strong>even driven</strong> server. <strong>Memcached</strong> adopts an approach called <em>state machine</em>, in which logic flow is divided into non-linear fragments identified with <strong>state</strong>s, which is normally controled by a huge <code>switch case</code>. The brightside of this approach is that the mentioned breakdown of slow procedure is sincerely reflected by the logic fragments. But it makes the code style a bit different from what most developers are already used to.</p><p>Following is how the event <strong>drive</strong>n state <strong>machine</strong> actually looks like.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> nreqs = settings.reqs_per_event;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(c-&gt;state) &#123;</span><br><span class="line">        <span class="keyword">case</span> conn_listening:</span><br><span class="line">            addrlen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">...</span><br><span class="line">            sfd = accept(c-&gt;sfd, (struct sockaddr *)&amp;addr, &amp;addrlen);</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (sfd == <span class="number">-1</span>) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (settings.maxconns_fast &amp;&amp;</span><br><span class="line">                stats_state.curr_conns + stats_state.reserved_fds &gt;= settings.maxconns - <span class="number">1</span>) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,</span><br><span class="line">                                     DATA_BUFFER_SIZE, c-&gt;transport);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_waiting:</span><br><span class="line">...</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_read:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_parse_cmd :</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_new_cmd:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_nread:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_swallow:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_write:</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_closing:</span><br><span class="line">            <span class="keyword">if</span> (IS_UDP(c-&gt;transport))</span><br><span class="line">                conn_cleanup(c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                conn_close(c);</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_closed:</span><br><span class="line">            <span class="comment">/* This only happens if dormando is an idiot. */</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_watch:</span><br><span class="line">            <span class="comment">/* We handed off our connection to the logger thread. */</span></span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_max_state:</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">drive_machine@memcached.c</text></center><p>The omitted switch blocks will be discussed in detail in following posts, so no worries.</p><h1 id="Thread-model"><a href="#Thread-model" class="headerlink" title="Thread model"></a>Thread model</h1><p>The thread model of <strong>Memcached</strong> is quite standard. There is a <em>dispatcher thread</em>, and there are preconfigured number of <em>worker thread</em>s. Each thread runs an independent <strong>drive machine</strong> described above. The <em>dispatcher thread</em>, of which the responsible is to distribute <em>request</em>s among <em>worker thread</em>s, only executes code under <code>conn_listening</code>. The actual requests are completed by <em>worker thread</em>s running on the rest of the <strong>state</strong>s.</p><p><img src="/gallery/mem-thread.png" alt="Thread model"></p><p>Next we go through the bootstrap portion of <code>main</code> function which establishes the various building blocks of <strong>event driven</strong> as well as the <em>multithreading</em> mechanism. And we will also see locations of the discussed sub-system <code>***_init</code> methods in relation to the whole initialization process.</p><p>First thing first, all the <em>system initialization</em> relevant procedures are executed in the discussed <em>dispatcher thread</em>.</p><p>The call stack of this process is</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|-main</span><br><span class="line">  |-hash_init          (LRU II)</span><br><span class="line">  |-assoc_init         (LRU II)</span><br><span class="line">  |-conn_init</span><br><span class="line">  |-slabs_init         (Slab I)</span><br><span class="line">  |-memcached_thread_init</span><br><span class="line">    |-setup_thread</span><br><span class="line">    |-create_worker</span><br><span class="line">  |-server_sockets</span><br><span class="line">    |-new_socket</span><br><span class="line">    |-conn_new</span><br></pre></td></tr></table></figure><h1 id="System-initialization"><a href="#System-initialization" class="headerlink" title="System initialization"></a>System initialization</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">...<span class="comment">// scr: -----------------------------------------------------&gt; *)</span></span><br><span class="line">...<span class="comment">// scr: initialize `settings` using default values and command line arguements</span></span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hash_init(hash_type) != <span class="number">0</span>) &#123; <span class="comment">// scr: ---------------&gt; LRU II</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to initialize hash_algorithm!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EX_USAGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: initialize `settings` &amp; sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxcore != <span class="number">0</span>) &#123; <span class="comment">// scr: --------------------------------&gt; 1)</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim_new</span>;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * First try raising to infinity; if that fails, try bringing</span></span><br><span class="line"><span class="comment">         * the soft limit to the hard.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (getrlimit(RLIMIT_CORE, &amp;rlim) == <span class="number">0</span>) &#123;</span><br><span class="line">            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;</span><br><span class="line">            <span class="keyword">if</span> (setrlimit(RLIMIT_CORE, &amp;rlim_new)!= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* failed. try raising just to the old max */</span></span><br><span class="line">                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;</span><br><span class="line">                (<span class="keyword">void</span>)setrlimit(RLIMIT_CORE, &amp;rlim_new);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * getrlimit again to see what we ended up with. Only fail if</span></span><br><span class="line"><span class="comment">         * the soft limit ends up 0, because then no core files will be</span></span><br><span class="line"><span class="comment">         * created at all.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((getrlimit(RLIMIT_CORE, &amp;rlim) != <span class="number">0</span>) || rlim.rlim_cur == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to ensure corefile creation\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rlim) != <span class="number">0</span>) &#123; <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to getrlimit number of files\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rlim.rlim_cur = settings.maxconns;</span><br><span class="line">        rlim.rlim_max = settings.maxconns;</span><br><span class="line">        <span class="keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;rlim) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: -----------------------------------------------------&gt; *)</span></span><br><span class="line"></span><br><span class="line">    main_base = event_init(); <span class="comment">// scr: --------------------------&gt; 2)</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">    assoc_init(settings.hashpower_init); <span class="comment">// scr: -----------&gt; LRU II</span></span><br><span class="line">    conn_init(); <span class="comment">// scr: ---------------------------------------&gt; 3)</span></span><br><span class="line">    slabs_init(settings.maxbytes, settings.factor, preallocate,</span><br><span class="line">            use_slab_sizes ? slab_sizes : <span class="literal">NULL</span>); <span class="comment">// scr: ---&gt; Slab I</span></span><br><span class="line">...</span><br><span class="line">    memcached_thread_init(settings.num_threads, main_base); <span class="comment">//scr:4)</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: maintainer threads initialization</span></span><br><span class="line">...<span class="comment">// scr: unix socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the listening socket, bind it, and init */</span></span><br><span class="line">    <span class="keyword">if</span> (settings.socketpath == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        <span class="keyword">if</span> (portnumber_filename != <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        errno = <span class="number">0</span>; <span class="comment">// scr: -------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.port &amp;&amp; server_sockets(settings.port, tcp_transport,</span><br><span class="line">                                           portnumber_file)) &#123;</span><br><span class="line">            vperror(<span class="string">"failed to listen on TCP port %d"</span>, settings.port);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        errno = <span class="number">0</span>; <span class="comment">// scr: -------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.udpport &amp;&amp; server_sockets(settings.udpport, udp_transport,</span><br><span class="line">                                              portnumber_file)) &#123;</span><br><span class="line">            vperror(<span class="string">"failed to listen on UDP port %d"</span>, settings.udpport);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (portnumber_file) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">1000</span>);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (event_base_loop(main_base, <span class="number">0</span>) != <span class="number">0</span>) &#123; <span class="comment">// scr: ----------&gt; 6)</span></span><br><span class="line">        retval = EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: finalization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c</text></center><p>The two relevant steps are 4) and 5) which will be discussed in the  following sections.</p><p>1) Raise the limit for core dump file size as well as the number of file descriptors.</p><p>2) Call <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6" target="_blank" rel="noopener">event_init</a> to initialize the <strong>libevent</strong> framework. The value returned is called an <em>event base</em>.</p><p>3) For all potential connections, call <a href="#" onclick="return false;" data-toggle="collapse" data-target="#conn_init">conn_init</a> to allocate space to store their respective <em>context</em>s (located using file descriptor in global variable <code>conns</code>). The role of <em>context</em> in <strong>event driven</strong> model has already been discussed in <a href="#An-introduction-to-event-driven">introduction</a>.</p><div id="conn_init" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rl) == <span class="number">0</span>) &#123;</span><br><span class="line">        max_fds = rl.rlim_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to query maximum file descriptor; "</span></span><br><span class="line">                        <span class="string">"falling back to maxconns\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((conns = <span class="built_in">calloc</span>(max_fds, <span class="keyword">sizeof</span>(conn *))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to allocate connection structures\n"</span>);</span><br><span class="line">        <span class="comment">/* This is unrecoverable so bail out early. */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">conn_init@memcached.c</text></center><br></div><p>4) Preallocate threads and their associated resources using <a href="#memcached-thread-init">memcached_thread_init</a>.</p><p>5) Setup the socket and first event listener - <code>conn_listening</code>.</p><p>6) Call <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event_8h.html#a76e311cff042dab77125e309315a0617" target="_blank" rel="noopener">event_base_loop</a> to start the <strong>event loop</strong>.</p><p>*) Other miscellaneous system operations, such as setting the signal handler for <code>SIGINT</code> and <code>SIGTERM</code>; <code>setbuf</code> <code>stderr</code> to <code>NULL</code>; dropping the root privileges of the process; and daemonizing. If those names do not ring a bell, $\lt$$\lt$Advanced UNIX Programming$\gt$$\gt$ is your friend.</p><h1 id="Threads-initialization"><a href="#Threads-initialization" class="headerlink" title="Threads initialization"></a>Threads initialization</h1><p>The core data structure of <em>multithreading</em> mechanism is</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;        <span class="comment">/* unique ID of this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span>    <span class="comment">/* libevent handle this thread uses */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">notify_event</span>;</span>  <span class="comment">/* listen event for notify pipe */</span></span><br><span class="line">    <span class="keyword">int</span> notify_receive_fd;      <span class="comment">/* receiving end of notify pipe */</span></span><br><span class="line">    <span class="keyword">int</span> notify_send_fd;         <span class="comment">/* sending end of notify pipe */</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_queue</span> *<span class="title">new_conn_queue</span>;</span> <span class="comment">/* queue of new connections to handle */</span></span><br><span class="line">...<span class="comment">// scr: cas &amp; log</span></span><br><span class="line">&#125; LIBEVENT_THREAD;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">LIBEVENT_THREAD@memcached.h</text></center><h2 id="memcached-thread-init"><a href="#memcached-thread-init" class="headerlink" title="memcached_thread_init"></a>memcached_thread_init</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcached_thread_init</span><span class="params">(<span class="keyword">int</span> nthreads, struct event_base *main_base)</span> </span>&#123;</span><br><span class="line">...<span class="comment">// scr: initialize all sorts of mutexes and condition variables</span></span><br><span class="line"></span><br><span class="line">    threads = <span class="built_in">calloc</span>(nthreads, <span class="keyword">sizeof</span>(LIBEVENT_THREAD)); <span class="comment">// scr:  1)</span></span><br><span class="line">    <span class="keyword">if</span> (! threads) &#123;</span><br><span class="line">        perror(<span class="string">"Can't allocate thread descriptors"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatcher_thread.base = main_base; <span class="comment">// scr: ----------------&gt; 2)</span></span><br><span class="line">    dispatcher_thread.thread_id = pthread_self(); <span class="comment">// scr: ------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (pipe(fds)) &#123; <span class="comment">// scr: -------------------------------&gt; 4)</span></span><br><span class="line">            perror(<span class="string">"Can't create notify pipe"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threads[i].notify_receive_fd = fds[<span class="number">0</span>]; <span class="comment">// scr: ---------&gt; 4)</span></span><br><span class="line">        threads[i].notify_send_fd = fds[<span class="number">1</span>]; <span class="comment">// scr: ------------&gt; 4)</span></span><br><span class="line"></span><br><span class="line">        setup_thread(&amp;threads[i]); <span class="comment">// scr: ---------------------&gt; 5)</span></span><br><span class="line">        <span class="comment">/* Reserve three fds for the libevent base, and two for the pipe */</span></span><br><span class="line">        stats_state.reserved_fds += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create threads after we've done all the libevent setup. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</span><br><span class="line">        create_worker(worker_libevent, &amp;threads[i]); <span class="comment">// scr: ---&gt; 6)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for all the threads to set themselves up before returning. */</span></span><br><span class="line">    pthread_mutex_lock(&amp;init_lock);</span><br><span class="line">    wait_for_thread_registration(nthreads);</span><br><span class="line">    pthread_mutex_unlock(&amp;init_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">conn_init@memcached.c</text></center><p>1) Allocate memory for an array of <a href="#Threads-initialization">LIBEVENT_THREAD</a>. The number of thread is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#num_threads">num_threads</a> Each element represents one thread. As described above, better the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#num_threads">num_threads</a> does not exceed the number of cores.</p><div id="num_threads" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.num_threads = <span class="number">4</span>;         <span class="comment">/* N workers */</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            settings.num_threads = atoi(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Number of threads must be greater than 0\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* There're other problems when you get above 64 threads.</span></span><br><span class="line"><span class="comment">             * In the future we should portably detect # of cores for the</span></span><br><span class="line"><span class="comment">             * default.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &gt; <span class="number">64</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting a high number of worker"</span></span><br><span class="line">                                <span class="string">"threads is not recommended.\n"</span></span><br><span class="line">                                <span class="string">" Set this value to the number of cores in"</span></span><br><span class="line">                                <span class="string">" your machine or less.\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">num_threads@memcached.c</text></center><br></div><p>2) Set the <em>event base</em> for the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#dispatcher_thread">dispatcher_thread</a> which represents the main thread itself. Note that <a href="#" onclick="return false;" data-toggle="collapse" data-target="#dispatcher_thread">dispatcher_thread</a> is a global variable so the reference is accessible to all the <em>worker thread</em>s.</p><div id="dispatcher_thread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> LIBEVENT_DISPATCHER_THREAD dispatcher_thread;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">dispatcher_thread@thread.c</text></center><br></div><p>3) Set the thread id for <a href="#" onclick="return false;" data-toggle="collapse" data-target="#dispatcher_thread">dispatcher_thread</a>.</p><p>4) Initialize the <a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a> <code>fd</code>s for each of the <em>worker thread</em>. Here the <code>notify_send_fd</code> is used for communication between <em>dispatcher thread</em> and <em>worker thread</em>s - whenever the <em>dispatcher thread</em> <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener">write</a>s to <code>notify_send_fd</code>, an <strong>event</strong> is generated on the other side, <code>notify_receive_fd</code>, which is listened by <em>worker thread</em>s. Again, $\lt$$\lt$Advanced UNIX Programming$\gt$$\gt$ gives more information about <code>pipe</code>.</p><p>5) The full method name is supposed to be <code>setup_libevent_for_each_thread</code>. Will examine this method in the <a href="#setup-thread">next section</a>.</p><p>6) Call <a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html" target="_blank" rel="noopener">pthread_create</a> to create the actual <em>worker threads</em>. Will examine this method in <a href="#create-worker">create_worker</a>.</p><h2 id="setup-thread"><a href="#setup-thread" class="headerlink" title="setup_thread"></a>setup_thread</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_thread</span><span class="params">(LIBEVENT_THREAD *me)</span> </span>&#123;</span><br><span class="line">    me-&gt;base = event_init(); <span class="comment">// scr: ---------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">if</span> (! me-&gt;base) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't allocate event base\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Listen for notifications from other threads */</span></span><br><span class="line">    event_set(&amp;me-&gt;notify_event, me-&gt;notify_receive_fd, <span class="comment">// scr: &gt; 2)</span></span><br><span class="line">              EV_READ | EV_PERSIST, thread_libevent_process, me);</span><br><span class="line">    event_base_set(me-&gt;base, &amp;me-&gt;notify_event); <span class="comment">// scr: -------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event_add(&amp;me-&gt;notify_event, <span class="number">0</span>) == <span class="number">-1</span>) &#123; <span class="comment">// scr: -------&gt; 2)</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't monitor libevent notify pipe\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me-&gt;new_conn_queue = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct conn_queue)); <span class="comment">//scr:3)</span></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;new_conn_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Failed to allocate memory for connection queue"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    cq_init(me-&gt;new_conn_queue);</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: stat &amp; cas</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">setup_thread@thread.c</text></center><p>1) Call <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6" target="_blank" rel="noopener">event_init</a> to initialize the <strong>libevent</strong> instance for the <em>worker thread</em>. As discussed in <a href="#Thread-model">thread model</a>, each <em>worker thread</em> runs its own <strong>drive machine</strong>.</p><p>2) Set the <code>thread_libevent_process</code> as the callback of events emitted from the discussed <code>notify_receive_fd</code>. The major function of <code>thread_libevent_process</code> is to link the actual <strong>drive machine</strong> to <strong>event</strong>s, which we will see very soon in <a href="#thread-libevent-process">inter-thread communication</a>.</p><p>3) Allocate and initialize the connection queue of the <em>worker thread</em>.</p><h2 id="create-worker"><a href="#create-worker" class="headerlink" title="create_worker"></a>create_worker</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create_worker</span><span class="params">(<span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span>  attr;</span><br><span class="line">    <span class="keyword">int</span>             ret;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = pthread_create(&amp;((LIBEVENT_THREAD*)arg)-&gt;thread_id, &amp;attr, func, arg)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't create thread: %s\n"</span>,</span><br><span class="line">                strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">create_worker@thread.c</text></center><p>As mentioned, this method calls <a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html" target="_blank" rel="noopener">pthread_create</a> to create the actual <em>worker thread</em>s. The callback passed through is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#worker_libevent">worker_libevent</a> which essentially starts the <strong>event loop</strong> using <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event_8h.html#a76e311cff042dab77125e309315a0617" target="_blank" rel="noopener">event_base_loop</a>, this time, on <em>worker thread</em>s rather than <em>dispatch thread</em>.</p><div id="worker_libevent" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">worker_libevent</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    LIBEVENT_THREAD *me = arg;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    event_base_loop(me-&gt;base, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">worker_libevent@thread.c</text></center><br></div><h1 id="Socket-initialization"><a href="#Socket-initialization" class="headerlink" title="Socket initialization"></a>Socket initialization</h1><p>The methods involved in socket initialization reconcile the initialization of both <em>TCP</em> and <em>UDP</em> while the following discussion covers only the <em>TCP</em> logic branch. And we consider <a href="#" onclick="return false;" data-toggle="collapse" data-target="#portnumber_file">portnumber_file</a> is not set so as to focus on the critical path.</p><div id="portnumber_file" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *portnumber_filename = getenv(<span class="string">"MEMCACHED_PORT_FILENAME"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (portnumber_filename != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(portnumber_filename)+<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">    temp_portnumber_filename = <span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="built_in">snprintf</span>(temp_portnumber_filename,</span><br><span class="line">             len,</span><br><span class="line">             <span class="string">"%s.lck"</span>, portnumber_filename);</span><br><span class="line"></span><br><span class="line">    portnumber_file = fopen(temp_portnumber_filename, <span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">if</span> (portnumber_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to open \"%s\": %s\n"</span>,</span><br><span class="line">                temp_portnumber_filename, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:6029</text></center><br></div><p>Unlike <em>worker thread</em>s that listen to internal (<a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a>) <code>fd</code>s, <em>dispatch thread</em> is responsible for <strong>event</strong>s generated from external socket <code>fd</code>s (by network requests). The method that initializes sockets is <code>server_sockets</code>.</p><p>If network interface is not indicated by <a href="#" onclick="return false;" data-toggle="collapse" data-target="#inter">inter</a>, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#server_sockets">server_sockets</a> is equivalent to</p><div id="inter" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.inter = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:209</text></center><br></div><div id="server_sockets" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">server_sockets</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">enum</span> network_transport transport,</span></span></span><br><span class="line"><span class="function"><span class="params">                          FILE *portnumber_file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (settings.inter == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> server_socket(settings.inter, port, transport, portnumber_file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">server_sockets@memcached.c</text></center><br></div><h2 id="server-socket"><a href="#server-socket" class="headerlink" title="server_socket"></a>server_socket</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">server_socket</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *interface,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">enum</span> network_transport transport,</span></span></span><br><span class="line"><span class="function"><span class="params">                         FILE *portnumber_file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">ling</span> = &#123;</span><span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span> = &#123;</span> .ai_flags = AI_PASSIVE,</span><br><span class="line">                              .ai_family = AF_UNSPEC &#125;;</span><br><span class="line">    <span class="keyword">char</span> port_buf[NI_MAXSERV];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> success = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flags =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">-1</span>) &#123;</span><br><span class="line">        port = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(port_buf, <span class="keyword">sizeof</span>(port_buf), <span class="string">"%d"</span>, port);</span><br><span class="line">    error= getaddrinfo(interface, port_buf, &amp;hints, &amp;ai); <span class="comment">// scr: 1)</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (next= ai; next; next= next-&gt;ai_next) &#123; <span class="comment">// scr: --------&gt; 2)</span></span><br><span class="line">        conn *listen_conn_add;</span><br><span class="line">        <span class="keyword">if</span> ((sfd = new_socket(next)) == <span class="number">-1</span>) &#123; <span class="comment">// scr: ----------&gt; 3)</span></span><br><span class="line">            <span class="comment">/* getaddrinfo can return "junk" addresses,</span></span><br><span class="line"><span class="comment">             * we make sure at least one works before erroring.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">                <span class="comment">/* ...unless we're out of fds */</span></span><br><span class="line">                perror(<span class="string">"server_socket"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 4)</span></span><br><span class="line">        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</span><br><span class="line">        <span class="keyword">if</span> (IS_UDP(transport)) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">"setsockopt"</span>);</span><br><span class="line"></span><br><span class="line">            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (<span class="keyword">void</span> *)&amp;ling, <span class="keyword">sizeof</span>(ling));</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">"setsockopt"</span>);</span><br><span class="line"></span><br><span class="line">            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">"setsockopt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (bind(sfd, next-&gt;ai_addr, next-&gt;ai_addrlen) == <span class="number">-1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            success++;</span><br><span class="line">            <span class="keyword">if</span> (!IS_UDP(transport) &amp;&amp; listen(sfd, settings.backlog) == <span class="number">-1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (portnumber_file != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IS_UDP(transport)) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ---------------------------------------&gt; 6)</span></span><br><span class="line">            <span class="keyword">if</span> (!(listen_conn_add = conn_new(sfd, conn_listening,</span><br><span class="line">                                             EV_READ | EV_PERSIST, <span class="number">1</span>,</span><br><span class="line">                                             transport, main_base))) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to create listening connection\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            listen_conn_add-&gt;next = listen_conn; <span class="comment">// scr: -------&gt; 7)</span></span><br><span class="line">            listen_conn = listen_conn_add;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeaddrinfo(ai);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return zero iff we detected no errors in starting up connections */</span></span><br><span class="line">    <span class="keyword">return</span> success == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">server_socket@memcached.c</text></center><p>1) Get all the available network interfaces.</p><p>2) Iterate all the network interfaces and setup the sockets with the following steps.</p><p>3) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#new_socket">new_socket</a> encapsulates the operation of <a href="http://man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="noopener">socket</a> creation as well as that of setting it to non-block.</p><div id="new_socket" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">new_socket</span><span class="params">(struct addrinfo *ai)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sfd = socket(ai-&gt;ai_family, ai-&gt;ai_socktype, ai-&gt;ai_protocol)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags = fcntl(sfd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span> ||</span><br><span class="line">        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setting O_NONBLOCK"</span>);</span><br><span class="line">        close(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">new_socket@memcached.c</text></center><br></div><p>4) Tweak the newly created <a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank" rel="noopener">socket</a> <code>fd</code> using <a href="http://man7.org/linux/man-pages/man2/setsockopt.2.html" target="_blank" rel="noopener">setsockopt</a>, in which</p><p><code>SO_REUSEADDR</code> allows binding to a port in <code>TIME_WAIT</code>. This is useful for instantly rebooting a server on a “not fresh” TCP port;</p><p><code>SO_KEEPALIVE</code> sends heartbeats to detect an absent client, and to release the resource for network connection in both kernel and user space; <a href="/network-essentials-setsockopt-SO_KEEPALIVE/">learn more</a></p><p><code>SO_LINGER</code> enables fast close of a connection on <code>RST</code>; <a href="http://deepix.github.io/2016/10/21/tcprst.html" target="_blank" rel="noopener">learn more</a></p><p><code>TCP_NODELAY</code> disables <em>nagle</em> to improve latency. <a href="/network-essentials-setsockopt-TCP_NODELAY/">learn more</a></p><p>5) <a href="http://man7.org/linux/man-pages/man2/bind.2.html" target="_blank" rel="noopener">bind</a> and start <a href="http://man7.org/linux/man-pages/man2/listen.2.html" target="_blank" rel="noopener">listen</a>ing to the <code>fd</code>.</p><p>6) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#conn_new">conn_new</a> initializes the <em>context</em> for the <code>fd</code> and adds it to <strong>libevent</strong> with initial <strong>state</strong> set to <code>conn_listening</code> and callback as <code>event_handler</code>. Here <code>event_handler</code> is another transient method leading to the <strong>drive machine</strong> on <em>dispatcher thread</em>. Likewise, this method will be discussed soon in <a href="#event-handler">inter-thread communication</a>.</p><div id="conn_new" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">conn *<span class="title">conn_new</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> sfd, <span class="keyword">enum</span> conn_states init_state,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">int</span> event_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">int</span> read_buffer_size, <span class="keyword">enum</span> network_transport transport,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct event_base *base)</span> </span>&#123;</span><br><span class="line">    conn *c;</span><br><span class="line">...<span class="comment">// scr: initialize context conn</span></span><br><span class="line">    c-&gt;state = init_state;</span><br><span class="line">...<span class="comment">// scr: initialize context conn</span></span><br><span class="line"></span><br><span class="line">    event_set(&amp;c-&gt;event, sfd, event_flags, event_handler, (<span class="keyword">void</span> *)c);</span><br><span class="line">    event_base_set(base, &amp;c-&gt;event);</span><br><span class="line">    c-&gt;ev_flags = event_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event_add(&amp;c-&gt;event, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"event_add"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:120</text></center><br></div><p>7) Add the <em>context</em> to the head of a global list <a href="#" onclick="return false;" data-toggle="collapse" data-target="#listen_conn">listen_conn</a>.</p><div id="listen_conn" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> conn *listen_conn = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:120</text></center><br></div><p>Next we briefly go through the process that handles a new connection to wrap up the</p><h1 id="Inter-thread-communication"><a href="#Inter-thread-communication" class="headerlink" title="Inter-thread communication"></a>Inter-thread communication</h1><p><img src="/gallery/threads-comm.png" alt="Inter-thread communication"></p><h2 id="event-handler"><a href="#event-handler" class="headerlink" title="event_handler"></a>event_handler</h2><p>Firstly, after a TCP connection completes, the <code>fd</code> monitored by <em>dispatcher thread</em> notifies <strong>libevent</strong>, which invokes the mentioned <a href="#" onclick="return false;" data-toggle="collapse" data-target="#event_handler">event_handler</a>. Next, the logic flow enters the code snippet we got in the beginning - the <strong>drive machine</strong>, with <em>context</em> <strong>state</strong> initialized as <code>conn_listening</code> in <a href="#Socket-initialization">socket initialization</a>.</p><div id="event_handler" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_handler</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> fd, <span class="keyword">const</span> short which, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    conn *c;</span><br><span class="line"></span><br><span class="line">    c = (conn *)arg;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    c-&gt;which = which;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sanity */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    drive_machine(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait for next event */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">event_handler@memcached.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(c-&gt;state) &#123;</span><br><span class="line">        <span class="keyword">case</span> conn_listening:</span><br><span class="line">            addrlen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">...</span><br><span class="line">                  <span class="comment">// scr: --------------------------------------&gt; 1)</span></span><br><span class="line">            sfd = accept(c-&gt;sfd, (struct sockaddr *)&amp;addr, &amp;addrlen);</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (sfd == <span class="number">-1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (settings.maxconns_fast &amp;&amp;</span><br><span class="line">                stats_state.curr_conns + stats_state.reserved_fds &gt;= settings.maxconns - <span class="number">1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// scr: ----------------------------------------&gt; 2)</span></span><br><span class="line">                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,</span><br><span class="line">                                     DATA_BUFFER_SIZE, c-&gt;transport);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">drive_machine@memcached.c</text></center><p>At this stage, the <strong>drive machine</strong> 1) <a href="http://man7.org/linux/man-pages/man2/accept.2.html" target="_blank" rel="noopener">accept</a>s the connection and derives another <code>fd</code> that can be <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener">read</a> from. It 2) then calls <code>dispatch_conn_new</code> with the new <code>fd</code> and other relevant information including the next <strong>state</strong>, <code>conn_new_cmd</code>.</p><h2 id="dispatch-conn-new"><a href="#dispatch-conn-new" class="headerlink" title="dispatch_conn_new"></a>dispatch_conn_new</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_conn_new</span><span class="params">(<span class="keyword">int</span> sfd, <span class="keyword">enum</span> conn_states init_state, <span class="keyword">int</span> event_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> read_buffer_size, <span class="keyword">enum</span> network_transport transport)</span> </span>&#123;</span><br><span class="line">    CQ_ITEM *item = cqi_new();</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tid = (last_thread + <span class="number">1</span>) % settings.num_threads; <span class="comment">// scr: &gt; 1)</span></span><br><span class="line"></span><br><span class="line">    LIBEVENT_THREAD *thread = threads + tid; <span class="comment">// scr: -----------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">    last_thread = tid; <span class="comment">// scr: ---------------------------------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">    item-&gt;sfd = sfd; <span class="comment">// scr: -----------------------------------&gt; 2)</span></span><br><span class="line">    item-&gt;init_state = init_state;</span><br><span class="line">    item-&gt;event_flags = event_flags;</span><br><span class="line">    item-&gt;read_buffer_size = read_buffer_size;</span><br><span class="line">    item-&gt;transport = transport;</span><br><span class="line"></span><br><span class="line">    cq_push(thread-&gt;new_conn_queue, item); <span class="comment">// scr: -------------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    MEMCACHED_CONN_DISPATCH(sfd, thread-&gt;thread_id);</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">'c'</span>;</span><br><span class="line">    <span class="keyword">if</span> (write(thread-&gt;notify_send_fd, buf, <span class="number">1</span>) != <span class="number">1</span>) &#123; <span class="comment">// scr: --&gt; 4)</span></span><br><span class="line">        perror(<span class="string">"Writing to thread notify pipe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">dispatch_conn_new@thread.c</text></center><p>1) Round robin the threads established in <a href="#Threads-initialization">threads initialization</a>.</p><p>2) Initializes a <a href="#" onclick="return false;" data-toggle="collapse" data-target="#CQ_ITEM">CQ_ITEM</a> instance. Here <a href="#" onclick="return false;" data-toggle="collapse" data-target="#CQ_ITEM">CQ_ITEM</a> is an intermediate object passed to <em>worker thread</em>s through <em>connection queue</em>, so <em>worker thread</em>s can create new <em>context</em> based on it.</p><div id="CQ_ITEM" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">conn_queue_item</span> <span class="title">CQ_ITEM</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_queue_item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>               sfd;</span><br><span class="line">    <span class="keyword">enum</span> conn_states  init_state;</span><br><span class="line">    <span class="keyword">int</span>               event_flags;</span><br><span class="line">    <span class="keyword">int</span>               read_buffer_size;</span><br><span class="line">    <span class="keyword">enum</span> network_transport     transport;</span><br><span class="line">    CQ_ITEM          *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">CQ_ITEM@thread.c</text></center><br></div><p>3) Push <a href="#" onclick="return false;" data-toggle="collapse" data-target="#CQ_ITEM">CQ_ITEM</a> to the <em>connection queue</em>.</p><p>4) Write to <code>notify_send_fd</code> with the command <code>&#39;c&#39;</code>.</p><p>As discussed <a href="#memcached-thread-init">before</a>, 4) generates an <strong>event</strong> on the other side of the <a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a> (on the chosen <em>worker thread</em>), which invokes</p><h2 id="thread-libevent-process"><a href="#thread-libevent-process" class="headerlink" title="thread_libevent_process"></a>thread_libevent_process</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_libevent_process</span><span class="params">(<span class="keyword">int</span> fd, short which, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    LIBEVENT_THREAD *me = arg;</span><br><span class="line">    CQ_ITEM *item;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> timeout_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">1</span>) != <span class="number">1</span>) &#123; <span class="comment">// scr: -----------------------&gt; 1)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't read from libevent pipe\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (buf[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">        item = cq_pop(me-&gt;new_conn_queue); <span class="comment">// scr: -------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != item) &#123;</span><br><span class="line">            conn *c = conn_new(item-&gt;sfd, item-&gt;init_state, item-&gt;event_flags,</span><br><span class="line">                               item-&gt;read_buffer_size, item-&gt;transport,</span><br><span class="line">                               me-&gt;base); <span class="comment">// scr: --------------&gt; 3)</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c-&gt;thread = me; <span class="comment">// scr: ------------------------&gt; 4)</span></span><br><span class="line">            &#125;</span><br><span class="line">            cqi_free(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* we were told to pause and report in */</span></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">thread_libevent_process@thread.c</text></center><p>1) Read the command (i.e., <code>&#39;c&#39;</code>) from the <a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a>.</p><p>2) Read the <code>CQ_ITEM</code> from the <em>connection queue</em>.</p><p>3) Call <code>conn_new</code>. In <a href="#server-socket">server_socket</a> we know that <code>conn_new</code> establishes the <em>context</em>, this time, for the new connection, and adds the <a href="http://man7.org/linux/man-pages/man2/accept.2.html" target="_blank" rel="noopener">accept</a>ed <code>fd</code> to <strong>libevent</strong>. Here on <em>worker thread</em>, the callback is set to <code>event_handler</code>, which essentially connects the <strong>drive machine</strong> to the upcoming <strong>event</strong>s on the same connection.</p><p>4) Set the <a href="#Threads-initialization">thread information</a> to the context.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf" target="_blank" rel="noopener">Why Threads Are A Bad Idea</a></p><p>W. Richard Stevens. 1992. Advanced Programming in the UNIX Environment. Addison Wesley Longman Publishing Co., Inc., Redwood City, CA, USA. </p><p><a href="http://deepix.github.io/2016/10/21/tcprst.html" target="_blank" rel="noopener">Resetting a TCP connection and SO_LINGER</a></p><p><a href="https://www.usenix.org/legacy/publications/library/proceedings/usenix99/full_papers/pai/pai_html/node7.html" target="_blank" rel="noopener">Single-process event-driven</a></p>]]></content>
    
    <summary type="html">
    
      In classic multithreading, large amounts of slow and blocking operations, mostly, I/O, can easily drain out available thread resources, which severely constrains the maximum number of requests a server can handle per unit time. More specific, threads are scheduled out and put into sleep in the middle of procedures that contain blocking I/O, despite piling up requests packets queuing within the network stack. In such situation, server side will show low throughput, low CPU saturation and high latency.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="socket" scheme="https://holmeshe.me/tags/socket/"/>
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="event driven" scheme="https://holmeshe.me/tags/event-driven/"/>
    
      <category term="state machine" scheme="https://holmeshe.me/tags/state-machine/"/>
    
      <category term="multithreading" scheme="https://holmeshe.me/tags/multithreading/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - LRU III</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-VI/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-VI/</id>
    <published>2018-12-23T22:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I, </text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;"> II, </text></a> <a href="#"><text style="color:black;font-weight:bold;"> III - this article)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>In previous posts, we have discussed different facets of an <strong>item</strong>, i.e., <strong>slab</strong>, <strong>hash map</strong> and <strong>LRU list</strong> as well as their associated (CRUD) methods, which build up the internal procedures and perform client requests after the corresponding commands are parsed by the <strong>drive machine</strong>. This time we will go through those procedures by issuing <em>telnet commands</em> to a <strong>Memcached</strong> instance and see how the discussed modules work together on various <strong>item</strong> operations. We will also see the whole picture of <strong>LRU list</strong>s that maintain the property of ‘least recently used’ in accordance to those operations.</p><a id="more"></a><p>On top of standard <strong>LRU</strong> algorithm, the <strong>Memcached</strong> (1.4.28) emploies <code>3</code> lists instead of just <code>1</code>, i.e., hot, warm and cold, a.k.a., <a href="https://memcached.org/blog/modern-lru/" target="_blank" rel="noopener">Segmented LRU</a> for each <strong>slab class</strong>. This heuristic is implemented to reduce the lock contention between <strong>item</strong> <em>bumping</em> (an <a href="/understanding-memcached-source-code-IV/#Linked-list">action</a> that moves recently accessed <strong>item</strong> to the list head) and <strong>item</strong> read. Moreover, unlike a casual implementation (such as the one I coded), <strong>Memcached</strong> does not <em>bump</em> <strong>item</strong> right on <a href="#opt1">read action</a>. Rather, the <em>bumping</em> is delayed to <a href="#opt2">other operations when the resource is in short</a>, which could reflect <strong>Memcached</strong>‘s read-first design decision.</p><blockquote><p>In normal use cases, let’s say, a social media, the volume of read requests are more than that of other operations combined by orders of magnitude, hence it’s a critical point that worth extensive optimizations, I suppose.</p></blockquote><p>We start this post by issuing an <strong>item</strong> read command to a <strong>Memcached</strong> instance.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~telnet localhost 11211</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">...// add some items</span><br><span class="line">&gt; get test</span><br></pre></td></tr></table></figure><h1 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h1><p>The the normal execution of this procedure,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line">1 |~Drive machine &amp; command parser</span><br><span class="line">    |-process_get_command</span><br><span class="line">++    |-item_get</span><br><span class="line">        |-assoc_find    (LRU II)</span><br><span class="line">      |-item_update</span><br><span class="line">        |-item_unlink_q (LRU I)</span><br><span class="line">        |-item_link_q   (LRU I)</span><br></pre></td></tr></table></figure><h2 id="process-get-command"><a href="#process-get-command" class="headerlink" title="process_get_command"></a>process_get_command</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">process_get_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">size_t</span> ntokens, <span class="keyword">bool</span> return_cas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">token_t</span> *key_token = &amp;tokens[KEY_TOKEN];</span><br><span class="line">    <span class="keyword">char</span> *suffix;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(key_token-&gt;length != <span class="number">0</span>) &#123; <span class="comment">// scr: -----------------&gt; *)</span></span><br><span class="line"></span><br><span class="line">            key = key_token-&gt;value;</span><br><span class="line">            nkey = key_token-&gt;length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nkey &gt; KEY_MAX_LENGTH) &#123;</span><br><span class="line">                out_string(c, <span class="string">"CLIENT_ERROR bad command line format"</span>);</span><br><span class="line">                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    item_remove(*(c-&gt;ilist + i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it = item_get(key, nkey, c); <span class="comment">// scr: ----------------&gt; 1)</span></span><br><span class="line">            <span class="keyword">if</span> (settings.detail_enabled) &#123;</span><br><span class="line">                stats_prefix_record_get(key, nkey, <span class="literal">NULL</span> != it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= c-&gt;isize) &#123; <span class="comment">// scr: --------------------&gt; *)</span></span><br><span class="line">                    item **new_list = <span class="built_in">realloc</span>(c-&gt;ilist, <span class="keyword">sizeof</span>(item *) * c-&gt;isize * <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">if</span> (new_list) &#123;</span><br><span class="line">                        c-&gt;isize *= <span class="number">2</span>;</span><br><span class="line">                        c-&gt;ilist = new_list;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">                        item_remove(it);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (return_cas)</span><br><span class="line">                &#123;</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  MEMCACHED_COMMAND_GET(c-&gt;sfd, ITEM_key(it), it-&gt;nkey,</span><br><span class="line">                                        it-&gt;nbytes, ITEM_get_cas(it));</span><br><span class="line">                  <span class="keyword">if</span> (add_iov(c, <span class="string">"VALUE "</span>, <span class="number">6</span>) != <span class="number">0</span> || <span class="comment">// scr: ---&gt; *)</span></span><br><span class="line">                      add_iov(c, ITEM_key(it), it-&gt;nkey) != <span class="number">0</span> ||</span><br><span class="line">                      add_iov(c, ITEM_suffix(it), it-&gt;nsuffix + it-&gt;nbytes) != <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          item_remove(it);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: verbose &amp; stat</span></span><br><span class="line"></span><br><span class="line">                item_update(it); <span class="comment">// scr: ------------------------&gt; 2)</span></span><br><span class="line">                *(c-&gt;ilist + i) = it;</span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key_token++; <span class="comment">// scr: --------------------------------&gt; *)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the command string hasn't been fully processed, get the next set</span></span><br><span class="line"><span class="comment">         * of tokens.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(key_token-&gt;value != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: ------------------&gt; *)</span></span><br><span class="line">            ntokens = tokenize_command(key_token-&gt;value, tokens, MAX_TOKENS);</span><br><span class="line">            key_token = tokens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(key_token-&gt;value != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    c-&gt;icurr = c-&gt;ilist;</span><br><span class="line">    c-&gt;ileft = i;</span><br><span class="line">... <span class="comment">// scr: cas &amp; verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key_token-&gt;value != <span class="literal">NULL</span> || add_iov(c, <span class="string">"END\r\n"</span>, <span class="number">5</span>) != <span class="number">0</span></span><br><span class="line">        || (IS_UDP(c-&gt;transport) &amp;&amp; build_udp_headers(c) != <span class="number">0</span>)) &#123;</span><br><span class="line">        out_of_memory(c, <span class="string">"SERVER_ERROR out of memory writing get response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// scr: ----------------------------------------------&gt; *)</span></span><br><span class="line">        conn_set_state(c, conn_mwrite);</span><br><span class="line">        c-&gt;msgcurr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_get_command@memcached.c</text></center><p>The only relevant step here are 1) <code>item_get</code> and 2) <code>item_update</code>. Steps marked as *) are mostly command parsing and I/O which will be discussed in later posts when we examine <strong>event driven</strong> mechanism.</p><h2 id="do-item-get"><a href="#do-item-get" class="headerlink" title="do_item_get"></a>do_item_get</h2><p>Like other methods discussed before, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_get">item_get</a> is a thread-safe wrapper of <code>do_item_get</code>.</p><div id="item_get" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">item_get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, conn *c)</span> </span>&#123;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(key, nkey);</span><br><span class="line">    item_lock(hv);</span><br><span class="line">    it = do_item_get(key, nkey, hv, c);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_get@thread.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">do_item_get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv, conn *c)</span> </span>&#123;</span><br><span class="line">    item *it = assoc_find(key, nkey, hv); <span class="comment">// scr: -----------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        refcount_incr(&amp;it-&gt;refcount); <span class="comment">// scr: ---------------------&gt; 2)</span></span><br><span class="line">...<span class="comment">// scr: comments</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> was_found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        was_found = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (item_is_flushed(it)) &#123;</span><br><span class="line">...<span class="comment">// scr: item flush</span></span><br><span class="line"><span class="comment">// scr: -----------------------------------------------------------&gt; 3)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;exptime != <span class="number">0</span> &amp;&amp; it-&gt;exptime &lt;= current_time) &#123;</span><br><span class="line">            do_item_unlink(it, hv);</span><br><span class="line">            do_item_remove(it);</span><br><span class="line">            it = <span class="literal">NULL</span>;</span><br><span class="line">...<span class="comment">// scr: stat &amp; verbose</span></span><br><span class="line">            was_found = <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ------------------------------------------&gt; 4)</span></span><br><span class="line">            it-&gt;it_flags |= ITEM_FETCHED|ITEM_ACTIVE;</span><br><span class="line">            DEBUG_REFCNT(it, <span class="string">'+'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_get@items.c</text></center><p>1) Use the discussed <a href="/understanding-memcached-source-code-V/#assoc-find">assoc_find</a> to locate the <strong>item</strong> using the <em>hash key</em>.</p><p>2) Increase the discussed <a href="/understanding-memcached-source-code-IV/#do-item-link">reference count</a>.</p><p>3) If the <strong>item</strong> has expired, remove it. Note that <code>do_item_unlink</code> decreases the reference count held by the last step, and <code>do_item_remove</code> actually removes the <strong>item</strong>. These two methods will be discussed soon in <a href="#Delete">item delete</a>.</p><a href="#" id="opt1" style="visibility: hidden"></a><p>4) Simply mark the <strong>item</strong> as <code>ITEM_ACTIVE</code> rather than perform <strong>item</strong> <em>bumping</em> which is offloaded to other operations associated procedures. This is part of the heuristic discussed in the beginning.</p><h2 id="do-item-update"><a href="#do-item-update" class="headerlink" title="do_item_update"></a>do_item_update</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_update">item_update</a> is a thread-safe wrapper of <code>do_item_update</code>.<br><br><div id="item_update" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_update</span><span class="params">(item *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(ITEM_key(item), item-&gt;nkey);</span><br><span class="line"></span><br><span class="line">    item_lock(hv);</span><br><span class="line">    do_item_update(item);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_update@thread.c</text></center><p></p></div><p></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_update</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    MEMCACHED_ITEM_UPDATE(ITEM_key(it), it-&gt;nkey, it-&gt;nbytes);</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;time &lt; current_time - ITEM_UPDATE_INTERVAL) &#123;</span><br><span class="line">        assert((it-&gt;it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">            it-&gt;time = current_time; <span class="comment">// scr: ----------------------&gt; 1)</span></span><br><span class="line">            <span class="keyword">if</span> (!settings.lru_maintainer_thread) &#123;</span><br><span class="line">                item_unlink_q(it);</span><br><span class="line">                item_link_q(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_update@items.c</text></center><p>1) The only line effective in this method is to set the access time for the <strong>item</strong> in (passively) an <a href="#" onclick="return false;" data-toggle="collapse" data-target="#interval">interval</a> of 60 seconds. <a href="#" onclick="return false;" data-toggle="collapse" data-target="#lru_maintainer_thread">lru_maintainer_thread</a> is set to <code>true</code> by command line argument <code>modern</code> so the operations inside <code>if (!settings.lru_maintainer_thread)</code> is not applicable.</p><div id="interval" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_UPDATE_INTERVAL 60</span></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.h:73</text></center><br></div><div id="lru_maintainer_thread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> MODERN:</span><br><span class="line">...</span><br><span class="line">    start_lru_maintainer = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5828</text></center><br></div><p>Next, </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; delete test</span><br></pre></td></tr></table></figure><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>Call stack in normal execution,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line">1 |~Drive machine &amp; command parser</span><br><span class="line">    |-process_delete_command</span><br><span class="line">++    |-do_item_get</span><br><span class="line">      |-do_item_unlink</span><br><span class="line">        |-assoc_delete    (LRU II)</span><br><span class="line">        |-item_unlink_q   (LRU I)</span><br><span class="line">--      |-do_item_remove</span><br><span class="line">--    |-do_item_remove</span><br><span class="line">        |-do_item_free</span><br><span class="line">          |-do_slabs_free (Slab II)</span><br></pre></td></tr></table></figure><h2 id="process-delete-command"><a href="#process-delete-command" class="headerlink" title="process_delete_command"></a>process_delete_command</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_delete_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">const</span> <span class="keyword">size_t</span> ntokens)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    item *it;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    key = tokens[KEY_TOKEN].value;</span><br><span class="line">    nkey = tokens[KEY_TOKEN].length;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: sanity check &amp; stat</span></span><br><span class="line"></span><br><span class="line">    it = item_get(key, nkey, c); <span class="comment">// scr: -------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">if</span> (it) &#123;</span><br><span class="line">        MEMCACHED_COMMAND_DELETE(c-&gt;sfd, ITEM_key(it), it-&gt;nkey);</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">        item_unlink(it); <span class="comment">// scr: ---------------------------------&gt; 2)</span></span><br><span class="line">        item_remove(it);      <span class="comment">/* release our reference */</span></span><br><span class="line">        out_string(c, <span class="string">"DELETED"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">        out_string(c, <span class="string">"NOT_FOUND"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_delete_command@memcached.c</text></center><p>1) Get the <strong>item</strong> using <code>item_get</code> discussed in last section. Note that the reference count is increased in <code>item_get</code>.</p><p>2) Delete it.</p><h2 id="do-item-unlink"><a href="#do-item-unlink" class="headerlink" title="do_item_unlink"></a>do_item_unlink</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_unlink">item_unlink</a> is a thread safe wrapper of <code>do_item_unlink</code>.<br><br><div id="item_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_unlink</span><span class="params">(item *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(ITEM_key(item), item-&gt;nkey);</span><br><span class="line">    item_lock(hv);</span><br><span class="line">    do_item_unlink(item, hv);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_unlink@thread.c</text></center><p></p></div><p></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_unlink</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_LINKED;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">        assoc_delete(ITEM_key(it), it-&gt;nkey, hv); <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">        item_unlink_q(it); <span class="comment">// scr: -------------------------------&gt; 2)</span></span><br><span class="line">        do_item_remove(it); <span class="comment">// scr: ------------------------------&gt; 3)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@items.c</text></center><p>1) As discussed in last post, <a href="/understanding-memcached-source-code-IV/#assoc-delete-remove-from-hash-map">assoc_delete</a> removes the <strong>item</strong> from the <em>hash map</em>; and</p><p>2) <a href="/understanding-memcached-source-code-IV/#item-unlink-q-remove-from-linked-list">item_unlink_q</a> removes the <strong>item</strong> from the <strong>LRU list</strong> that the <strong>item</strong> belongs to.</p><p>3) This time <code>do_item_remove</code> simply decreases the reference count. The <strong>item</strong> will be removed when <code>do_item_remove</code> is called the second time from</p><h2 id="do-item-remove"><a href="#do-item-remove" class="headerlink" title="do_item_remove"></a>do_item_remove</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_remove">item_remove</a> is a thread safe wrapper of <code>do_item_remove</code>.<br><br><div id="item_remove" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_remove</span><span class="params">(item *item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hv;</span><br><span class="line">    hv = hash(ITEM_key(item), item-&gt;nkey);</span><br><span class="line"></span><br><span class="line">    item_lock(hv);</span><br><span class="line">    do_item_remove(item);</span><br><span class="line">    item_unlock(hv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_remove@thread.c</text></center><p></p></div><p></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_remove</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (refcount_decr(&amp;it-&gt;refcount) == <span class="number">0</span>) &#123; <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">        item_free(it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_free</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> ntotal = ITEM_ntotal(it);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> clsid;</span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* so slab size changer can tell later if item is already free or not */</span></span><br><span class="line">    clsid = ITEM_clsid(it); <span class="comment">// scr: -------------------------&gt; 2)</span></span><br><span class="line">    DEBUG_REFCNT(it, <span class="string">'F'</span>);</span><br><span class="line">    slabs_free(it, ntotal, clsid); <span class="comment">// scr: ------------------&gt; 3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_remove@items.c</text></center><p>1) Decrease the reference count, if it reaches <code>0</code>, goto 2) and free the <strong>item</strong>.</p><p>2) Use <a href="#" onclick="return false;" data-toggle="collapse" data-target="#ITEM_clsid">ITEM_clsid</a> to get the <em>slab class</em> the <strong>item</strong> belongs. This macro removes the <em>list type</em> from <code>slabs_clsid</code>.</p><div id="ITEM_clsid" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ITEM_clsid(item) ((item)-&gt;slabs_clsid &amp; ~(3&lt;&lt;6))</span></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.h:116</text></center><br></div><p>3) Call <a href="/understanding-memcached-source-code-II/#do-slabs-free">slabs_free</a> to release the memory to slab subsystem.</p><h1 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h1><p>The <strong>Item</strong> creating procedure is divided into several logic fragments by the mentioned <strong>drive machine</strong>, 1) creating an empty <strong>item</strong> object with the <em>key</em> and other <em>meta data</em> sent through; 2) read the value (from the <em>socket</em>) and fill the <strong>item</strong> object with it; and 3) <em>link</em> the <strong>item object</strong>. The workflow controller - <strong>drive machine</strong> will be discussed in the next post.</p><p>Now we send an <code>add</code> command to the <strong>Memcached</strong> instance.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; add test 0 60 11 (\r\n)</span><br><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure><h2 id="Creating-an-empty-item-object"><a href="#Creating-an-empty-item-object" class="headerlink" title="Creating an empty item object"></a>Creating an empty item object</h2><p>After the first line of the above command</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; add test 0 60 11 (\r\n)</span><br></pre></td></tr></table></figure><p>the procedure described in this section starts, the call stack of the hot path is,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line">1 |~Drive machine &amp; command parser</span><br><span class="line">    |-process_update_command</span><br><span class="line">      |-do_item_alloc</span><br><span class="line">        |-slabs_clsid                (Slab III)</span><br><span class="line">++      |-do_slabs_alloc             (Slab III)</span><br><span class="line">        |-lru_pull_tail (on hot list)</span><br><span class="line">          |-do_item_update_nolock    (same to do_item_update)</span><br><span class="line">          |-do_item_remove</span><br><span class="line">          |-item_link_q              (LRU I)</span><br><span class="line">          |-do_item_remove</span><br><span class="line">        |-lru_pull_tail (on warm list)</span><br><span class="line">          |-same as hot list</span><br><span class="line">        |-lru_pull_tail (on cold list)</span><br><span class="line">          |-do_item_unlink_nolock    (same to do_item_unlink LRU I)</span><br></pre></td></tr></table></figure><p>We start from</p><h3 id="process-update-command"><a href="#process-update-command" class="headerlink" title="process_update_command"></a>process_update_command</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_update_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">const</span> <span class="keyword">size_t</span> ntokens, <span class="keyword">int</span> comm, <span class="keyword">bool</span> handle_cas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int32_t</span> exptime_int = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">time_t</span> exptime;</span><br><span class="line">    <span class="keyword">int</span> vlen;</span><br><span class="line">    <span class="keyword">uint64_t</span> req_cas_id=<span class="number">0</span>;</span><br><span class="line">    item *it;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: irrelevant code &amp; sanity checks</span></span><br><span class="line"></span><br><span class="line">    key = tokens[KEY_TOKEN].value; <span class="comment">// scr: ----------------------&gt; 1)</span></span><br><span class="line">    nkey = tokens[KEY_TOKEN].length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! (safe_strtoul(tokens[<span class="number">2</span>].value, (<span class="keyword">uint32_t</span> *)&amp;flags)</span><br><span class="line">           &amp;&amp; safe_strtol(tokens[<span class="number">3</span>].value, &amp;exptime_int)</span><br><span class="line">           &amp;&amp; safe_strtol(tokens[<span class="number">4</span>].value, (<span class="keyword">int32_t</span> *)&amp;vlen))) &#123;</span><br><span class="line">        out_string(c, <span class="string">"CLIENT_ERROR bad command line format"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */</span></span><br><span class="line">    exptime = exptime_int;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: cas &amp; sanity checks</span></span><br><span class="line"></span><br><span class="line">    vlen += <span class="number">2</span>; <span class="comment">// scr: ------------------------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    it = item_alloc(key, nkey, flags, realtime(exptime), vlen); <span class="comment">// 3)</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: cas &amp; error handling</span></span><br><span class="line"></span><br><span class="line">    c-&gt;item = it; <span class="comment">// scr: ---------------------------------------&gt; 4)</span></span><br><span class="line">    c-&gt;ritem = ITEM_data(it);</span><br><span class="line">    c-&gt;rlbytes = it-&gt;nbytes;</span><br><span class="line">    c-&gt;cmd = comm;</span><br><span class="line">    conn_set_state(c, conn_nread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_update_command@memcached.c</text></center><p>1) Set the <em>key</em> (i.e., <code>test</code>), as well as the <em>meta data</em> (i.e., <code>flags</code>, <code>0</code>; <code>exptime</code>, <code>60;</code>vlen<code>,</code>11`), to local variables.</p><p>2) Increase <code>vlen</code> by <code>2</code>, to populate the <code>\n\r</code> in addition to the <em>key</em> string.</p><p>3) Call <code>item_alloc</code> to allocate the memory (from <a href="/understanding-memcached-source-code-III/">slab</a>) for the <strong>item</strong>.</p><p>4) After <code>item_alloc</code> is called, set the properties of <code>conn</code>. Here <code>ritem</code> points to the data portion of an <a href="/understanding-memcached-source-code-IV/#Memory-layout-of-an-item-chunk">item chunk</a>; and <code>rlbytes</code> is set to <code>vlen</code>. These two fields will be used to populate the data portion with the content, i.e., <code>hello world</code>, in the next post.</p><h3 id="do-item-alloc"><a href="#do-item-alloc" class="headerlink" title="do_item_alloc"></a>do_item_alloc</h3><p>Unlike other methods we have discussed, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_alloc">item_alloc</a> is a wrapper of <code>do_item_alloc</code> without adding any locks. I would assume this wrapper is added simply for consistent code style.</p><div id="item_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">size_t</span> nkey, <span class="keyword">int</span> flags, <span class="keyword">rel_time_t</span> exptime, <span class="keyword">int</span> nbytes)</span> </span>&#123;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="comment">/* do_item_alloc handles its own locks */</span></span><br><span class="line">    it = do_item_alloc(key, nkey, flags, exptime, nbytes, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5849</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">do_item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">rel_time_t</span> exptime, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">uint8_t</span> nsuffix;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> suffix[<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> total_chunks;       <span class="comment">// scr: -----------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">size_t</span> ntotal = item_make_header(nkey + <span class="number">1</span>, flags, nbytes, suffix, &amp;nsuffix);</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id = slabs_clsid(ntotal); <span class="comment">// scr: -----------------------&gt; 2)</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If no memory is available, attempt a direct LRU juggle/eviction */</span></span><br><span class="line">    <span class="comment">/* This is a race in order to simplify lru_pull_tail; in cases where</span></span><br><span class="line"><span class="comment">     * locked items are on the tail, you want them to fall out and cause</span></span><br><span class="line"><span class="comment">     * occasional OOM's, rather than internally work around them.</span></span><br><span class="line"><span class="comment">     * This also gives one fewer code path for slab alloc/free</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* Try to reclaim memory first */</span></span><br><span class="line">... <span class="comment">// scr: legacy, no lru_maintainer_thread</span></span><br><span class="line">        it = slabs_alloc(ntotal, id, &amp;total_chunks, <span class="number">0</span>); <span class="comment">// scr: ----------&gt; 3)</span></span><br><span class="line">... <span class="comment">// scr: no-expire setting</span></span><br><span class="line">        <span class="keyword">if</span> (it == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (settings.lru_maintainer_thread) &#123; <span class="comment">// scr: ----------------&gt; 4)</span></span><br><span class="line">                lru_pull_tail(id, HOT_LRU, total_chunks, <span class="literal">false</span>, cur_hv);</span><br><span class="line">                lru_pull_tail(id, WARM_LRU, total_chunks, <span class="literal">false</span>, cur_hv);</span><br><span class="line">                lru_pull_tail(id, COLD_LRU, total_chunks, <span class="literal">true</span>, cur_hv);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: legacy, no lru_maintainer_thread</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: stat &amp; sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Refcount is seeded to 1 by slabs_alloc() */</span></span><br><span class="line">    it-&gt;next = it-&gt;prev = it-&gt;h_next = <span class="number">0</span>; <span class="comment">// scr: ------------------------&gt; 5)</span></span><br><span class="line">    <span class="comment">/* Items are initially loaded into the HOT_LRU. This is '0' but I want at</span></span><br><span class="line"><span class="comment">     * least a note here. Compiler (hopefully?) optimizes this out.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (settings.lru_maintainer_thread) &#123;</span><br><span class="line">... <span class="comment">// scr: no expire setting</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            id |= HOT_LRU; <span class="comment">// scr: ---------------------------------------&gt; 6)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: legacy, no lru_maintainer_thread</span></span><br><span class="line">    &#125;</span><br><span class="line">    it-&gt;slabs_clsid = id; <span class="comment">// scr: ----------------------------------------&gt; 7)</span></span><br><span class="line"></span><br><span class="line">    DEBUG_REFCNT(it, <span class="string">'*'</span>);</span><br><span class="line">    it-&gt;it_flags = settings.use_cas ? ITEM_CAS : <span class="number">0</span>;</span><br><span class="line">    it-&gt;nkey = nkey;</span><br><span class="line">    it-&gt;nbytes = nbytes;</span><br><span class="line">    <span class="built_in">memcpy</span>(ITEM_key(it), key, nkey);</span><br><span class="line">    it-&gt;exptime = exptime;</span><br><span class="line">    <span class="built_in">memcpy</span>(ITEM_suffix(it), suffix, (<span class="keyword">size_t</span>)nsuffix);</span><br><span class="line">    it-&gt;nsuffix = nsuffix;</span><br><span class="line">    <span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_alloc@items.c</text></center><p>1) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_make_header">item_make_header</a> initializes <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">suffix</a> portion of the <a href="/understanding-memcached-source-code-IV/#Memory-layout-of-an-item-chunk">item chunk</a> using the <em>meta data</em> (<code>flags</code>) and <em>key</em>.</p><div id="item_make_header" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">item_make_header</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint8_t</span> nkey, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">char</span> *suffix, <span class="keyword">uint8_t</span> *nsuffix)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* suffix is defined at 40 chars elsewhere.. */</span></span><br><span class="line">    *nsuffix = (<span class="keyword">uint8_t</span>) <span class="built_in">snprintf</span>(suffix, <span class="number">40</span>, <span class="string">" %u %d\r\n"</span>, flags, nbytes - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(item) + nkey + *nsuffix + nbytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_make_header@items.c</text></center><br></div><p>2), 3) are discussed in detail in <a href="/understanding-memcached-source-code-III/">Slab III</a>. To recap, <a href="/understanding-memcached-source-code-III/#slabs-clsid">slabs_clsid</a> select the most optimal <em>slab class</em> and <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">slab_alloc</a> allocates one <strong>item chunk</strong> from <strong>slab</strong> sub-system.</p><p>4) If <code>slab_alloc</code> fails, try to release some memory using <code>lru_pull_tail</code> and retry the allocation for at most <code>5</code> times. <code>lru_pull_tail</code> is the focus of the <a href="#lru-pull-tail">next section</a>.</p><p>5) Initialize the <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">pointers</a> of <strong>LRU list</strong> and <em>hash collision list</em>.</p><p>6) Set the <em>list type</em> (<code>HOT_LRU</code>) to the <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">slabs_clsid</a>, which indicates that this <strong>item</strong> belongs to the “HOT” <strong>LRU list</strong> of its respective <em>slab class</em>.</p><p>7) Initialize <a href="/understanding-memcached-source-code-IV/#Core-data-structure-item">other fields</a> of <strong>item</strong>.</p><h3 id="lru-pull-tail"><a href="#lru-pull-tail" class="headerlink" title="lru_pull_tail"></a>lru_pull_tail</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lru_pull_tail</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> orig_id, <span class="keyword">const</span> <span class="keyword">int</span> cur_lru,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> total_chunks, <span class="keyword">const</span> <span class="keyword">bool</span> do_evict, <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv)</span> </span>&#123;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> id = orig_id; <span class="comment">// scr: ---------------------------------------&gt; p)</span></span><br><span class="line">    <span class="keyword">int</span> removed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tries = <span class="number">5</span>;</span><br><span class="line">    item *search;</span><br><span class="line">    item *next_it;</span><br><span class="line">    <span class="keyword">void</span> *hold_lock = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> move_to_lru = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> limit;</span><br><span class="line"></span><br><span class="line">    id |= cur_lru; <span class="comment">// scr: ------------------------------------------&gt; p)</span></span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[id]);</span><br><span class="line">    search = tails[id]; <span class="comment">// scr: -------------------------------------&gt; p)</span></span><br><span class="line">    <span class="comment">/* We walk up *only* for locked items, and if bottom is expired. */</span></span><br><span class="line">    <span class="keyword">for</span> (; tries &gt; <span class="number">0</span> &amp;&amp; search != <span class="literal">NULL</span>; tries--, search=next_it) &#123;<span class="comment">//s: p)</span></span><br><span class="line">        <span class="comment">/* we might relink search mid-loop, so search-&gt;prev isn't reliable */</span></span><br><span class="line">        next_it = search-&gt;prev; <span class="comment">// scr: -----------------------------&gt; p)</span></span><br><span class="line">...<span class="comment">// scr: irrelevant code here</span></span><br><span class="line">        <span class="keyword">uint32_t</span> hv = hash(ITEM_key(search), search-&gt;nkey);</span><br><span class="line">        <span class="comment">/* Attempt to hash item lock the "search" item. If locked, no</span></span><br><span class="line"><span class="comment">         * other callers can incr the refcount. Also skip ourselves. */</span></span><br><span class="line">        <span class="keyword">if</span> (hv == cur_hv || (hold_lock = item_trylock(hv)) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">/* Now see if the item is refcount locked */</span></span><br><span class="line">        <span class="keyword">if</span> (refcount_incr(&amp;search-&gt;refcount) != <span class="number">2</span>) &#123; <span class="comment">// scr: --------&gt; s)</span></span><br><span class="line">            <span class="comment">/* Note pathological case with ref'ed items in tail.</span></span><br><span class="line"><span class="comment">             * Can still unlink the item, but it won't be reusable yet */</span></span><br><span class="line">            itemstats[id].lrutail_reflocked++;</span><br><span class="line">            <span class="comment">/* In case of refcount leaks, enable for quick workaround. */</span></span><br><span class="line">            <span class="comment">/* WARNING: This can cause terrible corruption */</span></span><br><span class="line">            <span class="keyword">if</span> (settings.tail_repair_time &amp;&amp;</span><br><span class="line">                    search-&gt;time + settings.tail_repair_time &lt; current_time) &#123;</span><br><span class="line">                itemstats[id].tailrepairs++;</span><br><span class="line">                search-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/* This will call item_remove -&gt; item_free since refcnt is 1 */</span></span><br><span class="line">                do_item_unlink_nolock(search, hv);</span><br><span class="line">                item_trylock_unlock(hold_lock);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Expired or flushed */</span> <span class="comment">// scr: ---------------------------&gt; e1)</span></span><br><span class="line">        <span class="keyword">if</span> ((search-&gt;exptime != <span class="number">0</span> &amp;&amp; search-&gt;exptime &lt; current_time)</span><br><span class="line">            || item_is_flushed(search)) &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">            <span class="comment">/* refcnt 2 -&gt; 1 */</span></span><br><span class="line">            do_item_unlink_nolock(search, hv);</span><br><span class="line">            <span class="comment">/* refcnt 1 -&gt; 0 -&gt; item_free */</span></span><br><span class="line">            do_item_remove(search);</span><br><span class="line">            item_trylock_unlock(hold_lock);</span><br><span class="line">            removed++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If all we're finding are expired, can keep going */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we're HOT_LRU or WARM_LRU and over size limit, send to COLD_LRU.</span></span><br><span class="line"><span class="comment">         * If we're COLD_LRU, send to WARM_LRU unless we need to evict</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">switch</span> (cur_lru) &#123;</span><br><span class="line">            <span class="keyword">case</span> HOT_LRU: <span class="comment">// scr: -----------------------------------&gt; 1)</span></span><br><span class="line">                limit = total_chunks * settings.hot_lru_pct / <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> WARM_LRU:</span><br><span class="line">                limit = total_chunks * settings.warm_lru_pct / <span class="number">100</span>; <span class="comment">// 1)</span></span><br><span class="line">                <span class="keyword">if</span> (sizes[id] &gt; limit) &#123; <span class="comment">// scr: --------------------&gt; 2)</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                    move_to_lru = COLD_LRU;</span><br><span class="line">                    do_item_unlink_q(search);</span><br><span class="line">                    it = search;</span><br><span class="line">                    removed++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((search-&gt;it_flags &amp; ITEM_ACTIVE) != <span class="number">0</span>) &#123; <span class="comment">//e3)</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                    search-&gt;it_flags &amp;= ~ITEM_ACTIVE;</span><br><span class="line">                    do_item_update_nolock(search);</span><br><span class="line">                    do_item_remove(search);</span><br><span class="line">                    item_trylock_unlock(hold_lock);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ------------------------------------&gt; 3)</span></span><br><span class="line">                    <span class="comment">/* Don't want to move to COLD, not active, bail out */</span></span><br><span class="line">                    it = search;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> COLD_LRU:</span><br><span class="line">                it = search; <span class="comment">/* No matter what, we're stopping */</span></span><br><span class="line">                <span class="keyword">if</span> (do_evict) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (settings.evict_to_free == <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applied here</span></span><br><span class="line">                    &#125;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                    LOGGER_LOG(<span class="literal">NULL</span>, LOG_EVICTIONS, LOGGER_EVICTION, search);</span><br><span class="line">                    do_item_unlink_nolock(search, hv); <span class="comment">// scr: ------&gt; 4)</span></span><br><span class="line">                    removed++;</span><br><span class="line">                    <span class="keyword">if</span> (settings.slab_automove == <span class="number">2</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applied here</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">...<span class="comment">// scr: not applied here</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[id]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: --------------------------------------&gt; e2)</span></span><br><span class="line">        <span class="keyword">if</span> (move_to_lru) &#123;</span><br><span class="line">            it-&gt;slabs_clsid = ITEM_clsid(it);</span><br><span class="line">            it-&gt;slabs_clsid |= move_to_lru;</span><br><span class="line">            item_link_q(it);</span><br><span class="line">        &#125;</span><br><span class="line">        do_item_remove(it);</span><br><span class="line">        item_trylock_unlock(hold_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">lru_pull_tail@items.c</text></center><p><strong>Method start &amp; end</strong></p><p>p) This method starts by selecting the tail element of the designated <strong>LRU list</strong> using the <strong>slab class</strong> id and the <em>list type</em>, assuming that the element can be a release candidate. And it iterates over (at most <code>5</code> entries) the list in reverse order to find a entry in case that elements near the tail are recently <a href="#Read">accessed</a>.</p><p>s) For each <strong>item</strong> selected, increase its <em>reference count</em>. In normal situation, the original value of <em>reference count</em> should be <code>1</code> (as you will see in the <a href="#Populate-the-data-amp-Link-the-item">last step</a> of the create operation). Hence a <code>!= 2</code> value after the increment indicates an exception that needs to be corrected. Note that the reference count is now 2 so it is required to decrease at least one time (back to 1) when the processing of the current item is done (e1, e2 or e3 is reached).</p><p>e1) Remove the <strong>item</strong> directly when an expiration is detected. Here the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_unlink_nolock">do_item_unlink_nolock</a> is exactly the same as the discussed <a href="#item-unlink">do_item_unlink</a> (I think the code is duplicated to emphasize that this method is not thread-safe), and it follows the same “unlink and remove” routine as in <a href="#Delete">item delete</a>.</p><p>e2) When a candidate is found, we might need to relocate it to another <strong>list</strong> (when <code>move_to_lru</code> is set in the <code>switch</code> <code>case</code>) by calling <a href="/understanding-memcached-source-code-IV/#item-link-q-add-to-linked-list">item_link_q</a>. And we do need to call <a href="##item-remove">do_item_remove</a> to reduce the reference count back to <code>1</code>. The decision is made by the steps discussed bellow.</p><a href="#" id="opt2" style="visibility: hidden"></a><p>e3) If an <strong>item</strong> is recently accessed, reset the <code>ITEM_ACTIVE</code> flag; <em>bump</em> it to the head of the list; decrease its <em>reference count</em> and iterate to the next one (maximum <code>5</code> times). Remember that the flag <code>ITEM_ACTIVE</code> is set by <a href="/understanding-memcached-source-code-VI/#item-get">item_get</a>, and here is the place where the <strong>item</strong> gets <em>bumped</em>.</p><p><strong>Hot &amp; warm</strong></p><p>1) The only difference of <code>HOT_LRU</code> and <code>WARM_LRU</code> is the threshold (<code>limit</code>) which are indicated by their respective configurations <a href="#" onclick="return false;" data-toggle="collapse" data-target="#hot_lru_pct">hot_lru_pct</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#warm_lru_pct">warm_lru_pct</a>.</p><div id="hot_lru_pct" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.hot_lru_pct = <span class="number">32</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> HOT_LRU_PCT:</span><br><span class="line">    <span class="keyword">if</span> (subopts_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Missing hot_lru_pct argument\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    settings.hot_lru_pct = atoi(subopts_value);</span><br><span class="line">    <span class="keyword">if</span> (settings.hot_lru_pct &lt; <span class="number">1</span> || settings.hot_lru_pct &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"hot_lru_pct must be &gt; 1 and &lt; 80\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">hot_lru_pct@memcached.c</text></center><br></div><div id="warm_lru_pct" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.warm_lru_pct = <span class="number">32</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> WARM_LRU_PCT:</span><br><span class="line">    <span class="keyword">if</span> (subopts_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Missing warm_lru_pct argument\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    settings.warm_lru_pct = atoi(subopts_value);</span><br><span class="line">    <span class="keyword">if</span> (settings.warm_lru_pct &lt; <span class="number">1</span> || settings.warm_lru_pct &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"warm_lru_pct must be &gt; 1 and &lt; 80\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">warm_lru_pct@memcached.c</text></center><br></div><p>2) If the threshold of <code>HOT_LRU</code> or <code>WARM_LRU</code> is reached, remove the <strong>item</strong> from the current list using <a href="/understanding-memcached-source-code-IV/#item-unlink-q-remove-from-linked-list">do_item_unlink_q</a>, and goto e2). Therefore, e2) is responsible to relink it to the <code>COLD_LRU</code> and decrease the reference count.</p><p>3) If the current <strong>item</strong> is not “active”, and the threshold is not reached, finish this method without any <strong>item</strong> relocation, nor release.</p><p><strong>Cold</strong></p><p>4) If there are any <strong>item</strong> in the list, evict it directly with the discussed <code>do_item_unlink_nolock</code> to free up its resource, and goto e1). Note that the default values of <a href="#" onclick="return false;" data-toggle="collapse" data-target="#evict_to_free">evict_to_free</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_automove">slab_automove</a> are set to values that disable their respective <code>if</code> blocks.</p><div id="evict_to_free" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.evict_to_free = <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:215</text></center><br></div><div id="slab_automove" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> MODERN:</span><br><span class="line">    <span class="comment">/* Modernized defaults. Need to add equivalent no_* flags</span></span><br><span class="line"><span class="comment">     * before making truly default. */</span></span><br><span class="line">...</span><br><span class="line">    settings.slab_automove = <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5824</text></center><br></div><p>Now we input the second line of the command</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure><p>and trigger the following procedures.</p><h2 id="Populate-the-item-with-content"><a href="#Populate-the-item-with-content" class="headerlink" title="Populate the item with content"></a>Populate the item with content</h2><p>As mentioned in <a href="#process-update-command">process_update_command</a>, the content we input is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#populated">populated</a> to <code>conn.item</code> using <code>conn.ritem</code> and <code>conn.rlbytes</code>. This step is handled by <strong>drive machine</strong> which will be discussed in detail in the next post.</p><div id="populated" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">res = read(c-&gt;sfd, c-&gt;ritem, c-&gt;rlbytes);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4421</text></center><br></div><p>Now we consider <code>conn.item</code> is filled with all relevant information, hence the next and final step is to</p><h2 id="Link-the-item"><a href="#Link-the-item" class="headerlink" title="Link the item"></a>Link the item</h2><p>the call stack of this step is</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ref</span><br><span class="line"><span class="number">2</span> |~Drive machine &amp; command parser</span><br><span class="line">    |-complete_nread</span><br><span class="line">      |-complete_nread_ascii</span><br><span class="line">        |-do_store_item</span><br><span class="line">        |=do_item_link      (LRU I)</span><br><span class="line">--      |-do_item_remove</span><br></pre></td></tr></table></figure><a href="#" onclick="return false;" data-toggle="collapse" data-target="#complete_nread">complete_nread</a> checks the protocol in use and moves directly to<br><br><div id="complete_nread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete_nread</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">    assert(c-&gt;protocol == ascii_prot</span><br><span class="line">           || c-&gt;protocol == binary_prot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;protocol == ascii_prot) &#123;</span><br><span class="line">        complete_nread_ascii(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;protocol == binary_prot) &#123;</span><br><span class="line">        complete_nread_binary(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">complete_nread@memcached.c</text></center><p></p></div><p></p><h3 id="complete-nread-ascii"><a href="#complete-nread-ascii" class="headerlink" title="complete_nread_ascii"></a>complete_nread_ascii</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete_nread_ascii</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    item *it = c-&gt;item;</span><br><span class="line">    <span class="keyword">int</span> comm = c-&gt;cmd;</span><br><span class="line">    <span class="keyword">enum</span> store_item_type ret;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(ITEM_data(it) + it-&gt;nbytes - <span class="number">2</span>, <span class="string">"\r\n"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        out_string(c, <span class="string">"CLIENT_ERROR bad data chunk"</span>); <span class="comment">// scr: -----&gt; 1)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ret = store_item(it, comm, c);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">      <span class="keyword">case</span> STORED:</span><br><span class="line">          out_string(c, <span class="string">"STORED"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> EXISTS:</span><br><span class="line">          out_string(c, <span class="string">"EXISTS"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NOT_FOUND:</span><br><span class="line">          out_string(c, <span class="string">"NOT_FOUND"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> NOT_STORED:</span><br><span class="line">          out_string(c, <span class="string">"NOT_STORED"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">          out_string(c, <span class="string">"SERVER_ERROR Unhandled storage type."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scr: -------------------------------------------------------&gt; 2)</span></span><br><span class="line">    item_remove(c-&gt;item);       <span class="comment">/* release the c-&gt;item reference */</span></span><br><span class="line">    c-&gt;item = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_store_item@items.c</text></center><p>1) Call <code>store_item</code> to link the <strong>item</strong> to the <strong>LRU list</strong> and <strong>hash map</strong>.</p><p>2) The <em>reference count</em> is set to <code>1</code> by <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slab_alloc</a> in <a href="#do-item-alloc">do_item_alloc</a> and increased by <a href="/understanding-memcached-source-code-IV/#do-item-link">do_item_link</a> in <a href="#do-store-item">do_store_item</a>. So reduce it to the normal value, <code>1</code>, with <a href="#do-item-remove">item_remove</a>. The methods of those have all been discussed in detail.</p><h3 id="do-store-item"><a href="#do-store-item" class="headerlink" title="do_store_item"></a>do_store_item</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">enum</span> store_item_type <span class="title">do_store_item</span><span class="params">(item *it, <span class="keyword">int</span> comm, conn *c, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key = ITEM_key(it);</span><br><span class="line">    item *old_it = do_item_get(key, it-&gt;nkey, hv, c); <span class="comment">// scr: ------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">enum</span> store_item_type stored = NOT_STORED;</span><br><span class="line"></span><br><span class="line">    item *new_it = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_it != <span class="literal">NULL</span> &amp;&amp; comm == NREAD_ADD) &#123;</span><br><span class="line">... <span class="comment">// scr: update logic</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!old_it &amp;&amp; (comm == NREAD_REPLACE</span><br><span class="line">        || comm == NREAD_APPEND || comm == NREAD_PREPEND))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* replace only replaces an existing value; don't store */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comm == NREAD_CAS) &#123;</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (comm == NREAD_APPEND || comm == NREAD_PREPEND) &#123;</span><br><span class="line">... <span class="comment">// scr: comm is NREAD_ADD (1)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stored == NOT_STORED &amp;&amp; failed_alloc == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (old_it != <span class="literal">NULL</span>)</span><br><span class="line">                item_replace(old_it, it, hv);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                do_item_link(it, hv); <span class="comment">// scr: ----------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            stored = STORED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: irrelevant code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: cas</span></span><br><span class="line">    LOGGER_LOG(c-&gt;thread-&gt;l, LOG_MUTATIONS, LOGGER_ITEM_STORE, <span class="literal">NULL</span>,</span><br><span class="line">            stored, comm, ITEM_key(it), it-&gt;nkey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_store_item@items.c</text></center><p>1) The newly created <strong>item</strong> exists only in the <strong>slab</strong> subsystem, hence <a href="#do-item-get">do_item_get</a> returns <code>null</code> as there is no such record in <strong>hash map</strong> yet.</p><p>2) So in the context of <em>item creation</em>, <code>do_store_item</code> is essentially the same as <a href="/understanding-memcached-source-code-IV/#do-item-link">do_item_link</a>.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://memcached.org/blog/modern-lru/" target="_blank" rel="noopener">Replacing the cache replacement algorithm in memcached</a></p><p><a href="http://hourlyapps.blogspot.com/2010/06/examples-of-memcached-commands.html" target="_blank" rel="noopener">Examples of Memcached telnet commands</a></p><p><a href="https://blog.elijaa.org/2010/05/21/memcached-telnet-command-summary/#delete" target="_blank" rel="noopener">Memcached telnet command summary</a></p>]]></content>
    
    <summary type="html">
    
      In previous posts, we have discussed different facets of an item, i.e., slab, hash map and LRU list as well as their associated (CRUD) methods, which build up the internal procedures and perform client requests after the corresponding commands are parsed by the drive machine. This time we will go through those procedures by issuing telnet commands to a Memcached instance and see how the discussed modules work together on various item operations. We will also see the whole picture of LRU lists that maintain the property of ‘least recently used’ in accordance to those operations.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="LRU" scheme="https://holmeshe.me/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - LRU II</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-V/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-V/</id>
    <published>2018-12-17T22:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="#"><text style="color:black;font-weight:bold;">, II - this article</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>More often than not, the <strong>LRU</strong> algorithm is combined with a <strong>hash map</strong>, and is referred to as a LRU cache. </p><p>In a <strong>LRU-cache</strong>, the <strong>hash map</strong> enables fast accessing of <em>cached</em> objects; and <strong>LRU</strong> avoids the <em>cache</em> to grow infinitely by marking expired, or so called, <strong>least recently used</strong> objects. This time we examine the <strong>memcached</strong>‘s implementation of <strong>hash map</strong>.</p><a id="more"></a><h1 id="Overview-textbook-overlapped-skip"><a href="#Overview-textbook-overlapped-skip" class="headerlink" title="Overview (textbook overlapped, skip)"></a>Overview (textbook overlapped, <a href="#Module-initialization">skip</a>)</h1><p><strong>Hash map</strong> is basically a <em>fixed-sized</em> array that indexes <em>value</em>s with integers <strong>hashed</strong> from <em>key</em>s. In <strong>hash map</strong> an array entry is referred to as a <em>bucket</em>. If the <strong>hash value</strong> exceeds the number of buckets (i.e., array size), it <em>rolls over</em> using ‘mod’ (<code>%</code>). <em>Collision</em> occurs when more than two <em>key</em>s result in the same <strong>hash value</strong> or different <strong>hash value</strong>s roll over to the same bucket, then a *linked list is formed on the bucket in collision.</p><p><em>Collision</em> slows down lookups speed for the sequential access of <em>linked list</em>, hence it is required to increase the <em>bucket number</em>, and to <em>rehash</em> entries using the new <strong>bucket number</strong> before the performance goes too bad. This process will be discussed <a href="#Scale-up-amp-entry-migration">soon</a>.</p><h1 id="Module-initialization"><a href="#Module-initialization" class="headerlink" title="Module initialization"></a>Module initialization</h1><p>The first relevant method is</p><h2 id="hash-init"><a href="#hash-init" class="headerlink" title="hash_init"></a>hash_init</h2><p>which simply determines the hash algorithm type.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash_init</span><span class="params">(<span class="keyword">enum</span> hashfunc_type type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> JENKINS_HASH:</span><br><span class="line">            hash = jenkins_hash;</span><br><span class="line">            settings.hash_algorithm = <span class="string">"jenkins"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MURMUR3_HASH:</span><br><span class="line">            hash = MurmurHash3_x86_32;</span><br><span class="line">            settings.hash_algorithm = <span class="string">"murmur3"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">hash_init@hash.c</text></center><p>This method is called from <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet1">here</a> as one of the init steps before the logic enters the main event loop.</p><div id="snippet1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (hash_init(hash_type) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to initialize hash_algorithm!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EX_USAGE);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5849</text></center><br></div><p>The parameter <code>hash_type</code> is set to <code>MURMUR3_HASH</code> by the mentioned command-line argument <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet2">modern</a>.</p><div id="snippet2" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> MODERN:</span><br><span class="line">                <span class="comment">/* Modernized defaults. Need to add equivalent no_* flags</span></span><br><span class="line"><span class="comment">                 * before making truly default. */</span></span><br><span class="line">...</span><br><span class="line">                hash_type = MURMUR3_HASH;</span><br><span class="line">...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5849</text></center><br></div><p>The second method</p><h2 id="assoc-init"><a href="#assoc-init" class="headerlink" title="assoc_init"></a>assoc_init</h2><p>allocates the fixed sized array mentioned in the beginning.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assoc_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> hashtable_init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hashtable_init) &#123;</span><br><span class="line">        hashpower = hashtable_init;</span><br><span class="line">    &#125;</span><br><span class="line">    primary_hashtable = <span class="built_in">calloc</span>(hashsize(hashpower), <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="keyword">if</span> (! primary_hashtable) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to init hashtable.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">hash_init@hash.c</text></center><p>This method is called in a similar <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet3">location</a> as <code>hash_init</code> as part of the system bootstrap process.</p><div id="snippet3" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    assoc_init(settings.hashpower_init);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5976</text></center><br></div><p>And the actual initial size is determined by the command-line argument <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet4">hashpower</a>.</p><div id="snippet4" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> HASHPOWER_INIT:</span><br><span class="line">    <span class="keyword">if</span> (subopts_value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Missing numeric argument for hashpower\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    settings.hashpower_init = atoi(subopts_value);</span><br><span class="line">    <span class="keyword">if</span> (settings.hashpower_init &lt; <span class="number">12</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Initial hashtable multiplier of %d is too low\n"</span>,</span><br><span class="line">            settings.hashpower_init);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (settings.hashpower_init &gt; <span class="number">64</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Initial hashtable multiplier of %d is too high\n"</span></span><br><span class="line">            <span class="string">"Choose a value based on \"STAT hash_power_level\" from a running instance\n"</span>,</span><br><span class="line">            settings.hashpower_init);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5677</text></center><br></div><p>As said before, the array can be replaced with a newly allocated larger one if the performance drops due to excessive <em>collision</em>. Next we discuss the process of</p><h1 id="Scale-up-amp-entry-migration"><a href="#Scale-up-amp-entry-migration" class="headerlink" title="Scale up &amp; entry migration"></a>Scale up &amp; entry migration</h1><p>In <strong>memcached</strong>, the threshold is 1.5, meaning, if the <strong>item</strong>s number exceeds 1.5 * <strong>bucket number</strong>, the mentioned expanding process starts.</p><p><img src="/gallery/expanding.png" alt="Expand hash map"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (! expanding &amp;&amp; hash_items &gt; (hashsize(hashpower) * <span class="number">3</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        assoc_start_expand();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_insert@assoc.c:173</text></center><p>The <code>assoc_start_expand</code> simply set a flag (i.e., <code>do_run_maintenance_thread</code>), and send a signal to awake a maintenance thread that does the actual job.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assoc_start_expand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (started_expanding)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    started_expanding = <span class="literal">true</span>;</span><br><span class="line">    pthread_cond_signal(&amp;maintenance_cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_insert@assoc.c:173</text></center><h2 id="Maintenance-thread-main-loop"><a href="#Maintenance-thread-main-loop" class="headerlink" title="Maintenance thread main loop"></a>Maintenance thread main loop</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">assoc_maintenance_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  mutex_lock(&amp;maintenance_lock);</span><br><span class="line">  <span class="keyword">while</span> (do_run_maintenance_thread<span class="comment">/* scr: the flag*/</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* There is only one expansion thread, so no need to global lock. */</span></span><br><span class="line">    <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; hash_bulk_move &amp;&amp; expanding; ++ii) &#123; <span class="comment">// scr: ----&gt; 2)</span></span><br><span class="line">      item *it, *next;</span><br><span class="line">      <span class="keyword">int</span> bucket;</span><br><span class="line">      <span class="keyword">void</span> *item_lock = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* bucket = hv &amp; hashmask(hashpower) =&gt;the bucket of hash table</span></span><br><span class="line"><span class="comment">       * is the lowest N bits of the hv, and the bucket of item_locks is</span></span><br><span class="line"><span class="comment">       *  also the lowest M bits of hv, and N is greater than M.</span></span><br><span class="line"><span class="comment">       *  So we can process expanding with only one item_lock. cool! */</span></span><br><span class="line">      <span class="keyword">if</span> ((item_lock = item_trylock(expand_bucket))) &#123; <span class="comment">// scr: --------&gt; 3)</span></span><br><span class="line">        <span class="keyword">for</span> (it = old_hashtable[expand_bucket]; <span class="literal">NULL</span> != it; it = next) &#123;</span><br><span class="line">          next = it-&gt;h_next; <span class="comment">// scr: ----------------------------------&gt; 4)</span></span><br><span class="line">          bucket = hash(ITEM_key(it), it-&gt;nkey) &amp; hashmask(hashpower);</span><br><span class="line">          it-&gt;h_next = primary_hashtable[bucket];</span><br><span class="line">          primary_hashtable[bucket] = it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        old_hashtable[expand_bucket] = <span class="literal">NULL</span>; <span class="comment">// scr: ----------------&gt; 4.1)</span></span><br><span class="line"></span><br><span class="line">        expand_bucket++; <span class="comment">// scr: --------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (expand_bucket == hashsize(hashpower - <span class="number">1</span>)) &#123; <span class="comment">// scr: -------&gt; 6)</span></span><br><span class="line">          expanding = <span class="literal">false</span>;</span><br><span class="line">          <span class="built_in">free</span>(old_hashtable);</span><br><span class="line">... <span class="comment">// scr: ---------------------------------------------------&gt; stat &amp; log</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        usleep(<span class="number">10</span>*<span class="number">1000</span>); <span class="comment">// scr: ------------------------------------&gt; 3.1)</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (item_lock) &#123; <span class="comment">// scr: --------------------------------------&gt; 3.2)</span></span><br><span class="line">        item_trylock_unlock(item_lock);</span><br><span class="line">        item_lock = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!expanding) &#123;</span><br><span class="line">      <span class="comment">/* We are done expanding.. just wait for next invocation */</span></span><br><span class="line">      started_expanding = <span class="literal">false</span>;</span><br><span class="line">      pthread_cond_wait(&amp;maintenance_cond, &amp;maintenance_lock); <span class="comment">// scr: &gt; 0)</span></span><br><span class="line">      <span class="comment">/* assoc_expand() swaps out the hash table entirely, so we need</span></span><br><span class="line"><span class="comment">       * all threads to not hold any references related to the hash</span></span><br><span class="line"><span class="comment">       * table while this happens.</span></span><br><span class="line"><span class="comment">       * This is instead of a more complex, possibly slower algorithm to</span></span><br><span class="line"><span class="comment">       * allow dynamic hash table expansion without causing significant</span></span><br><span class="line"><span class="comment">       * wait times.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      pause_threads(PAUSE_ALL_THREADS);</span><br><span class="line">      assoc_expand(); <span class="comment">// scr: -----------------------------------------&gt; 1)</span></span><br><span class="line">      pause_threads(RESUME_ALL_THREADS);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_maintenance_thread@assoc.c</text></center><p>0) This is where the thread waits up from sleep and start working, and goes to sleep when there is nothing to be done.</p><p>1) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#assoc_expand">assoc_expand</a> allocates the resource for the new <strong>hash map</strong> which is meant to replace the old one initialized from <a href="#assoc-init">here</a>.</p><div id="assoc_expand" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* grows the hashtable to the next power of 2. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assoc_expand</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    old_hashtable = primary_hashtable;</span><br><span class="line"></span><br><span class="line">    primary_hashtable = <span class="built_in">calloc</span>(hashsize(hashpower + <span class="number">1</span>), <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="keyword">if</span> (primary_hashtable) &#123;</span><br><span class="line">... <span class="comment">// scr: log</span></span><br><span class="line">        hashpower++;</span><br><span class="line">        expanding = <span class="literal">true</span>;</span><br><span class="line">        expand_bucket = <span class="number">0</span>;</span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        primary_hashtable = old_hashtable;</span><br><span class="line">        <span class="comment">/* Bad news, but we can keep running. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_expand@assoc.c</text></center><br></div><p>2) Only migrate a certain number of <strong>item</strong>s in one batch. <a href="#" onclick="return false;" data-toggle="collapse" data-target="#hash_bulk_move">hash_bulk_move</a> avoids the thread hanging around too long when <a href="#" onclick="return false;" data-toggle="collapse" data-target="#stop_assoc_maintenance_thread">stop_assoc_maintenance_thread</a> is called. In contrast to the discussed <code>assoc_start_expand</code>, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#stop_assoc_maintenance_thread">stop_assoc_maintenance_thread</a> reset the flag <code>do_run_maintenance_thread</code> and send the signal to wake up the thread to exit.</p><div id="hash_bulk_move" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_HASH_BULK_MOVE 1</span></span><br><span class="line"><span class="keyword">int</span> hash_bulk_move = DEFAULT_HASH_BULK_MOVE;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc.c:207</text></center><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">char</span> *env = getenv(<span class="string">"MEMCACHED_HASH_BULK_MOVE"</span>);</span><br><span class="line">    <span class="keyword">if</span> (env != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        hash_bulk_move = atoi(env);</span><br><span class="line">        <span class="keyword">if</span> (hash_bulk_move == <span class="number">0</span>) &#123;</span><br><span class="line">            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">start_assoc_maintenance_thread@assoc.c:281</text></center><br></div><div id="stop_assoc_maintenance_thread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_assoc_maintenance_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mutex_lock(&amp;maintenance_lock);</span><br><span class="line">    do_run_maintenance_thread = <span class="number">0</span>;</span><br><span class="line">    pthread_cond_signal(&amp;maintenance_cond);</span><br><span class="line">    mutex_unlock(&amp;maintenance_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for the maintenance thread to stop */</span></span><br><span class="line">    pthread_join(maintenance_tid, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">stop_assoc_maintenance_thread@assoc.c</text></center><br></div><p>3) (The “item lock” actually works on the whole <em>bucket</em> hence I will call it <em>bucket lock</em> instead) Use low priority <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_trylock">item_trylock</a> (<code>i.e., pthread_mutex_trylock</code>) to access the <em>bucket lock</em>; 3.1) sleep for 10 sec when the the <strong>item</strong> is not available; and 3.2) release the lock using <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_trylock_unlock">item_trylock_unlock</a> when the migration (of this <em>bucket</em>) completes.</p><div id="item_trylock" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">item_trylock</span><span class="params">(<span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> *lock = &amp;item_locks[hv &amp; hashmask(item_lock_hashpower)];</span><br><span class="line">    <span class="keyword">if</span> (pthread_mutex_trylock(lock) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_trylock@thread.c</text></center><br></div><div id="item_trylock_unlock" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">item_trylock_unlock</span><span class="params">(<span class="keyword">void</span> *lock)</span> </span>&#123;</span><br><span class="line">    mutex_unlock((<span class="keyword">pthread_mutex_t</span> *) lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_trylock@thread.c</text></center><br></div><p>4) Rehash all the <strong>item</strong>s in the bucket, and migrate them to the new hash map.</p><p>5) Move on to the next <em>bucket</em>.</p><p>6) Last <em>bucket</em> reached -&gt; go to 0)</p><h2 id="Maintenance-thread-start"><a href="#Maintenance-thread-start" class="headerlink" title="Maintenance thread start"></a>Maintenance thread start</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">start_assoc_maintenance_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *env = getenv(<span class="string">"MEMCACHED_HASH_BULK_MOVE"</span>);</span><br><span class="line">    <span class="keyword">if</span> (env != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        hash_bulk_move = atoi(env);</span><br><span class="line">        <span class="keyword">if</span> (hash_bulk_move == <span class="number">0</span>) &#123;</span><br><span class="line">            hash_bulk_move = DEFAULT_HASH_BULK_MOVE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_init(&amp;maintenance_lock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> ((ret = pthread_create(&amp;maintenance_tid, <span class="literal">NULL</span>,</span><br><span class="line">                              assoc_maintenance_thread, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't create thread: %s\n"</span>, strerror(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">start_assoc_maintenance_thread@assoc.c</text></center><p>Similar to initialization <a href="#Module-initialization">methods</a>, it is called during system <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet5">bootstrap</a>. </p><div id="snippet5" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (start_assoc_maintenance_thread() == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5992</text></center><br></div><h2 id="Maintenance-thread-stop"><a href="#Maintenance-thread-stop" class="headerlink" title="Maintenance thread stop"></a>Maintenance thread stop</h2><p>This method is called in system <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet6">shutdown</a> process, hence it is opposite in logic to <code>start_assoc_maintenance_thread</code>. Nevertheless, the operations of this method are opposite that of <code>assoc_start_expand</code> mechanism wise.</p><div id="snippet6" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    stop_assoc_maintenance_thread();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:6098</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_assoc_maintenance_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mutex_lock(&amp;maintenance_lock);</span><br><span class="line">    do_run_maintenance_thread = <span class="number">0</span>;</span><br><span class="line">    pthread_cond_signal(&amp;maintenance_cond);</span><br><span class="line">    mutex_unlock(&amp;maintenance_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for the maintenance thread to stop */</span></span><br><span class="line">    pthread_join(maintenance_tid, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">stop_assoc_maintenance_thread@assoc.c</text></center><p>As said before, the expanding &amp; migration process discussed here has an impact on the logic of all <strong>hash map</strong> related operations. In the next section, we look at these operations.</p><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><p>N.b., <code>assoc_delete</code> has been discussed in the <a href="/understanding-memcached-source-code-IV/#assoc-delete-remove-from-hash-map">last post</a>; and in a key-value system <em>update</em> and <em>insert</em> are essentially the same, thus, this section will discuss the operations of <em>C</em> (create) and <em>R</em> (read) only.</p><h2 id="assoc-insert"><a href="#assoc-insert" class="headerlink" title="assoc_insert"></a>assoc_insert</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">assoc_insert</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expanding &amp;&amp;</span><br><span class="line">        (oldbucket = (hv &amp; hashmask(hashpower - <span class="number">1</span>))) &gt;= expand_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        it-&gt;h_next = old_hashtable[oldbucket]; <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">        old_hashtable[oldbucket] = it;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;h_next = primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr: &gt; 2)</span></span><br><span class="line">        primary_hashtable[hv &amp; hashmask(hashpower)] = it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;hash_items_counter_lock);</span><br><span class="line">    hash_items++; <span class="comment">// scr: ------------------------------------------------&gt; 3)</span></span><br><span class="line">    <span class="keyword">if</span> (! expanding &amp;&amp; hash_items &gt; (hashsize(hashpower) * <span class="number">3</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        assoc_start_expand();</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;hash_items_counter_lock);</span><br><span class="line"></span><br><span class="line">    MEMCACHED_ASSOC_INSERT(ITEM_key(it), it-&gt;nkey, hash_items);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_insert@assoc.c</text></center><p>1) If expanding process is undergoing and the <em>hash key</em> associated bucket has not been migrated, insert the item to <code>old_hashtable</code>. Note that here we use the old <em>bucket number</em> (i.e., <code>hashmask(hashpower - 1))</code>) to calculate the hash index.</p><p>2) Otherwise, insert the <strong>item</strong>to <code>primary_hashtable</code> directly.</p><p>3) Increase the global variable <a href="#" onclick="return false;" data-toggle="collapse" data-target="#hash_items">hash_items</a> (number of <strong>item</strong>s). If it exceeds the threshold after the <strong>item</strong> is added, start expanding &amp; migration process. Note that this is also the preamble of <a href="#Scale-up-amp-entry-migration">the last section</a>.</p><div id="hash_items" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> hash_items = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc.c:51</text></center><br></div><h2 id="assoc-find"><a href="#assoc-find" class="headerlink" title="assoc_find"></a>assoc_find</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">assoc_find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expanding &amp;&amp;</span><br><span class="line">        (oldbucket = (hv &amp; hashmask(hashpower - <span class="number">1</span>))) &gt;= expand_bucket)</span><br><span class="line">    &#123;</span><br><span class="line">        it = old_hashtable[oldbucket]; <span class="comment">// scr: ---------------------------&gt; 1)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it = primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr: --------&gt; 2)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item *ret = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (it) &#123; <span class="comment">// scr: -------------------------------------------------&gt; 3)</span></span><br><span class="line">        <span class="keyword">if</span> ((nkey == it-&gt;nkey) &amp;&amp; (<span class="built_in">memcmp</span>(key, ITEM_key(it), nkey) == <span class="number">0</span>)) &#123;</span><br><span class="line">            ret = it;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        it = it-&gt;h_next;</span><br><span class="line">        ++depth;</span><br><span class="line">    &#125;</span><br><span class="line">    MEMCACHED_ASSOC_FIND(key, nkey, depth);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_find@assoc.c</text></center><p>1) Similar to that of <a href="#assoc-insert">assoc_insert</a>, this step locates the bucket from <code>old_hashtable</code> when the key is yet to be rehashed.</p><p>2) Use <code>primary_hashtable</code> directly otherwise.</p><p>3) Go through the <em>linked list</em> and compare the <em>key</em> (instead of the <em>hash index</em>) directly to lookup the <strong>item</strong> in the case of <em>Collision</em>.</p><p>One thing worth noting is that <code>assoc_find</code> is very similar to <code>_hashitem_before</code> which has been discussed in the <a href="/understanding-memcached-source-code-IV/#assoc-delete-remove-from-hash-map">last post</a>. The difference here is, <code>_hashitem_before</code> returns the <strong>address of the next member of the element before the found one</strong> (<code>pos = &amp;(*pos)-&gt;h_next;</code>), which is required when removing entries from a <em>singly linked list</em>; whilst this method returns the element found directly (<code>ret = it;</code>).</p>]]></content>
    
    <summary type="html">
    
      More often than not, the LRU algorithm is combined with a hash map, and is referred to as a LRU cache. In a LRU-cache, the hash map enables fast accessing of cached objects; and LRU avoids the cache to grow infinitely by marking expired, or so called, least recently used objects. This time we examine the memcached‘s implementation of hash map.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="LRU" scheme="https://holmeshe.me/tags/LRU/"/>
    
      <category term="hash map" scheme="https://holmeshe.me/tags/hash-map/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - LRU I</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-IV/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-IV/</id>
    <published>2018-12-10T23:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I - this article</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>More often than not, the <strong>LRU</strong> algorithm is combined with a <strong>hash map</strong>, and is referred to as a </p><h1 id="LRU-Cache"><a href="#LRU-Cache" class="headerlink" title="LRU Cache"></a>LRU Cache</h1><p>In a <strong>LRU-cache</strong>, the <strong>hash map</strong> enables fast accessing of <em>cached</em> objects; and <strong>LRU</strong> avoids the <em>cache</em> to grow infinitely by marking expired, or so called, <strong>least recently used</strong> objects. Next we look at how <strong>LRU</strong> works from a high level standpoint.</p><a id="more"></a><h2 id="Linked-list"><a href="#Linked-list" class="headerlink" title="Linked list"></a>Linked list</h2><p>Technically, <strong>LRU</strong> algorithm works on a <em>linked list</em>, whenever a list entry is used (accessed or updated), it is removed from the list and be attached to the list head. In this way, the closer an element is to the list tail, the <strong>less recently used</strong> it is. Hence it is easy to remove irrelevant or “expired” elements from the tail based on a certain configuration.</p><h2 id="Harsh-map"><a href="#Harsh-map" class="headerlink" title="Harsh map"></a>Harsh map</h2><p><em>Linked list</em> is slow when it comes to element access, hence another data structure is employed. We have seen how <strong>linked list</strong> “strings” <em>chunks</em> in <strong>slabs</strong> to make <em>free list</em>s. In an <strong>LRU cache</strong>, the mechanism is similar, however, it is the <strong>hash map</strong> entries instead of <em>chunks</em> in <strong>slabs</strong> got wired up this time, which looks like:</p><p><img src="/gallery/lru.png" alt="hash map perspective"></p><p>We can also flatten the linked list, and make the structure a bit more clear,</p><p><img src="/gallery/lru-linked-list.png" alt="linked list perspective"></p><h1 id="Core-data-structure-item"><a href="#Core-data-structure-item" class="headerlink" title="Core data structure - item"></a>Core data structure - item</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protected by LRU locks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">/* Rest are protected by an item lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">h_next</span>;</span>    <span class="comment">/* hash chain next */</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      time;       <span class="comment">/* least recent access */</span></span><br><span class="line">    <span class="keyword">rel_time_t</span>      exptime;    <span class="comment">/* expire time */</span></span><br><span class="line">    <span class="keyword">int</span>             nbytes;     <span class="comment">/* size of data */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short  refcount;</span><br><span class="line">    <span class="keyword">uint8_t</span>         nsuffix;    <span class="comment">/* length of flags-and-length string */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         nkey;       <span class="comment">/* key length, w/terminating null and padding */</span></span><br><span class="line">    <span class="comment">/* this odd type prevents type-punning issues when we do</span></span><br><span class="line"><span class="comment">     * the little shuffle to save space when not using CAS. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">        <span class="keyword">char</span> end; <span class="comment">// scr: flexible array member indicating the item header "end"</span></span><br><span class="line">    &#125; data[];</span><br><span class="line">    <span class="comment">/* if it_flags &amp; ITEM_CAS we have 8 bytes CAS */</span></span><br><span class="line">    <span class="comment">/* then null-terminated key */</span></span><br><span class="line">    <span class="comment">/* then " flags length\r\n" (no terminating null) */</span></span><br><span class="line">    <span class="comment">/* then data with terminating \r\n (no terminating null; it's binary!) */</span></span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@item.c</text></center><h2 id="Properties-in-discussion"><a href="#Properties-in-discussion" class="headerlink" title="Properties in discussion"></a>Properties in discussion</h2><p><code>next</code>, <code>prev</code> - <em>LRU list</em> pointers, initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="#item-link-q-add-to-linked-list">item_link_q</a>, <a href="#item-unlink-q-remove-from-linked-list">item_unlink_q</a></p><p><code>h_next</code> - <em>hash collision</em> list pointers, initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="#assoc-insert-add-to-hash-map">assoc_insert</a>, <a href="#assoc-delete-remove-from-hash-map">assoc_delete</a>, <a href="/understanding-memcached-source-code-II">various methods (LRU II)</a> </p><p><code>time</code> - last access time, set in <a href="#do-item-link">do_item_link</a>, used by <a href="(/understanding-memcached-source-code-VI/#lru-pull-tail">lru_pull_tail (LRU III)</a></p><p><code>exptime</code> - expire time indicated by request argument, initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="(/understanding-memcached-source-code-VI/#lru-pull-tail">lru_pull_tail (LRU III)</a></p><p><code>nbytes</code> - data size indicated by request argument, initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a></p><p><code>refcount</code> - reference cound, initialized in <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc (Slab III)</a>, used by <a href="#do-item-link">do_item_link</a></p><p><code>nsuffix</code> - initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a> with <code>item_make_header</code></p><p><code>it_flags</code> - initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="#do-item-link">do_item_link</a>, <a href="#do-item-unlink">do_item_unlink</a></p><p><code>slabs_clsid</code> - the <strong>LRU</strong> list the <strong>item</strong> belongs, initialized in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="#item-link-q-add-to-linked-list">item_link_q</a>, <a href="#item-unlink-q-remove-from-linked-list">item_unlink_q</a></p><p><code>nkey</code> - key size, calcuated in <a href="/understanding-memcached-source-code-VI/#do-item-alloc">do_item_alloc (LRU III)</a>, used by <a href="#assoc-delete-remove-from-hash-map">assoc_delete</a></p><h2 id="Memory-layout-of-an-item-chunk"><a href="#Memory-layout-of-an-item-chunk" class="headerlink" title="Memory layout of an item chunk"></a>Memory layout of an item chunk</h2><p>We have mentioned <em>item chunk</em> in <a href="/understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>. With the help of this data structure, we can now examine the chunk more closely.</p><p><img src="/gallery/item-chunk.png" alt="item chunk"></p><p>Next we read the relevant code that performs the above discussed LRU operations.</p><h1 id="do-item-link"><a href="#do-item-link" class="headerlink" title="do_item_link"></a>do_item_link</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_item_link</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123; <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">    it-&gt;it_flags |= ITEM_LINKED;                <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">    it-&gt;time = current_time;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate a new CAS ID on link. */</span></span><br><span class="line">... <span class="comment">// scr: cas</span></span><br><span class="line">    assoc_insert(it, hv);                       <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    item_link_q(it);                            <span class="comment">// scr: -------------------&gt; 4)</span></span><br><span class="line">    refcount_incr(&amp;it-&gt;refcount);               <span class="comment">// scr: -------------------&gt; 5)</span></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_link@item.c</text></center><p>1) <code>hv</code> is supposed to be the shortened “hashed value”.</p><p>2) Set <code>ITEM_LINKED</code> in <code>it-&gt;it_flags</code>, and set current time to <code>it-&gt;time</code>.</p><p class="back"><br>The field <code>it_flags</code> is used in <a href="/understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a> and <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc</a><br></p><p>3) Insert the <strong>item</strong> to hash map.</p><p>4) Insert the <strong>item</strong> to linked list.</p><p>5) Increase the <em>reference count</em>.</p><p class="back"><br>This field is initialized as <code>1</code> in <a href="/understanding-memcached-source-code-III/#do-slabs-alloc">do_slabs_alloc</a><br></p><p>It is worth noting here that <em>reference count</em> indicates how many sub-modules are using the same resource, so as to determine when to actually deallocate the resource (In this particular case, <strong>item</strong> is referred by both <strong>slab</strong> and <strong>LRU</strong>). I have written <a href="/cpp-pointers/">this article</a> that explains a similar mechanism of C++.</p><h2 id="item-link-q-add-to-linked-list"><a href="#item-link-q-add-to-linked-list" class="headerlink" title="item_link_q - add to linked list"></a>item_link_q - add to linked list</h2><a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_link_q">item_link_q</a> is a thread safe wrapper of the workhorse method <code>do_item_link_q</code>.<br><br><div id="item_link_q" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">item_link_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">    do_item_link_q(it);</span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_link_q@item.c</text></center><p></p></div><p></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_item_link_q</span><span class="params">(item *it)</span> </span>&#123; <span class="comment">/* item is the new head */</span></span><br><span class="line">    item **head, **tail;</span><br><span class="line">    assert((it-&gt;it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    head = &amp;heads[it-&gt;slabs_clsid];           <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">    tail = &amp;tails[it-&gt;slabs_clsid];</span><br><span class="line">    assert(it != *head);</span><br><span class="line">    assert((*head &amp;&amp; *tail) || (*head == <span class="number">0</span> &amp;&amp; *tail == <span class="number">0</span>));</span><br><span class="line">    it-&gt;prev = <span class="number">0</span>;                             <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">    it-&gt;next = *head;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it;</span><br><span class="line">    *head = it;</span><br><span class="line">    <span class="keyword">if</span> (*tail == <span class="number">0</span>) *tail = it;</span><br><span class="line">    sizes[it-&gt;slabs_clsid]++;                 <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_link_q@item.c</text></center><p>1) Get the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">head</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">tail</a> of the respective <strong>LRU linked list</strong> indicated by <code>slabs_clsid</code>. Note that the <code>slabs_clsid</code> is <em>salted</em> with the type of the queue, hence each <strong>slab group</strong> may enlist multiple <em>lists</em>.</p><p>2) Standard operations of “adding an element to the front”.</p><p>3) Increase the global array <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals">sizes</a>.</p><div id="globals" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item *heads[LARGEST_ID];</span><br><span class="line"><span class="keyword">static</span> item *tails[LARGEST_ID];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> sizes[LARGEST_ID];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item.c:59</text></center><br></div><h2 id="assoc-insert-add-to-hash-map"><a href="#assoc-insert-add-to-hash-map" class="headerlink" title="assoc_insert - add to hash map"></a>assoc_insert - add to hash map</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">assoc_insert</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123; <span class="comment">// scr: again, hv -&gt; hash value</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it-&gt;h_next = primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr:  1)</span></span><br><span class="line">        primary_hashtable[hv &amp; hashmask(hashpower)] = it;         // scr:  2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_insert@assoc.c</text></center><p>1) Deal with potential conflict. If there is no, the <code>h_next</code> is set to <code>null</code>.</p><p>2) Set the <strong>item</strong> to the bucket in <a href="#" onclick="return false;" data-toggle="collapse" data-target="#primary_hashtable">primary_hashtable</a>.</p><div id="primary_hashtable" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> item** primary_hashtable = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc.c:42</text></center><br></div><p>The expanding logic omitted here will be covered in the <a href="/understanding-memcached-source-code-V/#Scale-up-amp-entry-migration">next post</a>.</p><h1 id="do-item-unlink"><a href="#do-item-unlink" class="headerlink" title="do_item_unlink"></a>do_item_unlink</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_item_unlink</span><span class="params">(item *it, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    MEMCACHED_ITEM_UNLINK(ITEM_key(it), it-&gt;nkey, it-&gt;nbytes);</span><br><span class="line">    <span class="keyword">if</span> ((it-&gt;it_flags &amp; ITEM_LINKED) != <span class="number">0</span>) &#123;</span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_LINKED;         <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">... <span class="comment">// scr: stat</span></span><br><span class="line">        assoc_delete(ITEM_key(it), it-&gt;nkey, hv); <span class="comment">// scr: ---------------&gt; 2)</span></span><br><span class="line">        item_unlink_q(it);                    <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">        do_item_remove(it);                   <span class="comment">// scr: -------------------&gt; *)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink@item.c</text></center><p>1) Clear <code>ITEM_LINKED</code> in <code>it-&gt;it_flags</code>.</p><p>2) Remove the <strong>item</strong> from hash map.</p><p>3) Remove the <strong>item</strong> from linked list.</p><p>*) The actual releasing of an <em>item</em> will be covered in later posts.</p><h2 id="item-unlink-q-remove-from-linked-list"><a href="#item-unlink-q-remove-from-linked-list" class="headerlink" title="item_unlink_q - remove from linked list"></a>item_unlink_q - remove from linked list</h2><p>Likewise, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item_unlink_q">item_unlink_q</a> is a thread safe wrapper of the workhorse method <code>do_item_unlink_q</code>.</p><div id="item_unlink_q" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">item_link_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">    do_item_link_q(it);</span><br><span class="line">    pthread_mutex_unlock(&amp;lru_locks[it-&gt;slabs_clsid]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item_unlink_q@item.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_item_unlink_q</span><span class="params">(item *it)</span> </span>&#123;</span><br><span class="line">    item **head, **tail;</span><br><span class="line">    head = &amp;heads[it-&gt;slabs_clsid];           <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line">    tail = &amp;tails[it-&gt;slabs_clsid];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*head == it) &#123;                        <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">        assert(it-&gt;prev == <span class="number">0</span>);</span><br><span class="line">        *head = it-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*tail == it) &#123;</span><br><span class="line">        assert(it-&gt;next == <span class="number">0</span>);</span><br><span class="line">        *tail = it-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(it-&gt;next != it);</span><br><span class="line">    assert(it-&gt;prev != it);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it-&gt;prev;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;prev) it-&gt;prev-&gt;next = it-&gt;next;</span><br><span class="line">    sizes[it-&gt;slabs_clsid]--;                 <span class="comment">// scr: -------------------&gt; 3)</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_unlink_q@item.c</text></center><p>1) Same, get the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">head</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">tail</a> of the respective <strong>LRU linked list</strong> indicated by <code>slabs_clsid</code>.</p><p>2) Standard operations of “removing an element from a linked list”.</p><p>3) Decrease the global array <a href="#" onclick="return false;" data-toggle="collapse" data-target="#globals1">sizes</a>.</p><div id="globals1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item *heads[LARGEST_ID];</span><br><span class="line"><span class="keyword">static</span> item *tails[LARGEST_ID];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> sizes[LARGEST_ID];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">item.c:59</text></center><br></div><h2 id="assoc-delete-remove-from-hash-map"><a href="#assoc-delete-remove-from-hash-map" class="headerlink" title="assoc_delete - remove from hash map"></a>assoc_delete - remove from hash map</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> item** _hashitem_before (<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv) &#123;</span><br><span class="line">    item **pos;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> oldbucket;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: expanding related operations</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = &amp;primary_hashtable[hv &amp; hashmask(hashpower)]; <span class="comment">// scr: -----&gt; 1)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*pos &amp;&amp; ((nkey != (*pos)-&gt;nkey) || <span class="built_in">memcmp</span>(key, ITEM_key(*pos), nkey))) &#123;</span><br><span class="line">        pos = &amp;(*pos)-&gt;h_next; <span class="comment">// scr: ----------------------------------&gt; 2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assoc_delete</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">uint32_t</span> hv)</span> </span>&#123;</span><br><span class="line">    item **before = _hashitem_before(key, nkey, hv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*before) &#123;</span><br><span class="line">        item *nxt;</span><br><span class="line">...</span><br><span class="line">        nxt = (*before)-&gt;h_next; <span class="comment">// scr: --------------------------------&gt; 3)</span></span><br><span class="line">        (*before)-&gt;h_next = <span class="number">0</span>;   <span class="comment">/* probably pointless, but whatever. */</span></span><br><span class="line">        *before = nxt; <span class="comment">// scr: ------------------------------------------&gt; 4)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Note:  we never actually get here.  the callers don't delete things</span></span><br><span class="line"><span class="comment">       they can't find. */</span></span><br><span class="line">    assert(*before != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">assoc_delete@assoc.c</text></center><p>1) Get the hash bucket using <code>hv</code>.</p><p>2) Go through the conflict chain and compare the <code>key</code>. Note that the result value is the <strong>address of the <code>next</code> member of the element <code>before</code> the found one</strong>. When there is no conflict, the address is the bucket itself.</p><p>3) Set the next element after the found one to temporary variable <code>nxt</code>.</p><p>4) Update the <strong><code>next</code> member of the element <code>before</code> the found one</strong>.</p><h1 id="Take-home"><a href="#Take-home" class="headerlink" title="Take home"></a>Take home</h1><p>Try <a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">this</a>.</p>]]></content>
    
    <summary type="html">
    
      More often than not, the LRU algorithm is combined with a hash map, and is referred to as a LRU Cache. In a LRU-cache, the hash map enables fast accessing of cached objects; and LRU avoids the cache to grow infinitely by marking expired, or so called, least recently used objects. Next we look at how LRU works from a high level standpoint.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="LRU" scheme="https://holmeshe.me/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - Slab III</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-III/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-III/</id>
    <published>2018-09-28T09:55:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="#"><text style="color:black;font-weight:bold;">III - this article)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>Last time we saw the memory allocating process, which further formulates <strong>slabs</strong> and the derivative “free lists” (a.k.a., <code>slots</code>). This time we will examine how to take advantage of the established data structures to <strong>“slab allocate / release”</strong> memory chunks which will be used to store <strong>items</strong>.</p><a id="more"></a><h1 id="Slab-alloc"><a href="#Slab-alloc" class="headerlink" title="Slab alloc"></a>Slab alloc</h1><p>Firstly, we look at</p><h2 id="do-slabs-alloc"><a href="#do-slabs-alloc" class="headerlink" title="do_slabs_alloc"></a>do_slabs_alloc</h2><p class="back"><br>which is opposite to the <a href="../understanding-memcached-source-code-II/#do-slabs-free">discussed <code>do_slabs_free</code></a>.<br></p><p>Note that the “public” interface of <code>do_slabs_alloc</code> is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_alloc">slabs_alloc</a> which is basically a thread-safe wrapper that locks the core data structures manipulated by the <strong>Memcached</strong> instance that is configured as <a href="#" onclick="return false;" data-toggle="collapse" data-target="#multithreaded">multithreaded</a>.</p><div id="slabs_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">slabs_alloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">int</span> *total_chunks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;slabs_lock);</span><br><span class="line">    ret = do_slabs_alloc(size, id, total_chunks, flags);</span><br><span class="line">    pthread_mutex_unlock(&amp;slabs_lock);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_alloc@slabs.c</text></center><br></div><div id="multithreaded" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            settings.num_threads = atoi(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Number of threads must be greater than 0\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* There're other problems when you get above 64 threads.</span></span><br><span class="line"><span class="comment">             * In the future we should portably detect # of cores for the</span></span><br><span class="line"><span class="comment">             * default.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &gt; <span class="number">64</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting a high number of worker"</span></span><br><span class="line">                                <span class="string">"threads is not recommended.\n"</span></span><br><span class="line">                                <span class="string">" Set this value to the number of cores in"</span></span><br><span class="line">                                <span class="string">" your machine or less.\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5572</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">do_slabs_alloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id, <span class="keyword">unsigned</span> <span class="keyword">int</span> *total_chunks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p;</span><br><span class="line">    <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">    item *it = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br><span class="line">    p = &amp;slabclass[id]; <span class="comment">// scr: ----------------------------------------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (total_chunks != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *total_chunks = p-&gt;slabs * p-&gt;perslab; <span class="comment">// scr: -----------------&gt; 2)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* fail unless we have space at the end of a recently allocated page,</span></span><br><span class="line"><span class="comment">       we have something on our freelist, or we could allocate a new page */</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sl_curr == <span class="number">0</span> &amp;&amp; flags != SLABS_ALLOC_NO_NEWPAGE) &#123; <span class="comment">// scr: --&gt; *)</span></span><br><span class="line">        do_slabs_newslab(id); <span class="comment">// scr: ----------------------------------&gt; 3)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sl_curr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* return off our freelist */</span></span><br><span class="line">        it = (item *)p-&gt;slots; <span class="comment">// scr: ---------------------------------&gt; 4)</span></span><br><span class="line">        p-&gt;slots = it-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Kill flag and initialize refcount here for lock safety in slab</span></span><br><span class="line"><span class="comment">         * mover's freeness detection. */</span></span><br><span class="line">        it-&gt;it_flags &amp;= ~ITEM_SLABBED; <span class="comment">// scr: -------------------------&gt; 5)</span></span><br><span class="line">        it-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">        p-&gt;sl_curr--;</span><br><span class="line">        ret = (<span class="keyword">void</span> *)it; <span class="comment">// scr: --------------------------------------&gt; 6)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_alloc@slabs.c</text></center><p>1) For <em>item allocation</em>, <code>id</code> indicates the <strong>slab class</strong> that suits the requested <em>item size</em> best. In other words, <code>id</code> is selected using the actual <em>item size</em>, the process of which will be discussed <a href="#slabs-clsid">very soon</a>.</p><p>2) <code>total_chunks</code> is the parameter that outputs the total number of <em>memory chunks</em> (entries in the <em>free list</em>) available for the <strong>slab class</strong>. <code>if (total_chunks != NULL)</code> suggests that the argument is optional.</p><p>*) As the name indicates, <code>SLABS_ALLOC_NO_NEWPAGE</code> (<code>flags</code>) prevents this method to allocate new <strong>slab</strong> when there is no memory chunk available. This option is not used in the normal path of <em>item allocation</em>, hence is ignored for now.</p><p>3) When there is no free memory chunk, allocate a new <strong>slab</strong>. Here <code>p-&gt;sl_curr</code> indicates the number of available <em>chunks</em>, whose value decreases each time this method got called (in step 5 below).</p><p class="back"><br>Conversely, this field is increased in <a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>. Note that <em>new slab</em> has also been covered from <a href="../understanding-memcached-source-code-II/#New-slab">here</a>.<br></p><p>4) Remove the front element (<strong>f</strong>) from the <em>free list</em>, and set it to <code>it</code>.</p><p class="back"><br>In <a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>, an element is added to the front of the <em>free list</em>.<br></p><p>5) Clear the <code>ITEM_SLABBED</code> for the chuck (<strong>f</strong>), set its reference count to 1, and reduce <code>p-&gt;sl_curr</code> by <code>1</code>.</p><p class="back"><br>Likewise, this flag is set in <a href="../understanding-memcached-source-code-II/#do-slabs-free">do_slabs_free</a>.<br></p><p>6) Return (<strong>f</strong>).</p><p>Next, we look at the process of determining the <code>id</code> based on <em>item size</em>, the workhorse method of which is</p><h2 id="slabs-clsid"><a href="#slabs-clsid" class="headerlink" title="slabs_clsid"></a>slabs_clsid</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">slabs_clsid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = POWER_SMALLEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (size &gt; slabclass[res].size)</span><br><span class="line">        <span class="keyword">if</span> (res++ == power_largest)     <span class="comment">/* won't fit in the biggest slab */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_alloc@slabs.c</text></center><p><code>slabs_clsid</code> consists mainly of a <code>while</code> loop that linear search the possible smallest <strong>slab class</strong> that can contain the requested <code>size</code>. This method is called from <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_alloc">do_item_alloc</a> before <code>slabs_alloc</code>. We will discuss <a href="#" onclick="return false;" data-toggle="collapse" data-target="#do_item_alloc">do_item_alloc</a> in the following post.</p><div id="do_item_alloc" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">item *<span class="title">do_item_alloc</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">const</span> <span class="keyword">size_t</span> nkey, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">rel_time_t</span> exptime, <span class="keyword">const</span> <span class="keyword">int</span> nbytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">uint32_t</span> cur_hv)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id = slabs_clsid(ntotal);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">        it = slabs_alloc(ntotal, id, &amp;total_chunks, <span class="number">0</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_item_alloc@items.c</text></center><br></div>]]></content>
    
    <summary type="html">
    
      Last time we saw the memory allocating process, which further formulates slabs and the derivative “free lists” (a.k.a., slots). This time we will examine how to take advantage of the established data structures to “slab allocate / release” memory chunks which will be used to store items. Firstly, we look at do_slabs_alloc
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - Slab II</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-II/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-II/</id>
    <published>2018-09-17T08:17:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="#"><text style="color:black;font-weight:bold;">II - this article</text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">, III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/diamond.svg" width="30" height="30">  <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>This time we continue examining how <strong>slab</strong>s memory is allocated.</p><p>Firstly we look at the two arguments for <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init">slabs_init</a>, which were passed over in the previous article. The first one is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_maxbytes">settings.maxbytes</a>. It limits the overall memory that can be used by the <strong>memcached</strong> instance. In <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init">slabs_init</a>, the value of <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_maxbytes">settings.maxbytes</a> is assigned to the global variable <a href="#" onclick="return false;" data-toggle="collapse" data-target="#mem_limit">mem_limit</a> which will be used very <a href="#do_slabs_newslab_mem_limit">soon</a>.</p><a id="more"></a><div id="slabs_init" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    mem_limit = limit; <span class="comment">// scr: here</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@memcached.c</text></center><br></div><div id="settings_maxbytes" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">  settings.maxbytes = <span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">/* default is 64MB */</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">            settings.maxbytes = ((<span class="keyword">size_t</span>)atoi(optarg)) * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:210,5493</text></center><br></div><div id="mem_limit" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> mem_limit = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:43</text></center><br></div><p>The other argument is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#preallocate">preallocate</a>. It determines whether to <em>preallocate</em> <strong>slab</strong> for each <strong>slab class</strong>. This argument is toggled with <code>L</code> command line argument.</p><div id="preallocate" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">   <span class="keyword">bool</span> preallocate = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'L'</span> :</span><br><span class="line">            <span class="keyword">if</span> (enable_large_pages() == <span class="number">0</span>) &#123;</span><br><span class="line">                preallocate = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot enable large pages on this system\n"</span></span><br><span class="line">                    <span class="string">"(There is no Linux support as of this version)\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5350,5597</text></center><br></div><p>Next we look at the method for <strong>slabs</strong> memory allocation itself.</p><h1 id="New-slab"><a href="#New-slab" class="headerlink" title="New slab"></a>New slab</h1><h2 id="do-slabs-newslab"><a href="#do-slabs-newslab" class="headerlink" title="do_slabs_newslab"></a>do_slabs_newslab</h2><p>More specific, this method allocates one 1M sized <strong>slab</strong> for the <strong>slab class</strong> indicated by the parameter <code>id</code>.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_slabs_newslab</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id]; <span class="comment">// scr: ----------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">slabclass_t</span> *g = &amp;slabclass[SLAB_GLOBAL_PAGE_POOL]; <span class="comment">// scr: ---------&gt; *)</span></span><br><span class="line">    <span class="keyword">int</span> len = settings.slab_reassign ? settings.item_size_max <span class="comment">// scr: ---&gt; 2)</span></span><br><span class="line">        : p-&gt;size * p-&gt;perslab;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mem_limit &amp;&amp; mem_malloced + len &gt; mem_limit &amp;&amp; p-&gt;slabs &gt; <span class="number">0</span> <span class="comment">// -&gt; 3)</span></span><br><span class="line">         &amp;&amp; g-&gt;slabs == <span class="number">0</span>)) &#123;</span><br><span class="line">        mem_limit_reached = <span class="literal">true</span>;</span><br><span class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((grow_slab_list(id) == <span class="number">0</span>) || <span class="comment">// scr: ----------------------------&gt; 4)</span></span><br><span class="line">        (((ptr = get_page_from_global_pool()) == <span class="literal">NULL</span>) &amp;&amp; <span class="comment">// scr: -------&gt; *)</span></span><br><span class="line">        ((ptr = memory_allocate((<span class="keyword">size_t</span>)len)) == <span class="number">0</span>))) &#123; <span class="comment">// scr: ---------&gt; 5)</span></span><br><span class="line"></span><br><span class="line">        MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ptr, <span class="number">0</span>, (<span class="keyword">size_t</span>)len);</span><br><span class="line">    split_slab_page_into_freelist(ptr, id); <span class="comment">// scr: ---------------------&gt; 6)</span></span><br><span class="line"></span><br><span class="line">    p-&gt;slab_list[p-&gt;slabs++] = ptr; <span class="comment">// scr: -----------------------------&gt; 7)</span></span><br><span class="line">    MEMCACHED_SLABS_SLABCLASS_ALLOCATE(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_newslab@slabs.c</text></center><p>1) <code>slabclass[id]</code> is one of the <strong>slab class</strong>, the initialization of which is discussed in <a href="../understanding-memcached-source-code-I/#Module-initialization">last article</a>.</p><p>2) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_slab_reassign">settings.slab_reassign</a> determines whether to enlist a <em>rebalancing mechanism</em>, which recycles the unused <strong>slabs</strong> and redistributes them across <strong>slab classes</strong>. This requires that <strong>slabs</strong> contained in all <strong>slab classes</strong> be of the same size, hence this <em>setting</em> also decides whether to use unanimous (i.e., <code>settings.item_size_max</code>, or 1M as mentioned <a href="../understanding-memcached-source-code-I/#What-is-a-slab">before</a>) or heterogeneous (i.e., <code>p-&gt;size * p-&gt;perslab</code>) <strong>slabs</strong>. Besides its associated command line argument <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_slab_reassign">"slab_reassign"</a>, the value can be controlled by another argument <a href="#" onclick="return false;" data-toggle="collapse" data-target="#modern">"modern"</a>. For the positivity the name “modern” implies, 1M will be used throughout the text.</p><div id="settings_slab_reassign" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    settings.slab_reassign = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> SLAB_REASSIGN:</span><br><span class="line">                settings.slab_reassign = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:238,5694</text></center><br></div><div id="modern" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">            <span class="keyword">case</span> MODERN:</span><br><span class="line">                <span class="comment">/* Modernized defaults. Need to add equivalent no_* flags</span></span><br><span class="line"><span class="comment">                 * before making truly default. */</span></span><br><span class="line">                settings.slab_reassign = <span class="literal">true</span>;</span><br><span class="line">                settings.slab_automove = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5820</text></center><br></div><a href="#" id="nb_rebalancing" style="visibility: hidden"></a><p>N.b. *, <em>rebalancing mechanism</em> will be discussed later when we have a better understanding of the LRU module. </p><a href="#" id="do_slabs_newslab_mem_limit" style="visibility: hidden"></a><p>3) Check if the memory usage will exceed the upper limit.</p><p>4) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#grow_slab_list">grow_slab_list</a> checks if we need to increase <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slab_list</a>, if so, grows it.</p><div id="grow_slab_list" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">grow_slab_list</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id];</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;slabs == p-&gt;list_size) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> new_size =  (p-&gt;list_size != <span class="number">0</span>) ? p-&gt;list_size * <span class="number">2</span> : <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">void</span> *new_list = <span class="built_in">realloc</span>(p-&gt;slab_list, new_size * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">        <span class="keyword">if</span> (new_list == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p-&gt;list_size = new_size;</span><br><span class="line">        p-&gt;slab_list = new_list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">grow_slab_list@slabs.c</text></center><br></div><p>5) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#memory_allocate">memory_allocate</a> allocates the actual memory for the <strong>slab</strong>. As discussed, here the value of <code>len</code> is 1M.</p><div id="memory_allocate" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">memory_allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mem_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* We are not using a preallocated large memory chunk */</span></span><br><span class="line">        ret = <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: when preallocate is set to true</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memory_allocate@slabs.c</text></center><br></div><p>6) <code>split_slab_page_into_freelist</code> initializes (frees) the newly allocated <code>slab</code> preparing for objects storing. This method will be discussed in the next section.</p><p>7) Add the newly allocated <code>slab</code> to the <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slab_list</a>.</p><p>What has happened so far can be summarized with the following figure, (we assume <code>do_slabs_newslab(n)</code> is called two times) </p><p><img src="../gallery/slab_alloc.png" alt="new slabs"></p><p>Now we look inside the 1M <strong>slab</strong> in step 6).</p><h2 id="split-slab-page-into-freelist"><a href="#split-slab-page-into-freelist" class="headerlink" title="split_slab_page_into_freelist"></a>split_slab_page_into_freelist</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_slab_page_into_freelist</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p = &amp;slabclass[id];</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; p-&gt;perslab; x++) &#123;</span><br><span class="line">        do_slabs_free(ptr, <span class="number">0</span>, id);</span><br><span class="line">        ptr += p-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">split_slab_page_into_freelist@slabs.c</text></center><p>This method goes through all the <em>item chunk</em>s (in the size of <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.size</a>) within a <strong>slab</strong>. And for each of them, the method initializes its meta data by calling <code>do_slabs_free</code>. Another way to interpret this process is “split a slab into <strong>item</strong> free list”. As you might have already figured out, this “free list” will be used by <strong>item allocation</strong> in the future.</p><h2 id="do-slabs-free"><a href="#do-slabs-free" class="headerlink" title="do_slabs_free"></a>do_slabs_free</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_slabs_free</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">const</span> <span class="keyword">size_t</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">slabclass_t</span> *p;</span><br><span class="line">    item *it;</span><br><span class="line">...</span><br><span class="line">    p = &amp;slabclass[id];</span><br><span class="line"></span><br><span class="line">    it = (item *)ptr;</span><br><span class="line">    it-&gt;it_flags = ITEM_SLABBED; <span class="comment">// scr: ---------------&gt; 1)</span></span><br><span class="line">    it-&gt;slabs_clsid = <span class="number">0</span>;</span><br><span class="line">    it-&gt;prev = <span class="number">0</span>; <span class="comment">// scr: ------------------------------&gt; 2)</span></span><br><span class="line">    it-&gt;next = p-&gt;slots;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;next) it-&gt;next-&gt;prev = it;</span><br><span class="line">    p-&gt;slots = it;</span><br><span class="line"></span><br><span class="line">    p-&gt;sl_curr++; <span class="comment">// scr: ------------------------------&gt; 3)</span></span><br><span class="line">    p-&gt;requested -= size;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">do_slabs_free@slabs.c</text></center><p>This method works on <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item">item meta data</a> that is populated at the beginning of an <em>item chunk</em>.</p><div id="item" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protected by LRU locks */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">stritem</span> *<span class="title">prev</span>;</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">uint8_t</span>         it_flags;   <span class="comment">/* ITEM_* above */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>         slabs_clsid;<span class="comment">/* which slab class we're in */</span></span><br><span class="line">...</span><br><span class="line">&#125; item;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5820</text></center><br></div><p>1) Initialize some fields. <a href="#" onclick="return false;" data-toggle="collapse" data-target="#item">item</a> is another core data structure, we will come back to <strong>item</strong> data structure later.</p><p>2) Add the <strong>item</strong> to the front of the linked list (a.k.a., free list). And update the list head, <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.slots</a>.</p><p>3) Update the available (free list) slot count, <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.sl_curr</a>; and updates the <a href="../understanding-memcached-source-code-I/#core_ds">slabclass_t.requested</a> for statistic. Note that here we are not actually releasing an <strong>item</strong>, so the passed <code>size</code> is 0.</p><p><img src="../gallery/slab_free_list.png" alt="free list"></p><h1 id="Slab-preallocate"><a href="#Slab-preallocate" class="headerlink" title="Slab preallocate"></a>Slab preallocate</h1><p>Next we look at how <code>do_slabs_newslab</code> is used. One place it gets called is from the discussed <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slabs_init_1">slabs_init</a> when <code>preallocate</code> is set to <code>true</code>,</p><div id="slabs_init_1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (prealloc) &#123;</span><br><span class="line">        slabs_preallocate(power_largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@slabs.c</text></center><br></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slabs_preallocate</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> maxslabs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prealloc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pre-allocate a 1MB slab in every size class so people don't get</span></span><br><span class="line"><span class="comment">       confused by non-intuitive "SERVER_ERROR out of memory"</span></span><br><span class="line"><span class="comment">       messages.  this is the most common question on the mailing</span></span><br><span class="line"><span class="comment">       list.  if you really don't want this, you can rebuild without</span></span><br><span class="line"><span class="comment">       these three lines.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = POWER_SMALLEST <span class="comment">/* scr: 1 */</span>; i &lt; MAX_NUMBER_OF_SLAB_CLASSES; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++prealloc &gt; maxslabs)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (do_slabs_newslab(i) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error while preallocating slab memory!\n"</span></span><br><span class="line">                <span class="string">"If using -L or other prealloc options, max memory must be "</span></span><br><span class="line">                <span class="string">"at least %d megabytes.\n"</span>, power_largest);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_preallocate@slabs.c</text></center><p>This method simply goes through the <a href="../understanding-memcached-source-code-I/#core_ds">slabclass</a> starting from the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#defines">POWER_SMALLEST</a>, i.e., 1st entry, and allocate one <strong>slab</strong> for each of them. Note that the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#defines">0th</a> is a special <strong>slab class</strong> used by mentioned <em>rebalancing mechanism</em>.</p><div id="defines" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_SMALLEST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POWER_LARGEST 256 <span class="comment">/* actual cap is 255 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLAB_GLOBAL_PAGE_POOL 0 <span class="comment">/* magic slab class for storing pages for reassignment */</span></span></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.h:88</text></center><br></div><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>Same to <a href="../understanding-memcached-source-code-I/#References">the last article</a>.</p>]]></content>
    
    <summary type="html">
    
      This time we continue examining how slabs memory is allocated. Firstly we look at the two arguments for slabs_init, which were passed over in the previous article. The first one is settings.maxbytes. It limits the overall memory that can be used by the memcached instance. In slabs_init, the value of settings.maxbytes is assigned to the global variable mem_limit which will be used very soon. The other argument is preallocate. It determines whether to preallocate slab for each slab class. This argument is toggled with L command line argument.
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
      <category term="source code analysis" scheme="https://holmeshe.me/tags/source-code-analysis/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The Memcached Source Code - Slab I</title>
    <link href="https://holmeshe.me/understanding-memcached-source-code-I/"/>
    <id>https://holmeshe.me/understanding-memcached-source-code-I/</id>
    <published>2018-09-12T09:17:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I - this article</text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">, III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p><p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p><p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p><p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="../gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p><p>are built around it.</p><p>Variants of <strong>slab allocator</strong> is implemented in other systems, such as nginx and Linux kernel, to fight a common problem called <strong>memory fragmentation</strong>. And this article will, of course, focus on <strong>Memcached</strong>‘s implementation of the algorithm.</p><p><strong>memcached version: 1.4.28</strong></p><p>Firstly, let’s answer some questions.</p><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="What-is-a-slab"><a href="#What-is-a-slab" class="headerlink" title="What is a slab"></a>What is a slab</h2><p><strong>slab</strong>s are pre-allocated 1M memory chunks that can be subdivided for numerous objects. They are grouped into <strong>slab class</strong>es to serve allocation requests for various sizes.</p><h2 id="What-is-memory-fragmentation-how-it-occurs"><a href="#What-is-memory-fragmentation-how-it-occurs" class="headerlink" title="What is memory fragmentation, how it occurs"></a>What is memory fragmentation, how it occurs</h2><p>In particular, <strong>slab allocator</strong> curbs <strong>internal memory fragmentation</strong>. This kind of fragmentation exits within an allocated memory chunk. In the context of OS kernel, for instance, the fundamental unit allocated by memory management sub-system is called a <em>page</em>.</p><blockquote><p>On the other hand, <strong>external memory fragmentation</strong> exists across chunks, and the solution of which (keyword: buddy) belongs to another story.</p></blockquote><p>The most common phenomenon where <strong>internal fragmentation</strong> causes the problem is as following:</p><p>1) <code>malloc</code> of small objects is called a lot of times; and in the meantime;</p><p>2) <code>free</code> of those objects is called a lot of times.</p><p>The above process generates (a lot of) nominal “free” memory that cannot be utilized, as the discrete holes of various sizes, or <strong>fragments</strong>, can not be reused by subsequent <code>malloc</code>s for any objects that are larger than them.</p><h2 id="Why-memory-fragmentation-is-bad"><a href="#Why-memory-fragmentation-is-bad" class="headerlink" title="Why memory fragmentation is bad"></a>Why memory fragmentation is bad</h2><p>The impact of <strong>memory fragmentation</strong> is similar to that of <strong>memory leak</strong> - periodical system reboot is inevitable whenever the fragments accumulate to a certain level, which, increase the complexity in system operation, or even worse, leads to bad user experiences.</p><h2 id="How-the-problem-is-fixed"><a href="#How-the-problem-is-fixed" class="headerlink" title="How the problem is fixed"></a>How the problem is fixed</h2><p><strong>Slab allocator</strong> does not eliminate <strong>internal fragmentation</strong>. Instead, it converges the fragments and locks them in fixated memory locations. This is done by 1) categorizing objects of similar sizes in <strong>classes</strong>; and 2) allocating objects belonging to the same <strong>class</strong> only on the same group of “<strong>slab</strong>s”, or, a <strong>slab class</strong>.</p><p>The detail devil is in the code, so we start reading the code.</p><p><strong>reminder: Memcached version is 1.4.28</strong></p><p>The core data structure in use<br><a href="#" id="core_ds" style="visibility: hidden"></a><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;      <span class="comment">/* sizes of items */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> perslab;   <span class="comment">/* how many items per slab */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *slots;           <span class="comment">/* list of item ptrs */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sl_curr;   <span class="comment">/* total free items in list */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> slabs;     <span class="comment">/* how many slabs were allocated for this class */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> **slab_list;       <span class="comment">/* array of slab pointers */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> list_size; <span class="comment">/* size of prev array */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> requested; <span class="comment">/* The number of requested bytes */</span></span><br><span class="line">&#125; <span class="keyword">slabclass_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">slabclass_t</span> slabclass[MAX_NUMBER_OF_SLAB_CLASSES];</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabclass_t@slabs.c</text></center></p><h1 id="Module-initialization"><a href="#Module-initialization" class="headerlink" title="Module initialization"></a>Module initialization</h1><p>In this section we examine <code>slabs_init</code> that initializes <code>slabclass[MAX_NUMBER_OF_SLAB_CLASSES]</code> array. In particular, this process initializes the values of two fields, i.e., <code>slabclass_t.size</code>, the item (object) size of each <strong>slab class</strong>, and <code>slabclass_t.perslab</code> the item number one <strong>slab</strong> contains. This method is called from <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet1">here</a> as one of the <em>init</em> steps before the logic enters the <em>main even loop</em>.</p><div id="snippet1" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    assoc_init(settings.hashpower_init);</span><br><span class="line">    conn_init();</span><br><span class="line">    slabs_init(settings.maxbytes, settings.factor, preallocate,</span><br><span class="line">               use_slab_sizes ? slab_sizes : <span class="literal">NULL</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5977</text></center><br></div><p>In this step <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_sizes">slab_sizes</a> and <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_factor">settings.factor</a> jointly control the routes in which sizes of each <strong>slab class</strong> are decided, they are:</p><div id="slab_sizes" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> slab_sizes[MAX_NUMBER_OF_SLAB_CLASSES];</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5372</text></center><br></div><div id="settings_factor" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.factor = <span class="number">1.25</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">settings_init@memcached.c:217</text></center><br></div><p>a) if <a href="#" onclick="return false;" data-toggle="collapse" data-target="#slab_sizes">slab_sizes</a> is not <code>NULL</code>, the values within the array are used directly; and</p><p>b) otherwise, the sizes are calculated as <em>base size</em> × <em>n</em> × <code>settings.factor</code> where <em>n</em> is the index within <code>slabclass</code>.</p><p>Besides the default values, the two arguments can be set <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet2">at runtime</a> as well.</p><div id="snippet2" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">            settings.factor = atof(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.factor &lt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Factor must be greater than 1\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'o'</span>: <span class="comment">/* It's sub-opts time! */</span></span><br><span class="line">...</span><br><span class="line">            <span class="keyword">case</span> SLAB_SIZES:</span><br><span class="line">                <span class="keyword">if</span> (_parse_slab_sizes(subopts_value, slab_sizes)) &#123;</span><br><span class="line">                    use_slab_sizes = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5558, 5810</text></center><br></div><p>The other two arguments of this method <code>settings.maxbytes</code> and <code>preallocate</code> will be discussed <a href="../understanding-memcached-source-code-II">soon</a>. For now we set <code>false</code> to <code>preallocate</code> and ignore the relevant logic flow.</p><p>Next we look at the <code>slabs_init</code> itself.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slabs_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> limit, <span class="keyword">const</span> <span class="keyword">double</span> factor, <span class="keyword">const</span> <span class="keyword">bool</span> prealloc, <span class="keyword">const</span> <span class="keyword">uint32_t</span> *slab_sizes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = POWER_SMALLEST <span class="comment">/* scr: 1 */</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(item) + settings.chunk_size; <span class="comment">// scr: ---------&gt; b 1)</span></span><br><span class="line">...</span><br><span class="line">    <span class="built_in">memset</span>(slabclass, <span class="number">0</span>, <span class="keyword">sizeof</span>(slabclass));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (++i &lt; MAX_NUMBER_OF_SLAB_CLASSES<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slab_sizes != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: -----------------------------------&gt; a 1)</span></span><br><span class="line">            <span class="keyword">if</span> (slab_sizes[i<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            size = slab_sizes[i<span class="number">-1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt;= settings.item_size_max / factor) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Make sure items are always n-byte aligned */</span></span><br><span class="line">        <span class="keyword">if</span> (size % CHUNK_ALIGN_BYTES) <span class="comment">// scr: ---------------------------------&gt; 2)</span></span><br><span class="line">            size += CHUNK_ALIGN_BYTES - (size % CHUNK_ALIGN_BYTES);</span><br><span class="line"></span><br><span class="line">        slabclass[i].size = size;</span><br><span class="line">        slabclass[i].perslab = settings.item_size_max / slabclass[i].size; <span class="comment">// -&gt; 3)</span></span><br><span class="line">        <span class="keyword">if</span> (slab_sizes == <span class="literal">NULL</span>)</span><br><span class="line">            size *= factor; <span class="comment">// scr: -----------------------------------------&gt; b 4)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"slab class %3d: chunk size %9u perslab %7u\n"</span>,</span><br><span class="line">                    i, slabclass[i].size, slabclass[i].perslab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scr: -------------------------------------------------------------------&gt; 5)</span></span><br><span class="line">    power_largest = i;</span><br><span class="line">    slabclass[power_largest].size = settings.item_size_max;</span><br><span class="line">    slabclass[power_largest].perslab = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">slabs_init@slabs.c</text></center><h2 id="Route-a"><a href="#Route-a" class="headerlink" title="Route a"></a>Route a</h2><p>1) use the values in <code>slab_sizes</code>;</p><p>2) align the <code>size</code> to <code>CHUNK_ALIGN_BYTES</code>, and give the result to <code>slabclass[i].size</code>;</p><p>3) calculate the <code>slabclass[i].perslab</code>;</p><p>5) use the <code>settings.item_size_max</code> to initialize the last <strong>slab class</strong>.</p><p>Note that <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_item_size_max">settings.item_size_max</a> is the size of each <strong>slab</strong>, hence it is also the max size of items that are allocated on <em>slabs</em>. Likewise, the value of  <a href="#" onclick="return false;" data-toggle="collapse" data-target="#settings_item_size_max">settings.item_size_max</a> can be decided in <a href="#" onclick="return false;" data-toggle="collapse" data-target="#snippet3">runtime</a>.</p><div id="settings_item_size_max" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">settings.item_size_max = <span class="number">1024</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">settings_init@memcached.c:226</text></center><br></div><div id="snippet3" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">    buf = strdup(optarg);</span><br><span class="line">    unit = buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span> (unit == <span class="string">'k'</span> || unit == <span class="string">'m'</span> ||</span><br><span class="line">        unit == <span class="string">'K'</span> || unit == <span class="string">'M'</span>) &#123;</span><br><span class="line">        buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        size_max = atoi(buf);</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="string">'k'</span> || unit == <span class="string">'K'</span>)</span><br><span class="line">            size_max *= <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">if</span> (unit == <span class="string">'m'</span> || unit == <span class="string">'M'</span>)</span><br><span class="line">            size_max *= <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        settings.item_size_max = size_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        settings.item_size_max = atoi(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Item max size cannot be less than 1024 bytes.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &gt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">128</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Cannot set item size limit higher than 128 mb.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (settings.item_size_max &gt; <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting item max size above 1MB is not"</span></span><br><span class="line">            <span class="string">" recommended!\n"</span></span><br><span class="line">            <span class="string">" Raising this limit increases the minimum memory requirements\n"</span></span><br><span class="line">            <span class="string">" and will decrease your memory efficiency.\n"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c:5626</text></center><br></div><h2 id="Route-b"><a href="#Route-b" class="headerlink" title="Route b"></a>Route b</h2><p>1) calculate the <em>base size</em> with <em>settings.chunk_size</em> plus the extra bytes for metadata (<code>item</code> will be discussed in following articles);</p><p>2) align the <code>size</code> to <code>CHUNK_ALIGN_BYTES</code>, and give the result to <code>slabclass[i].size</code>; (same to route a)</p><p>3) calculate the <code>slabclass[i].perslab</code>;  (same to route a)</p><p>4) calculate the size for the next <code>slab class</code> using <code>factor</code> (<code>settings.factor</code>);</p><p>5) use the <code>settings.item_size_max</code> to initialize the last <strong>slab class</strong>. (same to route a)</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://github.com/memcached/memcached/wiki" target="_blank" rel="noopener">memcached wiki</a></p><p><a href="http://gihyo.jp/dev/feature/01/memcached/0002" target="_blank" rel="noopener">第2回　memcachedのメモリストレージを理解する</a></p><p><a href="https://blog.csdn.net/initphp/article/details/44888555" target="_blank" rel="noopener">Memcached源码分析之存储机制Slabs（7）</a></p><p><a href="https://gokulvasanblog.wordpress.com/2016/07/11/understanding-malloc-part1/" target="_blank" rel="noopener">Understanding Malloc</a></p><p><a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html" target="_blank" rel="noopener">Ch8 - Slab Allocator</a></p><p><a href="https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a" target="_blank" rel="noopener">The Slab Allocator:An Object-Caching Kernel Memory Allocator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;#&quot; class=&quot;fancybox&quot;&gt;&lt;img align=&quot;left&quot; style=&quot;padding-right:10px;&quot; src=&quot;../gallery/spade.svg&quot; width=&quot;30&quot; height=&quot;30&quot;&gt; &lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;slab allocator (I - this article&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-II/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, II&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-III/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, III)&lt;/text&gt;&lt;/a&gt; is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/understanding-memcached-source-code-IV/&quot; class=&quot;fancybox&quot;&gt;&lt;img align=&quot;left&quot; style=&quot;padding-right:10px;&quot; src=&quot;../gallery/heart.svg&quot; width=&quot;30&quot; height=&quot;30&quot;&gt; &lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;LRU algorithm (I&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-V/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, II&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-VI/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, III)&lt;/text&gt;&lt;/a&gt; for entry expiration; and an&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/understanding-memcached-source-code-VII/&quot; class=&quot;fancybox&quot;&gt;&lt;img align=&quot;left&quot; style=&quot;padding-right:10px;&quot; src=&quot;../gallery/club.svg&quot; width=&quot;30&quot; height=&quot;30&quot;&gt; &lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;event driven model (I&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-VIII/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, II&lt;/text&gt;&lt;/a&gt; &lt;a href=&quot;/understanding-memcached-source-code-IX/&quot;&gt;&lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;, III)&lt;/text&gt;&lt;/a&gt; based on libevent; and the&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#&quot; class=&quot;fancybox&quot;&gt;&lt;img align=&quot;left&quot; style=&quot;padding-right:10px;&quot; src=&quot;../gallery/diamond.svg&quot; width=&quot;30&quot; height=&quot;30&quot;&gt; &lt;text style=&quot;color:black;font-weight:bold;&quot;&gt;consistent harsh (not complete)&lt;/text&gt;&lt;/a&gt; for data distribution,&lt;/p&gt;
&lt;p&gt;are built around it.&lt;/p&gt;
&lt;p&gt;Variants of &lt;strong&gt;slab allocator&lt;/strong&gt; is implemented in other systems, such as nginx and Linux kernel, to fight a common problem called &lt;strong&gt;memory fragmentation&lt;/strong&gt;. And this article will, of course, focus on &lt;strong&gt;Memcached&lt;/strong&gt;‘s implementation of the algorithm.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;memcached version: 1.4.28&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Firstly, let’s answer some questions.&lt;/p&gt;
    
    </summary>
    
      <category term="Memcached Source Code" scheme="https://holmeshe.me/categories/Memcached-Source-Code/"/>
    
    
      <category term="memcached" scheme="https://holmeshe.me/tags/memcached/"/>
    
      <category term="slab allocator" scheme="https://holmeshe.me/tags/slab-allocator/"/>
    
      <category term="cache" scheme="https://holmeshe.me/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>setsockopt, TCP_NODELAY and Packet Aggregation I</title>
    <link href="https://holmeshe.me/network-essentials-setsockopt-TCP_NODELAY/"/>
    <id>https://holmeshe.me/network-essentials-setsockopt-TCP_NODELAY/</id>
    <published>2018-06-08T23:47:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p>Latency, instead of throughput, is found as the system bottleneck more often than not. However, the TCP socket enables a so-called <em>nagle algorithm</em> by default, which delays an egress packet in order to coalesces it with one that could be sent in the future, into a single TCP segment. This effectively reduces the number of TCP segments and the bandwidth overhead used by the TCP headers, whilst potentially imposes latency for every network request (response) being sent.</p><blockquote><p>Lock, and his temperamental brother, Block, are the two notorious villains in the world of programming. In the beginning, they always show up to assist. But sooner or later, they will kick your back-end like really hard.</p></blockquote><p>When I consider about <em>nagle algorithem</em>, it seems to me another scenario involving block operations which are meant to be helpful. So I decide to put hands on a keyboard to test if I am wrong.</p><p><strong>Software setup</strong><br><em>Client OS: Debian 4.9.88</em><br><em>Server OS (LAN &amp; WAN): Unbutu 16.04</em><br><em>gcc: 6.3.0</em></p><p><strong>Hardware (or VM) setup</strong><br><em>Server (LAN): Intel® Core™2 Duo CPU E8400 @ 3.00GHz × 2, 4GB</em><br><em>Server (WAN): t2.micro, 1GB</em></p><a id="more"></a><h1 id="The-impact-nagle-algorithm-has-on-latency"><a href="#The-impact-nagle-algorithm-has-on-latency" class="headerlink" title="The impact nagle algorithm has on latency"></a>The impact <em>nagle algorithm</em> has on latency</h1><p>First thing first, the code of client:</p><script src="https://gist.github.com/holmeshe/f8737a7aecbf368fdfe6fa0c5d0f897a.js"></script><p>and server:</p><script src="https://gist.github.com/holmeshe/6fc669c486b2070e2e482420ad0d0272.js"></script><p>The client code given above sends 1000 packets 4 bytes long in an interval indicated by the last command line argument. And as discussed, it adopts the default TCP behavior by default. The server is not different than a discard server, so the code is irrelevant here.</p><p>In this test, I will record the number of packets that are aggregated in different intervals, by adjusting the mentioned argument. This way, we can grasp the extent of latency the <em>nagle algorithm</em> can impose. The same test is conducted in both LAN (RTT &lt; 0.6ms) and WAN (RTT ≈ 200ms).</p><p><img src="../gallery/nagle-lan.png" alt="1000 packets through LAN"></p><p><img src="../gallery/nagle-wan.png" alt="1000 packets through WAN"></p><p>As given in the figures, the number aggregated packets approaches to 0 when the interval is greater than the RTT. This conforms to what described in &lt;&lt;TCP/IP Illustrated&gt;&gt;</p><blockquote><p>This algorithm says that a TCP connection can have only one outstanding small segment that has not yet been acknowledged. No additional small segments can be sent until the acknowledgment is received.</p></blockquote><p>If looking at the <code>tcpdump</code> output, we can also see that this algorithm effectively changes the sending interval to the RTT regardless of the actual <code>write(2)</code> frequency of the program. And the packets between two sends are those being aggregated.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">18:34:52.986972 IP debian.53700 &gt; ******.compute.amazonaws.com.6666: Flags [P.], seq 4:12, ack 1, win 229, options [nop,nop,TS val 7541746 ecr 2617170332], length 8</span><br><span class="line">18:34:53.178277 IP debian.53700 &gt; ******.amazonaws.com.6666: Flags [P.], seq 12:20, ack 1, win 229, options [nop,nop,TS val 7541794 ecr 2617170379], length 8</span><br><span class="line">18:34:53.369431 IP debian.53700 &gt; ******.amazonaws.com.6666: Flags [P.], seq 20:32, ack 1, win 229, options [nop,nop,TS val 7541842 ecr 2617170427], length 12</span><br><span class="line">18:34:53.560351 IP debian.53700 &gt; ******.amazonaws.com.6666: Flags [P.], seq 32:40, ack 1, win 229, options [nop,nop,TS val 7541890 ecr 2617170475], length 8</span><br><span class="line">18:34:54.325242 IP debian.53700 &gt; ******.amazonaws.com.6666: Flags [P.], seq 68:80, ack 1, win 229, options [nop,nop,TS val 7542081 ecr 2617170666], length 12</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>As a result, the delay imposed on every packet by the algorithm is RTT on average and 2 * RTT in worst case.</strong></p><h1 id="Combined-with-delayed-ACK"><a href="#Combined-with-delayed-ACK" class="headerlink" title="Combined with delayed ACK"></a>Combined with delayed ACK</h1><p>Delayed ACK is another similar algorithm, here I will just use the lines from &lt;&lt;TCP/IP Illustrated&gt;&gt; to brief the mechanism</p><blockquote><p>TCP will delay an ACK up to 200 ms to see if there is data to send with the ACK.</p></blockquote><p>Apperantly <em>nagle algorithm</em> is <a href="https://news.ycombinator.com/item?id=10607422" target="_blank" rel="noopener">not happy</a> with <em>delayed ACK</em>.</p><p>In some cases when the back-end do not reply instantly to a request, <em>delayed ACK</em> will have to wait for another request which is potentially delayed by <em>nagle algorithm</em> waiting for ACK. This senario where two resources waiting for each other, in another word, is called a dead-lock. </p><blockquote><p>Remember the two brothers mentioned in the beginning?</p></blockquote><p>Unfortunately, in my environments, seems like the <em>delayed ACK</em> is disabled by default and I failed to enable it by</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flags = 0;</span><br><span class="line">flglen = sizeof(flags);</span><br><span class="line">getsockopt(sfd, SOL_TCP, TCP_QUICKACK, &amp;flags, &amp;flglen)</span><br></pre></td></tr></table></figure><p>So I could not hand test the compounded impact.</p><h1 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h1><p>At the moment when I am writing, except for <em>telnet</em>, most of the other applications, including those of front-end(<em>Firefox</em>, <em>Chromium</em>), back-end(<em>nginx</em>, <em>memcached</em>), and the <em>telnet</em>‘s substitute, <em>ssh</em>, disable <em>nagle algorithm</em> with some code like bellow,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int flags =1;</span><br><span class="line">setsockopt(sfd, SOL_TCP, TCP_NODELAY, (void *)&amp;flags, sizeof(flags));</span><br></pre></td></tr></table></figure><p>which indicates that the packets should be emitted as it is.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">18:22:38.983278 IP debian.43808 &gt; 192.168.1.71.6666: Flags [P.], seq 1:5, ack 1, win 229, options [nop,nop,TS val 7358245 ecr 6906652], length 4</span><br><span class="line">18:22:38.984149 IP debian.43808 &gt; 192.168.1.71.6666: Flags [P.], seq 5:9, ack 1, win 229, options [nop,nop,TS val 7358246 ecr 6906652], length 4</span><br><span class="line">18:22:38.985028 IP debian.43808 &gt; 192.168.1.71.6666: Flags [P.], seq 9:13, ack 1, win 229, options [nop,nop,TS val 7358246 ecr 6906653], length 4</span><br><span class="line">18:22:38.985897 IP debian.43808 &gt; 192.168.1.71.6666: Flags [P.], seq 13:17, ack 1, win 229, options [nop,nop,TS val 7358246 ecr 6906653], length 4</span><br><span class="line">18:22:38.986765 IP debian.43808 &gt; 192.168.1.71.6666: Flags [P.], seq 17:21, ack 1, win 229, options [nop,nop,TS val 7358246 ecr 6906653], length 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>I think the reasons behind the prevalence of <code>TCP_NODELAY</code> are as follows,<br>1) the increasing bandwidth makes the benefits of <em>nagle algorithm</em> more and more negligible - it requires hundreds of thousands of tinygrams to saturate an edge node with mediocre bandwidth nowadays; and<br>2) app that generate a lot of tinygram tend to demand low latency.</p><p>To conclude, technically, it’s probably not a good idea to turn a modern real-time on-line battle arena into some (200 ms) turn based 80s RPG.</p><p><img src="../gallery/old-rpg.gif" alt="80s RPG"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.amazon.com/TCP-Illustrated-Vol-Addison-Wesley-Professional/dp/0201633469" target="_blank" rel="noopener">TCP/IP Illustrated</a><br><a href="https://tools.ietf.org/html/rfc896" target="_blank" rel="noopener">RFC 896</a><br><a href="https://news.ycombinator.com/item?id=10607422" target="_blank" rel="noopener">Hacker news</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Latency, instead of throughput, is found as the system bottleneck more often than not. However, the TCP socket enables a so-called &lt;em&gt;nagle algorithm&lt;/em&gt; by default, which delays an egress packet in order to coalesces it with one that could be sent in the future, into a single TCP segment. This effectively reduces the number of TCP segments and the bandwidth overhead used by the TCP headers, whilst potentially imposes latency for every network request (response) being sent.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lock, and his temperamental brother, Block, are the two notorious villains in the world of programming. In the beginning, they always show up to assist. But sooner or later, they will kick your back-end like really hard.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When I consider about &lt;em&gt;nagle algorithem&lt;/em&gt;, it seems to me another scenario involving block operations which are meant to be helpful. So I decide to put hands on a keyboard to test if I am wrong.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Software setup&lt;/strong&gt;&lt;br&gt;&lt;em&gt;Client OS: Debian 4.9.88&lt;/em&gt;&lt;br&gt;&lt;em&gt;Server OS (LAN &amp;amp; WAN): Unbutu 16.04&lt;/em&gt;&lt;br&gt;&lt;em&gt;gcc: 6.3.0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hardware (or VM) setup&lt;/strong&gt;&lt;br&gt;&lt;em&gt;Server (LAN): Intel® Core™2 Duo CPU E8400 @ 3.00GHz × 2, 4GB&lt;/em&gt;&lt;br&gt;&lt;em&gt;Server (WAN): t2.micro, 1GB&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Network Essentials" scheme="https://holmeshe.me/categories/Network-Essentials/"/>
    
    
      <category term="network" scheme="https://holmeshe.me/tags/network/"/>
    
      <category term="socket" scheme="https://holmeshe.me/tags/socket/"/>
    
      <category term="setsockopt" scheme="https://holmeshe.me/tags/setsockopt/"/>
    
      <category term="SOL_TCP" scheme="https://holmeshe.me/tags/SOL-TCP/"/>
    
      <category term="TCP_NODELAY" scheme="https://holmeshe.me/tags/TCP-NODELAY/"/>
    
      <category term="packet aggregation" scheme="https://holmeshe.me/tags/packet-aggregation/"/>
    
      <category term="nagle algorithm" scheme="https://holmeshe.me/tags/nagle-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>setsockopt, SO_KEEPALIVE and Heartbeats</title>
    <link href="https://holmeshe.me/network-essentials-setsockopt-SO_KEEPALIVE/"/>
    <id>https://holmeshe.me/network-essentials-setsockopt-SO_KEEPALIVE/</id>
    <published>2018-05-27T08:45:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p>There are two end purposes for sending heartbeats through a persistent connection. For a back-end application, heartbeats are generally used to detect an absent client, so as to drop a connection and release the associated resources; for a client, on the contrary, it is to prevent connection resources stored within intermediate nodes being released (such as a <em>NAT</em> router), <code>SO</code> as to <code>KEEP</code> the connection <code>ALIVE</code>.</p><p>This article will examine how to configure the four socket options, <code>SO_KEEPALIVE</code>, <code>TCP_KEEPIDLE</code>, <code>TCP_KEEPINTVL</code> and <code>TCP_KEEPCNT</code> with <code>setsockopt()</code> to send heartbeats; and discuss the practice of keep-alive heartbeats in general.</p><p><strong>Experiment setting</strong>:<br><em>OS: Unbutu 16.04</em><br><em>gcc: 5.4.0</em></p><a id="more"></a><h1 id="To-keep-the-connection-alive"><a href="#To-keep-the-connection-alive" class="headerlink" title="To keep the connection alive"></a>To keep the connection alive</h1><p>One cause of silent connection drop is <em>NAT</em> entry timeout. A <em>NAT</em> entry consisting of the 4-tuple (source address, source port, destination address and destination port) is recorded by a <strong>network</strong> router internally for <strong>address translation</strong>. Due to limited memory available to the hardware, the router has to remove the entry belonging to an inactive session after a timeout. As a result, the connection is effectively closed even though neither ends have explicitly issued a <code>FIN</code> nor <code>RST</code>.</p><p>Reconnecting is expensive. An end user has to wait for at least 3xRTT spent by handshakes; and additional logic is required to smoothly restore the UX with the previously interrupted state after the user is back on-line.</p><blockquote><p>In order to avoid the unnecessary handshakes and the RTTs imposed, HTTP adopts KEEP-ALIVE so that the short-lived HTTP sessions can reuse the same established, persistent TCP connection, which is another story.</p></blockquote><p>Next, I will use two programs to illustrate how it works exactly. We look at the code of a server first,</p><script src="https://gist.github.com/holmeshe/4eb2313d6c67872de5d628864bec0e99.js"></script><p>For simplicity, I do not apply IO multiplexing so the server can accept connect from 1 client one time.</p><p>the code of client,</p><script src="https://gist.github.com/holmeshe/a8186dd3020840dc4337f7b139da4550.js"></script><p>After setting the socket options mentioned before, the client initiates the TCP handshakes by <code>connect()</code>, and yield the CPU by <code>sleep()</code>.</p><blockquote><p>If you are not familiar with network programming (<code>socket</code>), please read <a href="http://www.cs.rpi.edu/~moorthy/Courses/os98/Pgms/socket.html" target="_blank" rel="noopener">this</a> first.</p></blockquote><p>Next, let’s see the network interaction in action.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tcpdump -i wlp3s0 dst net 192.168.1.71 or src net 192.168.1.71 and not dst port 22 and not src port 22</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ========================&gt; start handshakes</span><br><span class="line">12:21:42.437163 IP 192.168.1.66.43066 &gt; 192.168.1.71.6666: Flags [S], seq 3002564942, win 29200, options [mss 1460,sackOK,TS val 7961984 ecr 0,nop,wscale 7], length 0</span><br><span class="line">12:21:42.439960 IP 192.168.1.71.6666 &gt; 192.168.1.66.43066: Flags [S.], seq 3450454053, ack 3002564943, win 28960, options [mss 1460,sackOK,TS val 2221927 ecr 7961984,nop,wscale 7], length 0</span><br><span class="line">12:21:42.440088 IP 192.168.1.66.43066 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 7961985 ecr 2221927], length 0</span><br><span class="line">// ========================&gt; end handshakes</span><br><span class="line">12:21:52.452057 IP 192.168.1.66.43066 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 7964488 ecr 2221927], length 0</span><br><span class="line">12:21:52.454443 IP 192.168.1.71.6666 &gt; 192.168.1.66.43066: Flags [.], ack 1, win 227, options [nop,nop,TS val 2224431 ecr 7961985], length 0</span><br><span class="line">12:22:02.468056 IP 192.168.1.66.43066 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 7966992 ecr 2224431], length 0</span><br><span class="line">12:22:02.470458 IP 192.168.1.71.6666 &gt; 192.168.1.66.43066: Flags [.], ack 1, win 227, options [nop,nop,TS val 2226935 ecr 7961985], length 0</span><br><span class="line">12:22:12.484119 IP 192.168.1.66.43066 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 7969496 ecr 2226935], length 0</span><br><span class="line">12:22:12.489786 IP 192.168.1.71.6666 &gt; 192.168.1.66.43066: Flags [.], ack 1, win 227, options [nop,nop,TS val 2229440 ecr 7961985], length 0</span><br></pre></td></tr></table></figure><blockquote><p>Here I removed the irrelevant output of <code>ARP</code>s. If you are not familiar with <code>tcpdump</code>, please read <a href="https://danielmiessler.com/study/tcpdump/" target="_blank" rel="noopener">this</a> first.</p></blockquote><p>With the feet gotten wet, now it’s a good time to explain the heartbeat mechanism,</p><p>1) <code>SO_KEEPALIVE</code> enables (or disables) heartbeat;<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> flags =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags))) &#123; perror(<span class="string">"ERROR: setsocketopt(), SO_KEEPALIVE"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;;</span><br></pre></td></tr></table></figure></p><p>and</p><p>2) the side with heartbeat enabled (in this example, client) sends empty packets (&#x1f441; <code>length 0</code>); and<br>3) after received the packets, the other side (server) reply with <code>ACK</code> (&#x1f441; <code>Flags [.]</code>); and<br>4) <code>TCP_KEEPIDLE</code> defines the heartbeat frequency (&#x1f441; timestamps).<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flags = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sfd, SOL_TCP, TCP_KEEPIDLE, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags))) &#123; perror(<span class="string">"ERROR: setsocketopt(), SO_KEEPIDLE"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;;</span><br></pre></td></tr></table></figure></p><p>Note that throughout the process, the <code>read()</code> is blocked in the server side, which means the heartbeat packets are transparent to the recipient (server).</p><h1 id="To-detect-an-absent-peer"><a href="#To-detect-an-absent-peer" class="headerlink" title="To detect an absent peer"></a>To detect an absent peer</h1><p>Besides <em>NAT</em> entry expiration, a connection can be dropped silently in one way or another (e.g., a loosen cable). It is crucial for a server application to identify such exception in time, so it can release the associated resources, invoke clean-up routines and/or notify other peer clients. This is why sending heartbeats from server-side makes more sense.</p><p>Since our feet is already wet.<br>5) <code>TCP_KEEPINTVL</code> defines the heartbeat frequency when there is no answer from the other side; and<br>6) <code>TCP_KEEPCNT</code> dictates how many unanswered heartbeat will indicate a dropped connection;</p><p>Next we modify the server and client code to test this feature</p><p>in server, we added all the mentioned socket options,</p><script src="https://gist.github.com/holmeshe/7157ca6174964e1114a7d670e581416a.js"></script><p>and client is reduced to</p><script src="https://gist.github.com/holmeshe/c5a19a16f2accd0a4548c15eda3c13ba.js"></script><p>and the <code>tcpdump</code> output (that is executed on server machine, because we are going to unplug the connection from client)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ========================&gt; handshakes are omitted here</span><br><span class="line">20:04:12.535386 IP 192.168.1.66.49232 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 12312604 ecr 9154395], length 0</span><br><span class="line">20:04:22.538591 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9161936 ecr 12312604], length 0</span><br><span class="line">20:04:22.570817 IP 192.168.1.66.49232 &gt; 192.168.1.71.6666: Flags [.], ack 1, win 229, options [nop,nop,TS val 12315113 ecr 9154395], length 0</span><br><span class="line">// ========================&gt; we unplug the network connection here</span><br><span class="line">20:04:32.586590 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9164448 ecr 12315113], length 0</span><br><span class="line">20:04:37.594590 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9165700 ecr 12315113], length 0</span><br><span class="line">20:04:42.602590 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9166952 ecr 12315113], length 0</span><br><span class="line">20:04:47.610591 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9168204 ecr 12315113], length 0</span><br><span class="line">20:04:52.618596 IP 192.168.1.71.6666 &gt; 192.168.1.66.49232: Flags [.], ack 1, win 227, options [nop,nop,TS val 9169456 ecr 12315113], length 0</span><br></pre></td></tr></table></figure><p>Because we set 5 as the threshold number of unacknowledged packets, and each is 5 seconds apart, (&#x1f441; timestamps)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flags = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sfd, SOL_TCP, TCP_KEEPCNT, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags))) &#123; perror(<span class="string">"ERROR: setsocketopt(), SO_KEEPCNT"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;;</span><br><span class="line"></span><br><span class="line">flags = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (setsockopt(sfd, SOL_TCP, TCP_KEEPINTVL, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags))) &#123; perror(<span class="string">"ERROR: setsocketopt(), SO_KEEPINTVL"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;;</span><br></pre></td></tr></table></figure><p>after 5 heartbeats that are unanswered from the client, the </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">n = read(rfd, buffer, BUF_SIZE);</span><br></pre></td></tr></table></figure><p>is unblocked with an <code>n</code> indicating a closed connection. So that the process of breaking a connection, unlike heartbeat itself, notifies the monitor (server in this case) which in turn can trigger the mentioned actions to finalize a broken connection.</p><h1 id="Consideration"><a href="#Consideration" class="headerlink" title="Consideration"></a>Consideration</h1><h2 id="When-heartbeat-should-not-be-used"><a href="#When-heartbeat-should-not-be-used" class="headerlink" title="When heartbeat should not be used"></a>When heartbeat should not be used</h2><p>In mobile network, periodic data transfer will unnecessarily keep the radio active. When this happens in background, the application drains the battery fast and surprises users. So I would go for the extra miles preparing to reconnecting in such case.</p><h2 id="When-heartbeat-could-not-be-used"><a href="#When-heartbeat-could-not-be-used" class="headerlink" title="When heartbeat could not be used"></a>When heartbeat could not be used</h2><p>For a back-end with heavy traffic, the packets generated by business logic alone can be indicators of connectivity. In such case, I would make the server drop a connection after a client has not been sending packets for a long period of time.</p><p>Alternatively, if I need to further reduce false-positive, I could activate the heartbeat mechanism (through <code>setsockopt()</code>) only for a prolonged silence of a client. It is worth noting that when modifying socket option midway, <code>setsockopt()</code> should work on the file descriptor returned by the <code>accept()</code>, i.e., <code>rdf</code> which represents a established connection. (and other settings will be “inherited” from <code>sdf</code>)</p><h2 id="System-wide-setting"><a href="#System-wide-setting" class="headerlink" title="System wide setting"></a>System wide setting</h2><p>Some of the discussed socket options can also be set using <code>procfs</code> and <code>sysctl</code>.</p><p><code>TCP_KEEPIDLE</code> -&gt; <code>/net/ipv4/tcp_keepalive_time</code><br><code>TCP_KEEPCNT</code> -&gt; <code>/net/ipv4/tcp_keepalive_probes</code><br><code>TCP_KEEPINTVL</code> -&gt; <code>/net/ipv4/tcp_keepalive_intvl</code></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://hpbn.co/" target="_blank" rel="noopener">https://hpbn.co/</a><br><a href="https://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/" target="_blank" rel="noopener">https://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/</a><br><a href="https://gist.github.com/physacco/5792698" target="_blank" rel="noopener">https://gist.github.com/physacco/5792698</a><br><a href="https://notes.shichao.io/unp/ch7/#so_keepalive-socket-option" target="_blank" rel="noopener">https://notes.shichao.io/unp/ch7/#so_keepalive-socket-option</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;There are two end purposes for sending heartbeats through a persistent connection. For a back-end application, heartbeats are generally used to detect an absent client, so as to drop a connection and release the associated resources; for a client, on the contrary, it is to prevent connection resources stored within intermediate nodes being released (such as a &lt;em&gt;NAT&lt;/em&gt; router), &lt;code&gt;SO&lt;/code&gt; as to &lt;code&gt;KEEP&lt;/code&gt; the connection &lt;code&gt;ALIVE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This article will examine how to configure the four socket options, &lt;code&gt;SO_KEEPALIVE&lt;/code&gt;, &lt;code&gt;TCP_KEEPIDLE&lt;/code&gt;, &lt;code&gt;TCP_KEEPINTVL&lt;/code&gt; and &lt;code&gt;TCP_KEEPCNT&lt;/code&gt; with &lt;code&gt;setsockopt()&lt;/code&gt; to send heartbeats; and discuss the practice of keep-alive heartbeats in general.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Experiment setting&lt;/strong&gt;:&lt;br&gt;&lt;em&gt;OS: Unbutu 16.04&lt;/em&gt;&lt;br&gt;&lt;em&gt;gcc: 5.4.0&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Network Essentials" scheme="https://holmeshe.me/categories/Network-Essentials/"/>
    
    
      <category term="network" scheme="https://holmeshe.me/tags/network/"/>
    
      <category term="socket" scheme="https://holmeshe.me/tags/socket/"/>
    
      <category term="setsockopt" scheme="https://holmeshe.me/tags/setsockopt/"/>
    
      <category term="SOL_SOCKET" scheme="https://holmeshe.me/tags/SOL-SOCKET/"/>
    
      <category term="SO_KEEPALIVE" scheme="https://holmeshe.me/tags/SO-KEEPALIVE/"/>
    
      <category term="heartbeat" scheme="https://holmeshe.me/tags/heartbeat/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The React Source Code - UI Updating (DOM Tree) IX</title>
    <link href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-IX/"/>
    <id>https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-IX/</id>
    <published>2018-02-18T11:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p>Last time we went through the process from <code>setState()</code> to the updating of a single DOM. We also analyzed the diffing algorithm, which is far from complete as the algorithm is designed for tasks that are much more complex than updating a single DOM node.</p><p>This time we are going to use two examples to examine the diffing algorithm more in depth. More specific, we look at how the algorithm deals with a mutating DOM tree.</p><p>N.b., the examples used in this article are derived from the <a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">official document</a> which also provides a high level description of the diffing algorithm. You might want to read it first if the topic does not seem very familiar.</p><a id="more"></a><p>Example 1., diffing of key-less nodes</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      data : [<span class="string">'one'</span>, <span class="string">'two'</span>],</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">      <span class="number">5000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      data: [<span class="string">'new'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>],</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">this</span>.state.data.map(<span class="function"><span class="keyword">function</span>(<span class="params">val, i</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &lt;li&gt;&#123; val &#125;&lt;/li&gt;;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App;</span></span><br></pre></td></tr></table></figure><p>the babeled version of <code>render()</code>,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">'ul'</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">this</span>.state.data.map(<span class="function"><span class="keyword">function</span> (<span class="params">val, i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> React.createElement(</span><br><span class="line">        <span class="string">'li'</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="string">' '</span>,</span><br><span class="line">        val,</span><br><span class="line">        <span class="string">' '</span></span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="The-old-amp-new-virtual-DOM-tree"><a href="#The-old-amp-new-virtual-DOM-tree" class="headerlink" title="The old &amp; new virtual DOM tree"></a>The old &amp; new virtual DOM tree</h1><p>We know the result virtual DOM tree of the <code>render()</code> method is {<a href="https://holmeshe.me/understanding-react-js-source-code-initial-rendering-IV/">post four</a>} (nested calling of <code>React.createElement()</code>)</p><p><img src="https://cdn-images-1.medium.com/max/800/1*FyN2sTZrx8zxnjrHKF0dxg.png" alt></p><blockquote><p>We ignore the <code>ReactElement</code>’s corresponding controllers (i.e., <code>ReactDOMComponent</code>) for simplicity.</p></blockquote><p>The figure above gives the old virtual DOM tree that is generated by the initial rendering. As in {<a href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/">last post</a>}, a <code>setState()</code> is fired after 5 seconds, which initiates the updating process,</p><p><img src="https://cdn-images-1.medium.com/max/800/1*JGuVhGtKs95KNj2DaOwOJw.png" alt="Figure-I"></p><p>With this data structure in mind, we skip the logic process (mostly, before transaction) that is identical to {<a href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/">last post</a>}, and move directly to the diffing algorithm,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_updateRenderedComponent: <span class="function"><span class="keyword">function</span> (<span class="params">transaction, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevComponentInstance = <span class="keyword">this</span>._renderedComponent; <span class="comment">// scr: -&gt; 1)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 2)</span></span><br><span class="line">  <span class="keyword">var</span> prevRenderedElement = prevComponentInstance._currentElement;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: create a new DOM tree</span></span><br><span class="line">  <span class="keyword">var</span> nextRenderedElement = <span class="keyword">this</span>._renderValidatedComponent();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> debugID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldUpdateReactComponent( <span class="comment">// scr: ----------------------&gt; 3)</span></span><br><span class="line">      prevRenderedElement,</span><br><span class="line">      nextRenderedElement)</span><br><span class="line">  ) &#123;</span><br><span class="line">    ReactReconciler.receiveComponent( <span class="comment">// scr: ------------------&gt; 5)</span></span><br><span class="line">      prevComponentInstance,</span><br><span class="line">      nextRenderedElement,</span><br><span class="line">      transaction,</span><br><span class="line">      <span class="keyword">this</span>._processChildContext(context)</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ---------------------------------------------&gt; 4)</span></span><br><span class="line">  <span class="comment">// scr: code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactCompositeComponent@renderers/shared/stack/reconciler/ReactCompositeComponent.js</span><br></pre></td></tr></table></figure><blockquote><p>The steps 1–5) are also identical to {<a href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/">last post</a>}.</p></blockquote><p>, which starts by creating the new DOM tree (the right one in {Figure-I}) with <code>ReactCompositeComponent._renderValidatedComponent()</code>. {<a href="https://holmeshe.me/understanding-react-js-source-code-initial-rendering-IV/">post four</a>}</p><h2 id="Root-nodes-are-the-identical-so-“diff”-their-direct-children"><a href="#Root-nodes-are-the-identical-so-“diff”-their-direct-children" class="headerlink" title="Root nodes are the identical, so “diff” their direct children"></a>Root nodes are the identical, so “diff” their direct children</h2><p>Since the types of <code>ReactElement[1]</code> are the same (<code>“ul”</code>), the logic goes to 5) as in {<a href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/">last post</a>}.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">receiveComponent: <span class="function"><span class="keyword">function</span> (<span class="params">nextElement, transaction, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevElement = <span class="keyword">this</span>._currentElement;</span><br><span class="line">  <span class="keyword">this</span>._currentElement = nextElement;</span><br><span class="line">  <span class="keyword">this</span>.updateComponent(transaction,</span><br><span class="line">                       prevElement,</span><br><span class="line">                       nextElement,</span><br><span class="line">                       context);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">updateComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  context</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastProps = prevElement.props;</span><br><span class="line">  <span class="keyword">var</span> nextProps = <span class="keyword">this</span>._currentElement.props;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: ------------------------------------------------------&gt; 1)</span></span><br><span class="line">  <span class="keyword">this</span>._updateDOMProperties(lastProps, nextProps, transaction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: ------------------------------------------------------&gt; 2)</span></span><br><span class="line">  <span class="keyword">this</span>._updateDOMChildren(lastProps, nextProps, transaction, context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactDOMComponent@renderers/dom/shared/ReactDOMComponent.js</span><br></pre></td></tr></table></figure><p>in {<a href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/">last post</a>} step 1) updates a DOM node properties; and 2) updates its content.</p><p>But for the the root node (<code>ReactElement[1]</code>) the only purpose of the whole <code>ReactDOMComponent.updateComponent()</code> method call is to recurse and update <code>ReactElement[1]</code>’s direct children because neither the node’s properties and its content are changed.</p><p>I also extend the static call stack from {<a href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/">last post</a>} as a lead:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...                                                            ___</span><br><span class="line">ReactReconciler.receiveComponent()      &lt;----------------|      |</span><br><span class="line">  |-ReactDOMComponent.receiveComponent()                 |      |</span><br><span class="line">    |-this.updateComponent()                             |      |</span><br><span class="line">      |-this._updateDOMProperties()                      |      |</span><br><span class="line">        |-CSSPropertyOperations.setValueForStyles()      |      |</span><br><span class="line">      |-this._updateDOMChildren()                        |      |</span><br><span class="line">        |-this.updateTextContent()                       |   diffing</span><br><span class="line">        |-this._updateDOMChildren() (the focus this time)|      |</span><br><span class="line">          |-this.updateChildren()                        |      |</span><br><span class="line">          |=this._updateChildren()                       |      |</span><br><span class="line">            |-this._reconcilerUpdateChildren()           |      |</span><br><span class="line">              |-this.flattenChildren()                   |      |</span><br><span class="line">              |-ReactChildReconciler.updateChildren() ---|      |</span><br><span class="line">                                                               ---</span><br></pre></td></tr></table></figure><p>As mentioned before, the recursing starts from <code>ReactDOMComponent._updateDOMChildren()</code>. In the following sections, we will follow the hierarchy, one function a time, and go for the bottom of the stack.</p><h1 id="ReactDOMComponent-updateDOMChildren-—-Start-recursing-direct-children"><a href="#ReactDOMComponent-updateDOMChildren-—-Start-recursing-direct-children" class="headerlink" title="ReactDOMComponent._updateDOMChildren() — Start recursing direct children"></a><code>ReactDOMComponent._updateDOMChildren()</code> — Start recursing direct children</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_updateDOMChildren: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  lastProps, nextProps, transaction, context</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// scr: code for content updating</span></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">var</span> nextChildren = nextContent != <span class="literal">null</span> ? <span class="literal">null</span> : nextProps.children;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lastChildren != <span class="literal">null</span> &amp;&amp; nextChildren == <span class="literal">null</span>) &#123; <span class="comment">// scr: --&gt; 1)</span></span><br><span class="line">    <span class="keyword">this</span>.updateChildren(<span class="literal">null</span>, transaction, context);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastHasContentOrHtml &amp;&amp; !nextHasContentOrHtml) &#123;</span><br><span class="line">    <span class="comment">// scr: code for content updating</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextContent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastContent !== nextContent) &#123;</span><br><span class="line">      <span class="comment">// scr: code for content updating</span></span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHtml != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// scr: code for content updating</span></span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextChildren != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line">      <span class="comment">// scr: --------------------------------------------------&gt; 2)</span></span><br><span class="line">      <span class="keyword">this</span>.updateChildren(nextChildren, transaction, context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactDOMComponent@renderers/dom/shared/ReactDOMComponent.js</span><br></pre></td></tr></table></figure><blockquote><p>I fold up the content updating related code so we can focus on DOM children recursing</p></blockquote><p>1) remove the children only when necessary (<code>lastChildren != null &amp;&amp; nextChildren == null</code>);</p><p>2) start the recursing.</p><h1 id="ReactMultiChild-updateChildren-I-—-The-actual-work-horse"><a href="#ReactMultiChild-updateChildren-I-—-The-actual-work-horse" class="headerlink" title="ReactMultiChild.updateChildren() I — The actual work horse"></a><code>ReactMultiChild.updateChildren() I</code> — The actual work horse</h1><p>After the methods that are either alias or those with very little (preprocessing) operations, we come to the work horse that I) recurses virtual DOM children, compares the new/old versions of them and modifies <code>ReactDOMComponent</code>’s accordingly (we name them virtual DOM operations for simplicity); and II) commits the operations to real DOMs.</p><blockquote><p>the role of this <code>ReactMultiChild.updateChildren()</code> is similar to that of <code>mountComponentIntoNode()</code> in initial rendering {<a href="https://holmeshe.me/understanding-react-js-source-code-initial-rendering-II/">post two</a>}</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">updateChildren: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextNestedChildrenElements,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  context</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Hook used by React ART</span></span><br><span class="line">  <span class="keyword">this</span>._updateChildren(nextNestedChildrenElements, transaction, context);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_updateChildren: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nextNestedChildrenElements,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  context</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevChildren = <span class="keyword">this</span>._renderedChildren;</span><br><span class="line">  <span class="keyword">var</span> removedNodes = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> mountImages = [];</span><br><span class="line">  <span class="keyword">var</span> nextChildren = <span class="keyword">this</span>._reconcilerUpdateChildren( <span class="comment">// scr: ---&gt; I)</span></span><br><span class="line">                       prevChildren, <span class="comment">// scr: ------------------&gt;  i)</span></span><br><span class="line">                       nextNestedChildrenElements, <span class="comment">// scr: ----&gt; ii)</span></span><br><span class="line">                       mountImages,</span><br><span class="line">                       removedNodes,</span><br><span class="line">                       transaction,</span><br><span class="line">                       context</span><br><span class="line">                     );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextChildren &amp;&amp; !prevChildren) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: -----------------------------------------------------&gt; II)</span></span><br><span class="line">  <span class="keyword">var</span> updates = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="comment">// `nextIndex` will increment for each child in `nextChildren`, but</span></span><br><span class="line">  <span class="comment">// `lastIndex` will be the last index visited in `prevChildren`.</span></span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `nextMountIndex` will increment for each newly mounted child.</span></span><br><span class="line">  <span class="keyword">var</span> nextMountIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> lastPlacedNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</span><br><span class="line">    <span class="keyword">var</span> nextChild = nextChildren[name];</span><br><span class="line">    <span class="keyword">if</span> (prevChild === nextChild) &#123;</span><br><span class="line">      updates = enqueue(updates, <span class="keyword">this</span>.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));</span><br><span class="line">      lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line">      prevChild._mountIndex = nextIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prevChild) &#123;</span><br><span class="line">        <span class="comment">// Update `lastIndex` before `_mountIndex` gets unset by unmounting.</span></span><br><span class="line">        lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line">        <span class="comment">// The `removedNodes` loop below will actually remove the child.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The child must be instantiated before it's mounted.</span></span><br><span class="line">      updates = enqueue(updates, <span class="keyword">this</span>._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));</span><br><span class="line">      nextMountIndex++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextIndex++;</span><br><span class="line">    lastPlacedNode = ReactReconciler.getHostNode(nextChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove children that are no longer present.</span></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> removedNodes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (removedNodes.hasOwnProperty(name)) &#123;</span><br><span class="line">      updates = enqueue(updates, <span class="keyword">this</span>._unmountChild(prevChildren[name], removedNodes[name]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (updates) &#123;</span><br><span class="line">    processQueue(<span class="keyword">this</span>, updates);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._renderedChildren = nextChildren;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ReactMultiChild@renderers/shared/stack/reconciler/ReactMultiChild.js</span><br></pre></td></tr></table></figure><p>We firstly look at the virtual DOM operations, I). Note that the two input parameters of the responsible method <code>ReactDOMComponent._reconcilerUpdateChildren()</code> are i) <code>prevChildren</code>, i.e., <code>ReactDOMComponent._renderedChildren</code> which is set to an object of its sub-<code>ReactDOMComponents</code> in initial rendering {<a href="https://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/">post five</a>}; and ii) <code>nextNestedChildrenElements</code>, i.e., <code>nextProps.children</code> passed from <code>ReactDOMComponent._updateDOMChildren()</code>.</p><h1 id="ReactDOMComponent-reconcilerUpdateChildren-—-Virtual-DOM-operations"><a href="#ReactDOMComponent-reconcilerUpdateChildren-—-Virtual-DOM-operations" class="headerlink" title="ReactDOMComponent._reconcilerUpdateChildren() — Virtual DOM operations"></a><code>ReactDOMComponent._reconcilerUpdateChildren()</code> — Virtual DOM operations</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_reconcilerUpdateChildren: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  prevChildren,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextNestedChildrenElements,</span></span></span><br><span class="line"><span class="function"><span class="params">  mountImages,</span></span></span><br><span class="line"><span class="function"><span class="params">  removedNodes,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  context</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextChildren;</span><br><span class="line">  <span class="keyword">var</span> selfDebugID = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  nextChildren = flattenChildren(      <span class="comment">// scr: -----------------&gt; 1)</span></span><br><span class="line">                   nextNestedChildrenElements,</span><br><span class="line">                   selfDebugID);</span><br><span class="line"></span><br><span class="line">  ReactChildReconciler.updateChildren( <span class="comment">// scr: -----------------&gt; 2)</span></span><br><span class="line">                   prevChildren,</span><br><span class="line">                   nextChildren,</span><br><span class="line">                   mountImages,</span><br><span class="line">                   removedNodes,</span><br><span class="line">                   transaction,</span><br><span class="line">                   <span class="keyword">this</span>,</span><br><span class="line">                   <span class="keyword">this</span>._hostContainerInfo,</span><br><span class="line">                   context, selfDebugID);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nextChildren;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactMultiChild@renderers/shared/stack/reconciler/ReactMultiChild.js</span><br></pre></td></tr></table></figure><p>Before 2) the virtual DOM can be traversed and compared, this method 1) calls</p><h2 id="flattenChildren-—-converts-ReactElement-array-into-an-object-map"><a href="#flattenChildren-—-converts-ReactElement-array-into-an-object-map" class="headerlink" title="flattenChildren() — converts ReactElement array into an object (map)"></a><code>flattenChildren()</code> — converts <code>ReactElement</code> array into an object (map)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenChildren</span>(<span class="params">children, selfDebugID</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    traverseAllChildren(children, flattenSingleChildIntoContext, result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flattenChildren@shared/utils/flattenChildren.js</span><br></pre></td></tr></table></figure><p>Here we need to pay attention to the callback passed to <code>traverseAllChildren()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenSingleChildIntoContext</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  traverseContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  child,</span></span></span><br><span class="line"><span class="function"><span class="params">  name,</span></span></span><br><span class="line"><span class="function"><span class="params">  selfDebugID</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// We found a component instance.</span></span><br><span class="line">  <span class="keyword">if</span> (traverseContext &amp;&amp; <span class="keyword">typeof</span> traverseContext === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = traverseContext;</span><br><span class="line">    <span class="keyword">var</span> keyUnique = result[name] === <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (keyUnique &amp;&amp; child != <span class="literal">null</span>) &#123;</span><br><span class="line">      result[name] = child;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flattenSingleChildIntoContext@shared/utils/flattenChildren.js</span><br></pre></td></tr></table></figure><p>, which set individual <code>ReactElement</code> with its associated key (<code>name</code>) in an object (map). Next we look at the <code>traverseAllChildren()</code> method body, to see in particular how the keys are generated.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> SEPARATOR = <span class="string">'.'</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildren</span>(<span class="params">children, callback, traverseContext</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> traverseAllChildrenImpl(children, <span class="string">''</span>, callback, traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">traverseAllChildren@shared/utils/traverseAllChildren.js</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildrenImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,</span></span></span><br><span class="line"><span class="function"><span class="params">  nameSoFar, <span class="regexp">//</span> scr: -------- <span class="string">''</span></span></span></span><br><span class="line"><span class="function"><span class="params">  callback,</span></span></span><br><span class="line"><span class="function"><span class="params">  traverseContext</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> children;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'undefined'</span> || type === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="comment">// All of the above are perceived as null.</span></span><br><span class="line">    children = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (children === <span class="literal">null</span> || type === <span class="string">'string'</span> || type === <span class="string">'number'</span> ||</span><br><span class="line">type === <span class="string">'object'</span> &amp;&amp; children.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE) &#123;</span><br><span class="line">    callback(traverseContext, children,</span><br><span class="line">    <span class="comment">// If it's the only child, treat the name as if it was wrapped in an array</span></span><br><span class="line">    <span class="comment">// so that it's consistent if the number of children grows.</span></span><br><span class="line">    nameSoFar === <span class="string">''</span> ? SEPARATOR + getComponentKey(children, <span class="number">0</span>) : nameSoFar);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> child;</span><br><span class="line">  <span class="keyword">var</span> nextName;</span><br><span class="line">  <span class="keyword">var</span> subtreeCount = <span class="number">0</span>; <span class="comment">// Count of children found in the current subtree.</span></span><br><span class="line">  <span class="keyword">var</span> nextNamePrefix = nameSoFar === <span class="string">''</span> ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, i);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// scr: code that is not applicable</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> subtreeCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">traverseAllChildrenImpl@shared/utils/traverseAllChildren.js</span><br></pre></td></tr></table></figure><p>We have described this method in {<a href="https://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/">post five</a>},</p><blockquote><p>when it is called the first time (and the type of <code>children</code> parameter is <code>array</code>), it calls itself for every <code>ReactElement</code> within the array; when it is called successively (<code>children</code> is <code>ReactElement</code>), invokes the aforementioned callback that…</p></blockquote><p>“set individual <code>ReactElement</code> with its associated key (<code>name</code>) in an object” as mentioned soon before.</p><p>The keys are generated with <code>getComponentKey()</code>,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponentKey</span>(<span class="params">component, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (component &amp;&amp; <span class="keyword">typeof</span> component === <span class="string">'object'</span> &amp;&amp; component.key != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Explicit key</span></span><br><span class="line">    <span class="keyword">return</span> KeyEscapeUtils.escape(component.key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Implicit key determined by the index in the set</span></span><br><span class="line">  <span class="keyword">return</span> index.toString(<span class="number">36</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getComponentKey@shared/utils/traverseAllChildren.js</span><br></pre></td></tr></table></figure><p>which basically uses the index of the array as the key in the object (<code>index.toString(36)</code>), in the case that the key is not explicitly set in “key-less nodes”.</p><p>The static (sub) call stack of <code>flattenChildren()</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">flattenChildren()</span><br><span class="line">  |-traverseAllChildren()</span><br><span class="line">    |-traverseAllChildrenImpl()</span><br><span class="line">      |↻traverseAllChildrenImpl() // for direct each child</span><br><span class="line">        |-flattenSingleChildIntoContext()</span><br></pre></td></tr></table></figure><p>now we have an key-value object <code>nextChildren</code> to be “diffed” with <code>prevChildren</code>.</p><h2 id="ReactChildReconciler-updateChildren-—-manipulate-the-virtual-DOM-tree"><a href="#ReactChildReconciler-updateChildren-—-manipulate-the-virtual-DOM-tree" class="headerlink" title="ReactChildReconciler.updateChildren() — manipulate the virtual DOM tree"></a><code>ReactChildReconciler.updateChildren()</code> — manipulate the virtual DOM tree</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">updateChildren: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  prevChildren,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren,</span></span></span><br><span class="line"><span class="function"><span class="params">  mountImages,</span></span></span><br><span class="line"><span class="function"><span class="params">  removedNodes,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  hostParent,</span></span></span><br><span class="line"><span class="function"><span class="params">  hostContainerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">  context,</span></span></span><br><span class="line"><span class="function"><span class="params">  selfDebugID, <span class="regexp">//</span> <span class="number">0</span> in production and for roots</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!nextChildren &amp;&amp; !prevChildren) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="keyword">var</span> prevChild;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevChild = prevChildren &amp;&amp; prevChildren[name];</span><br><span class="line">    <span class="keyword">var</span> prevElement = prevChild &amp;&amp; prevChild._currentElement;</span><br><span class="line">    <span class="keyword">var</span> nextElement = nextChildren[name];</span><br><span class="line">    <span class="keyword">if</span> ( <span class="comment">// scr: -----------------------------------------------&gt; 1)</span></span><br><span class="line">      prevChild != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      shouldUpdateReactComponent(prevElement, nextElement)</span><br><span class="line">    ) &#123;</span><br><span class="line">      ReactReconciler.receiveComponent(</span><br><span class="line">        prevChild,</span><br><span class="line">        nextElement,</span><br><span class="line">        transaction,</span><br><span class="line">        context,</span><br><span class="line">      );</span><br><span class="line">      nextChildren[name] = prevChild; <span class="comment">// scr: --------------&gt; end 1)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (prevChild) &#123; <span class="comment">// scr: ---------------------------------&gt; 2)</span></span><br><span class="line">        removedNodes[name] = ReactReconciler.getHostNode(prevChild);</span><br><span class="line">        ReactReconciler.unmountComponent(prevChild, <span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The child must be instantiated before it's mounted.</span></span><br><span class="line">      <span class="keyword">var</span> nextChildInstance = instantiateReactComponent(nextElement, <span class="literal">true</span>);</span><br><span class="line">      nextChildren[name] = nextChildInstance;</span><br><span class="line">      <span class="comment">// Creating mount image now ensures refs are resolved in right order</span></span><br><span class="line">      <span class="comment">// (see https://github.com/facebook/react/pull/7101 for explanation).</span></span><br><span class="line">      <span class="keyword">var</span> nextChildMountImage = ReactReconciler.mountComponent(</span><br><span class="line">        nextChildInstance,</span><br><span class="line">        transaction,</span><br><span class="line">        hostParent,</span><br><span class="line">        hostContainerInfo,</span><br><span class="line">        context,</span><br><span class="line">        selfDebugID,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      mountImages.push(nextChildMountImage);</span><br><span class="line">    &#125; <span class="comment">// scr: ----------------------------------------------&gt; end 2)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 3)</span></span><br><span class="line">  <span class="comment">// Unmount children that are no longer present.</span></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> prevChildren) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      prevChildren.hasOwnProperty(name) &amp;&amp;</span><br><span class="line">      !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))</span><br><span class="line">    ) &#123;</span><br><span class="line">      prevChild = prevChildren[name];</span><br><span class="line">      removedNodes[name] = ReactReconciler.getHostNode(prevChild);</span><br><span class="line">      ReactReconciler.unmountComponent(prevChild, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// scr: ------------------------------------------------&gt; end 3)</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>updating is nothing more than modifying, adding, and deleting</p></blockquote><p>This method traverse the <code>nextChildren</code>, and</p><p>1) recurse back to <code>ReactReconciler.receiveComponent()</code> to modify the content of the associated DOM nodes as in {<a href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/">last post</a>} if the types of the corresponding “pre” and “next” nodes are the same (judged by <code>shouldUpdateReactComponent()</code> {<a href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/">last post</a>}), the logic branch of which applies to</p><p><img src="https://cdn-images-1.medium.com/max/800/1*dVz3SAhb23HlcEMu95pUKQ.png" alt></p><p>and</p><p><img src="https://cdn-images-1.medium.com/max/800/1*B6NLRBhH-Ir4-IuREzLMxw.png" alt></p><p>as the comparison is based on the counterparts’ index (that is also key);</p><p>2) re-mount the virtual DOM if types of “pre” and “next” nodes are different, or the corresponding “pre” node simply does not exist;</p><blockquote><p>As in {<a href="https://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/">post five</a>}, the virtual DOM’s corresponding <code>li</code> node has been created in the mounting process;</p></blockquote><p><img src="https://cdn-images-1.medium.com/max/800/1*dt42ILXAIG5YXiAWyscLDQ.png" alt></p><p>3) un-mount “pre” virtual DOM(s) if they do not exist in the “next” ones.</p><p>The content updating operations are encapsulated in the recursion of <code>ReactReconciler.receiveComponent()</code> {<a href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/">last post</a>}, whilst the operations on real DOM tree are conducted when the logic processes back in <code>ReactMultiChild.updateChildren()</code>.</p><h1 id="ReactMultiChild-updateChildren-II-—-matipulate-real-DOMs"><a href="#ReactMultiChild-updateChildren-II-—-matipulate-real-DOMs" class="headerlink" title="ReactMultiChild.updateChildren() II — matipulate real DOMs"></a><code>ReactMultiChild.updateChildren() II</code> — matipulate real DOMs</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">var</span> updates = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> name;</span><br><span class="line">  <span class="comment">// `nextIndex` will increment for each child in `nextChildren`, but</span></span><br><span class="line">  <span class="comment">// `lastIndex` will be the last index visited in `prevChildren`.</span></span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> lastIndex = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// `nextMountIndex` will increment for each newly mounted child.</span></span><br><span class="line">  <span class="keyword">var</span> nextMountIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> lastPlacedNode = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> nextChildren) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scr: --------------------------------------------------&gt; III)</span></span><br><span class="line">    <span class="keyword">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</span><br><span class="line">    <span class="keyword">var</span> nextChild = nextChildren[name];</span><br><span class="line">    <span class="keyword">if</span> (prevChild === nextChild) &#123;</span><br><span class="line">      updates = enqueue(</span><br><span class="line">                  updates,</span><br><span class="line">                  <span class="keyword">this</span>.moveChild(</span><br><span class="line">                    prevChild,</span><br><span class="line">                    lastPlacedNode,</span><br><span class="line">                    nextIndex,</span><br><span class="line">                    lastIndex</span><br><span class="line">                  )</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">      lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line">      prevChild._mountIndex = nextIndex; <span class="comment">// scr: ---------&gt; end III)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ------------------------------------------&gt; IV)</span></span><br><span class="line">      <span class="keyword">if</span> (prevChild) &#123;</span><br><span class="line">        <span class="comment">// Update `lastIndex` before `_mountIndex` gets unset by unmounting.</span></span><br><span class="line">        lastIndex = <span class="built_in">Math</span>.max(prevChild._mountIndex, lastIndex);</span><br><span class="line">        <span class="comment">// The `removedNodes` loop below will actually remove the child.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The child must be instantiated before it's mounted.</span></span><br><span class="line">      updates = enqueue(</span><br><span class="line">                  updates,</span><br><span class="line">                  <span class="keyword">this</span>._mountChildAtIndex(</span><br><span class="line">                    nextChild,</span><br><span class="line">                    mountImages[nextMountIndex],</span><br><span class="line">                    lastPlacedNode,</span><br><span class="line">                    nextIndex,</span><br><span class="line">                    transaction,</span><br><span class="line">                    context</span><br><span class="line">                  )</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">      nextMountIndex++;</span><br><span class="line">    &#125; <span class="comment">// scr: ---------------------------------------------&gt; end IV)</span></span><br><span class="line"></span><br><span class="line">    nextIndex++;</span><br><span class="line">    lastPlacedNode = ReactReconciler.getHostNode(nextChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove children that are no longer present.</span></span><br><span class="line">  <span class="keyword">for</span> (name <span class="keyword">in</span> removedNodes) &#123; <span class="comment">// scr: -------------------------&gt; V)</span></span><br><span class="line">    <span class="keyword">if</span> (removedNodes.hasOwnProperty(name)) &#123;</span><br><span class="line">      updates = enqueue(</span><br><span class="line">                  updates,</span><br><span class="line">                  <span class="keyword">this</span>._unmountChild(</span><br><span class="line">                    prevChildren[name],</span><br><span class="line">                    removedNodes[name]</span><br><span class="line">                  )</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// scr: ------------------------------------------------&gt; end V)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (updates) &#123;</span><br><span class="line">    processQueue(<span class="keyword">this</span>, updates); <span class="comment">// scr: ----------------------&gt; VI)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._renderedChildren = nextChildren;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ReactMultiChild@renderers/shared/stack/reconciler/ReactMultiChild.js</span><br></pre></td></tr></table></figure><p>This logic block iterates the <code>nextChildren</code>, and when necessary, it</p><p>III) mark that a node’s position has changed;</p><p>IV) mark a newly added node;</p><p>V) mark a removed node;</p><p>VI) commit the changes to the DOM tree {<a href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/">last post</a>}</p><p>The branch applies here is IV) that adds the <code>ReactElement[4]</code> associated node to the DOM tree.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">_mountChildAtIndex: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  child,</span></span></span><br><span class="line"><span class="function"><span class="params">  mountImage,</span></span></span><br><span class="line"><span class="function"><span class="params">  afterNode,</span></span></span><br><span class="line"><span class="function"><span class="params">  index,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  context</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  child._mountIndex = index;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.createChild(child, afterNode, mountImage);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">createChild: <span class="function"><span class="keyword">function</span> (<span class="params">child, afterNode, mountImage</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> makeInsertMarkup(mountImage, afterNode, child._mountIndex);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeInsertMarkup</span>(<span class="params">markup, afterNode, toIndex</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> Null values reduce hidden classes.</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'INSERT_MARKUP'</span>,</span><br><span class="line">    content: markup,</span><br><span class="line">    fromIndex: <span class="literal">null</span>,</span><br><span class="line">    fromNode: <span class="literal">null</span>,</span><br><span class="line">    toIndex: toIndex,</span><br><span class="line">    afterNode: afterNode</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactMultiChild@renderers/shared/stack/reconciler/ReactMultiChild.js</span><br></pre></td></tr></table></figure><p>And in VI)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">processUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">parentNode, updates</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; updates.length; k++) &#123;</span><br><span class="line">    <span class="keyword">var</span> update = updates[k];</span><br><span class="line">    <span class="keyword">switch</span> (update.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'INSERT_MARKUP'</span>:</span><br><span class="line">          insertLazyTreeChildAt(</span><br><span class="line">            parentNode,</span><br><span class="line">            update.content,</span><br><span class="line">            getNodeAfter(parentNode, update.afterNode),</span><br><span class="line">          );</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// scr: code that is not applicable</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertLazyTreeChildAt</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  parentNode,</span></span></span><br><span class="line"><span class="function"><span class="params">  childTree,</span></span></span><br><span class="line"><span class="function"><span class="params">  referenceNode</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  DOMLazyTree.insertTreeBefore(</span><br><span class="line">    parentNode,</span><br><span class="line">    childTree,</span><br><span class="line">    referenceNode</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOMChildrenOperations@renderers/dom/client/utils/DOMChildrenOperations.js</span><br></pre></td></tr></table></figure><p>So the last card in this stack is <code>DOMLazyTree.insertTreeBefore()</code>. We already know from {<a href="https://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a>} that this method calls the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore" target="_blank" rel="noopener">HTML DOM API</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.insertBefore(tree.node, referenceNode);</span><br></pre></td></tr></table></figure><p>So what happens when</p><h1 id="Diffing-nodes-with-keys"><a href="#Diffing-nodes-with-keys" class="headerlink" title="Diffing nodes with keys"></a>Diffing nodes with keys</h1><p>Example 2.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>.state.data.map(<span class="function"><span class="keyword">function</span>(<span class="params">val, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;li key=&#123;val&#125;&gt;&#123; val &#125;&lt;/li&gt;;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">...</span></span><br></pre></td></tr></table></figure><p>The process logic are the same as in key-less nodes before <code>ReactDOMComponent.flattenChildren()</code>, in which the designated keys instead of the array index will be used to establish the key-value object,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponentKey</span>(<span class="params">component, index</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (component &amp;&amp; <span class="keyword">typeof</span> component === <span class="string">'object'</span> &amp;&amp; </span><br><span class="line">      component.key != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Explicit key</span></span><br><span class="line">    <span class="keyword">return</span> KeyEscapeUtils.escape(component.key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// code that is not applicable</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getComponentKey@shared/utils/traverseAllChildren.js</span><br></pre></td></tr></table></figure><p>So in <code>ReactChildReconciler.updateChildren()</code> the comparison of the two virtual DOM trees can be better aligned,</p><p><img src="https://cdn-images-1.medium.com/max/800/1*VUHh02aFv638HBhvoSCRRw.png" alt></p><p>and the recursive <code>ReactReconciler.receiveComponent()</code> does not incur any DOM operations by comparing nodes (key: <code>one</code> and <code>two</code>) with same content , and only the necessary DOM operation, i.e.,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.insertBefore(tree.node, referenceNode);</span><br></pre></td></tr></table></figure><p>is conducted for the node (key: <code>new</code>) in <code>ReactMultiChild.updateChildren()</code>.</p><p>As a result, keys can spare some unnecessary DOM operations for mutating a DOM tree .</p><h1 id="Take-home"><a href="#Take-home" class="headerlink" title="Take home"></a>Take home</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      mutate: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">      <span class="number">5000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      mutate: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123; <span class="keyword">this</span>.state.mutate &amp;&amp;</span><br><span class="line">        &lt;li&gt;New&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        &lt;li&gt;One&lt;/</span>li&gt;</span><br><span class="line">        &lt;li&gt;Two&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/u</span>l&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>The above code also changes the DOM tree structure. Can you answer why the keys are not required here?</p><p>—End note—</p><p>Reading source code with a purpose is like searching an array, in which, theoretically, it is <code>O(n) - O(log n)</code> faster when the array has already been sorted. This series aims to sort out the React code base for you, so you will be able to enjoy the <code>O(log n)</code> whenever having a purpose(s).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Last time we went through the process from &lt;code&gt;setState()&lt;/code&gt; to the updating of a single DOM. We also analyzed the diffing algorithm, which is far from complete as the algorithm is designed for tasks that are much more complex than updating a single DOM node.&lt;/p&gt;
&lt;p&gt;This time we are going to use two examples to examine the diffing algorithm more in depth. More specific, we look at how the algorithm deals with a mutating DOM tree.&lt;/p&gt;
&lt;p&gt;N.b., the examples used in this article are derived from the &lt;a href=&quot;https://reactjs.org/docs/reconciliation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;official document&lt;/a&gt; which also provides a high level description of the diffing algorithm. You might want to read it first if the topic does not seem very familiar.&lt;/p&gt;
    
    </summary>
    
      <category term="Understanding The React Source Code" scheme="https://holmeshe.me/categories/Understanding-The-React-Source-Code/"/>
    
    
      <category term="JavaScript" scheme="https://holmeshe.me/tags/JavaScript/"/>
    
      <category term="react.js" scheme="https://holmeshe.me/tags/react-js/"/>
    
      <category term="setstate" scheme="https://holmeshe.me/tags/setstate/"/>
    
      <category term="virtual dom" scheme="https://holmeshe.me/tags/virtual-dom/"/>
    
      <category term="diffing" scheme="https://holmeshe.me/tags/diffing/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The React Source Code - UI Updating (Individual DOM) VIII</title>
    <link href="https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/"/>
    <id>https://holmeshe.me/understanding-react-js-source-code-virtual-dom-diff-VIII/</id>
    <published>2018-02-05T11:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p>UI updating, in its essential, is data change. React offers a straightforward and intuitive way to program front-end Apps as most moving parts are converged in the form of states, and most UI tasks can be done with a single</p><p><img src="https://cdn-images-1.medium.com/max/800/1*EBJi5HtjKTjMrczt0fibcQ.png" alt></p><p>…, I mean, a single method, <code>setState()</code>. In this article, we are going unfold the <code>setState()</code> implementation, and peek inside the diffing algorithm by mutating an individual DOM element.</p><a id="more"></a><blockquote><p>Before we get started, I would like to respond to one common feedback from readers: “why 15.x, why not fiber?”<br>Well, simply put, because <a href="https://code.facebook.com/posts/1716776591680069/react-16-a-look-inside-an-api-compatible-rewrite-of-our-frontend-ui-library/" target="_blank" rel="noopener">synchronous</a> <a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html" target="_blank" rel="noopener">rendering</a> <a href="https://makersden.io/blog/look-inside-fiber/" target="_blank" rel="noopener">is still alive</a>. Thus, the code base (a.k.a., stack reconciler) specifically designed for synchronous rendering, in my opinion, offers an easier albeit solid ground to establish an initial understanding.</p></blockquote><p>Firstly Let’s extend an example from {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-IV/">post four</a>}</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      desc: <span class="string">'start'</span>,</span><br><span class="line">      color: <span class="string">'blue'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.timer = setTimeout(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">      <span class="number">5000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      desc: <span class="string">'end'</span>,</span><br><span class="line">      color: <span class="string">'green'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">"App-header"</span>&gt;</span><br><span class="line">          &lt;img src=<span class="string">"main.jpg"</span> className=<span class="string">"App-logo"</span> alt=<span class="string">"logo"</span> /&gt;</span><br><span class="line">          &lt;h1&gt; <span class="string">"Welcom to React"</span> &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;p className=<span class="string">"App-intro"</span> style=&#123;&#123;<span class="attr">color</span>: <span class="keyword">this</span>.state.color&#125;&#125;&gt;</span><br><span class="line">          &#123; <span class="keyword">this</span>.state.desc &#125;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>Compared to the <code>App</code> component used in {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-IV/">post four</a>}, the new version adds <code>style</code> prop to <code>&lt;p&gt;</code> node, and <code>setState()</code>s <code>desc</code> to <code>&#39;end&#39;</code> and <code>color</code> to <code>&#39;green&#39;</code> 5 seconds after the component is constructed.</p><p>The instantiating of <code>App</code> has been discussed in {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-IV/">post four</a>}.</p><blockquote><p>ctl-f “setState”<br>In the same article, I also mentioned <code>ReactInstanceMap</code>, a back link (from the external <code>ReactComponent</code> instance) to the internal <code>ReactCompositeComponent[ins]</code>, which will be used very soon.</p></blockquote><p>Here I paste the data structure as a reminder.</p><p><img src="https://cdn-images-1.medium.com/max/800/1*oj4kmSko5Qa5uPVQiTl1tw.png" alt="Figure-I"></p><h1 id="Before-transactions"><a href="#Before-transactions" class="headerlink" title="Before transactions"></a>Before transactions</h1><p>We start from the <code>setState()</code> method body:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  partialState,</span></span></span><br><span class="line"><span class="function"><span class="params">  callback</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// scr: ---&gt; sanity check</span></span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState);</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">  <span class="comment">// scr: ---&gt; no callbak</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactComponent@isomorphic/modern/<span class="class"><span class="keyword">class</span>/<span class="title">ReactBaseClasses</span>.<span class="title">js</span></span></span><br></pre></td></tr></table></figure><p>Yes, <code>setState()</code> is inherited from <code>ReactComponent</code>.</p><p>But wait, what is <code>this.updater</code>? isn’t it set to <code>ReactNoopUpdateQueue</code> in the constructor, and is a <code>no-op</code>? In fact, I believe with the understanding of <code>Transaction</code>(s) and instance pooling {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-VII/">last post</a>}, if you trace back from the aforementioned <code>ReactComponent</code> instantiating {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-IV/">post four</a>}, you will be able to find out the origin of <code>this.updater</code> very easily.</p><blockquote><p>I will leave this question open so we can move faster to the core part —virtual DOM and diffing algorithm</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">enqueueSetState: <span class="function"><span class="keyword">function</span> (<span class="params">publicInstance, partialState</span>) </span>&#123;</span><br><span class="line"><span class="comment">// scr: DEV code</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 1)</span></span><br><span class="line">  <span class="keyword">var</span> internalInstance = getInternalInstanceReadyForUpdate(publicInstance, <span class="string">'setState'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!internalInstance) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 2)</span></span><br><span class="line">  <span class="keyword">var</span> queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);</span><br><span class="line">  queue.push(partialState);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 3)</span></span><br><span class="line">  enqueueUpdate(internalInstance);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactUpdateQueue@renderers/shared/stack/reconciler/ReactUpdateQueue.js</span><br></pre></td></tr></table></figure><p>1) this is the method that obtains the internal <code>ReactCompositeComponent[ins]</code> from the back link <code>ReactInstanceMap</code>;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInternalInstanceReadyForUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  publicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  callerName</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> internalInstance = ReactInstanceMap.get(publicInstance);</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: DEV code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> internalInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getInternalInstanceReadyForUpdate@renderers/shared/stack/reconciler/ReactUpdateQueue.js</span><br></pre></td></tr></table></figure><p>2) attach an array (<code>_pendingStateQueue</code>) to <code>ReactCompositeComponent[ins]</code>, and push the changed state <code>{desc:&#39;end&#39;,color:&#39;green&#39;}</code> into it;</p><p>3) start the <code>Transaction</code>(s) {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-VI/">post six</a>, <a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-VII/">seven</a>},</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">internalInstance</span>) </span>&#123;</span><br><span class="line">  ReactUpdates.enqueueUpdate(internalInstance);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">enqueueUpdate@renderers/shared/stack/reconciler/ReactUpdateQueue.js</span><br></pre></td></tr></table></figure><p>The call stack so far:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-ReactComponent.setState()</span><br><span class="line">  |-ReactUpdateQueue.enqueueSetState()</span><br><span class="line">    |-getInternalInstanceReadyForUpdate()</span><br><span class="line">    |-enqueueUpdate()</span><br><span class="line">      |-ReactUpdates.enqueueUpdate()</span><br><span class="line">        |~~~</span><br></pre></td></tr></table></figure><p>Here I also paste the transaction related call graph as a reminder.</p><p><img src="https://cdn-images-1.medium.com/max/1000/1*CbQxYgpncrKJHqKs_oIE0w.png" alt="Figure-II"></p><h1 id="In-transactions"><a href="#In-transactions" class="headerlink" title="In transactions"></a>In transactions</h1><p>The first stop after the <code>Transaction</code>(s) are fully initialized is</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runBatchedUpdates</span>(<span class="params">transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = transaction.dirtyComponentsLength;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: -----------------------------------&gt; sanity check</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  dirtyComponents.sort(mountOrderComparator);</span><br><span class="line"></span><br><span class="line">  updateBatchNumber++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> component = dirtyComponents[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> callbacks = component._pendingCallbacks;</span><br><span class="line">    component._pendingCallbacks = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scr: ------------------------------&gt; logging</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scr: ------------------------------&gt; logging</span></span><br><span class="line">    <span class="keyword">if</span> (callbacks) &#123; <span class="comment">// scr: -------------&gt; no callbacks</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactUpdates@renderers/shared/stack/reconciler/ReactUpdates.js</span><br></pre></td></tr></table></figure><p>This time we have one <code>dirtyComponents</code>, <code>ReactCompositeComponent[ins]</code> which is the first parameter of <code>ReactReconciler.performUpdateIfNecessary()</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">performUpdateIfNecessary: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  internalInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  updateBatchNumber</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    internalInstance.performUpdateIfNecessary(transaction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactReconciler@renderers/shared/stack/reconciler/ReactUpdates.js</span><br></pre></td></tr></table></figure><p>Like most of the other methods in <code>ReactReconciler</code> class, <code>ReactReconciler.performUpdateIfNecessary()</code> will call the component’s same method, <code>ReactCompositeComponent.performUpdateIfNecessary()</code></p><blockquote><p>it’s like a polymorphism in a more explicit way</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">performUpdateIfNecessary: <span class="function"><span class="keyword">function</span> (<span class="params">transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>._pendingElement != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// scr: -----------&gt; condition not applied</span></span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">this</span>._pendingStateQueue !== <span class="literal">null</span> || </span><br><span class="line">    <span class="keyword">this</span>._pendingForceUpdate</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateComponent(transaction, <span class="keyword">this</span>._currentElement, <span class="keyword">this</span>._currentElement, <span class="keyword">this</span>._context, <span class="keyword">this</span>._context);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// scr: -----------&gt; condition not applied</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactCompositeComponent@renderers/shared/stack/reconciler/ReactCompositeComponent.js</span><br></pre></td></tr></table></figure><p>It in turn calls <code>ReactCompositeComponent[ins].updateComponent()</code>. Note that <code>_pendingStateQueue</code> is set right before the logic enters the <code>Transaction</code> context.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">updateComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">    prevParentElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextParentElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    prevUnmaskedContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextUnmaskedContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance; <span class="comment">// scr: ---------------------------&gt; 1)</span></span><br><span class="line">  <span class="comment">// scr: sanity check and code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 2)    </span></span><br><span class="line">  <span class="keyword">var</span> nextState = <span class="keyword">this</span>._processPendingState(nextProps, nextContext); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> shouldUpdate = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._pendingForceUpdate) &#123;</span><br><span class="line">    <span class="keyword">if</span> (inst.shouldComponentUpdate) &#123; <span class="comment">// scr: ------------------&gt; 3)</span></span><br><span class="line">      shouldUpdate = inst.shouldComponentUpdate(</span><br><span class="line">        nextProps,</span><br><span class="line">        nextState,</span><br><span class="line">        nextContext,</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class="line">        <span class="comment">// scr: ---------------&gt; it is ImpureClass, not applicable</span></span><br><span class="line">...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._updateBatchNumber = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (shouldUpdate) &#123;</span><br><span class="line">    <span class="keyword">this</span>._pendingForceUpdate = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Will set `this.props`, `this.state` and `this.context`.</span></span><br><span class="line">    <span class="keyword">this</span>._performComponentUpdate( <span class="comment">// scr: --------------------&gt; 4)</span></span><br><span class="line">      nextParentElement,</span><br><span class="line">      nextProps,</span><br><span class="line">      nextState,</span><br><span class="line">      nextContext,</span><br><span class="line">      transaction,</span><br><span class="line">      nextUnmaskedContext,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// scr: code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactCompositeComponent@renderers/shared/stack/reconciler/ReactCompositeComponent.js</span><br></pre></td></tr></table></figure><p>1) obtain the external <code>ReactComponent</code> instance (<code>App</code>) from <code>ReactCompositeComponent[ins]._instance</code> {Figure-I};</p><p>2) merge the partial state in <code>ReactCompositeComponent[ins]._pendingStateQueue</code> (<code>{desc:&#39;end&#39;,color:&#39;green&#39;}</code>) and existing states using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">Object.assign()</a>;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_processPendingState: <span class="function"><span class="keyword">function</span>(<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// scr: -------&gt; obtain the App &#123;Figure-I&#125;</span></span><br><span class="line">  <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">this</span>._pendingStateQueue;</span><br><span class="line">  <span class="comment">// scr: code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nextState = <span class="built_in">Object</span>.assign(&#123;&#125;, replace ? queue[<span class="number">0</span>] : inst.state);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = replace ? <span class="number">1</span> : <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> partial = queue[i];</span><br><span class="line">    <span class="built_in">Object</span>.assign(</span><br><span class="line">      nextState,</span><br><span class="line">      <span class="keyword">typeof</span> partial === <span class="string">'function'</span></span><br><span class="line">        ? partial.call(inst, nextState, props, context)</span><br><span class="line">        : partial,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nextState;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactCompositeComponent@renderers/shared/stack/reconciler/ReactCompositeComponent.js</span><br></pre></td></tr></table></figure><p>3) <a href="https://reactjs.org/docs/optimizing-performance.html" target="_blank" rel="noopener">this is the lifecycle function that is provided to the developers to avoid reconciliation (the following processing logic) from being executed</a> in case <code>setState()</code> does not change the critical states;</p><blockquote><p>Most likely you do not need this function</p></blockquote><p>4) enter the next stop.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">_performComponentUpdate: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    nextElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextState,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">    unmaskedContext,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance; <span class="comment">// scr: &#123;Figure-I&#125;</span></span><br><span class="line">  <span class="comment">// scr: code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// scr: invoke App's life cycle method if defined</span></span><br><span class="line">  <span class="keyword">if</span> (inst.componentWillUpdate) &#123; </span><br><span class="line">    inst.componentWillUpdate(nextProps, nextState, nextContext);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// scr: code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line">    inst.state = nextState;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">this</span>._updateRenderedComponent(transaction, unmaskedContext);</span><br><span class="line">  <span class="comment">// scr: queue App's life cycle method if defined</span></span><br><span class="line">  <span class="keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactCompositeComponent@renderers/shared/stack/reconciler/ReactCompositeComponent.js</span><br></pre></td></tr></table></figure><p>It simply sets the <code>App</code>’s <code>state</code> to the newly merged one. And calls <code>this._updateRenderedComponent()</code> which is the entry point of the diffing algorithm.</p><p>The call stack so far,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">|~~~</span><br><span class="line">  |-runBatchedUpdates()</span><br><span class="line">    |-performUpdateIfNecessary()</span><br><span class="line">      |-ReactCompositeComponent[ins].performUpdateIfNecessary()</span><br><span class="line">        |-this.updateComponent()</span><br><span class="line">          |-this._processPendingState()</span><br><span class="line">          |-this._performComponentUpdate()                     ___</span><br><span class="line">            |-this._updateRenderedComponent()                   |</span><br><span class="line">...                                                          diffing</span><br></pre></td></tr></table></figure><p>Then the logic processes to the diffing algorithm.</p><h1 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h1><p>Before we start examining the Diffing algorithm, we better have a consent about what exactly are virtual DOMs, as the term did not appear in the code base.</p><p>Here I paste an image from {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/">post five</a>} as a reminder:</p><p><img src="https://cdn-images-1.medium.com/max/800/1*864jaojM5NIVrONDV18_7Q.png" alt="Figure-III"></p><p>The <code>ReactElement</code>s are the virtual DOMs we are going to agree on. {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-IV/">post four</a>, <a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/">five</a>} also discussed how the virtual DOM tree are initially established.</p><blockquote><p>In MVC terms <code>ReactElement</code>s are modals which contain only data. On the other hand, <code>ReactDOMComponent</code>s are controllers that offer actionable methods.</p></blockquote><h1 id="Diffing"><a href="#Diffing" class="headerlink" title="Diffing"></a>Diffing</h1><p>The figure above gives the old virtual DOM tree that is generated in {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-IV/">post four</a>}.</p><blockquote><p>ctl-f “in _renderValidatedComponent()”</p></blockquote><p>This step will generate a new one with <code>ReactCompositeComponent[ins]._renderValidatedComponent()</code> based on the changed states, for the purpose of diffing.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_updateRenderedComponent: <span class="function"><span class="keyword">function</span> (<span class="params">transaction, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevComponentInstance = <span class="keyword">this</span>._renderedComponent; <span class="comment">// scr: -&gt; 1)</span></span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 2)</span></span><br><span class="line">  <span class="keyword">var</span> prevRenderedElement = prevComponentInstance._currentElement;</span><br><span class="line">  <span class="comment">// scr: create a new DOM tree</span></span><br><span class="line">  <span class="keyword">var</span> nextRenderedElement = <span class="keyword">this</span>._renderValidatedComponent();</span><br><span class="line">  <span class="keyword">var</span> debugID = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (shouldUpdateReactComponent( <span class="comment">// scr: ----------------------&gt; 3)</span></span><br><span class="line">        prevRenderedElement,</span><br><span class="line">        nextRenderedElement)</span><br><span class="line">  ) &#123;</span><br><span class="line">    ReactReconciler.receiveComponent( <span class="comment">// scr: ------------------&gt; 5)</span></span><br><span class="line">      prevComponentInstance,</span><br><span class="line">      nextRenderedElement,</span><br><span class="line">      transaction,</span><br><span class="line">      <span class="keyword">this</span>._processChildContext(context)</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ---------------------------------------------&gt; 4)</span></span><br><span class="line">  <span class="comment">// scr: code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactCompositeComponent@renderers/shared/stack/reconciler/ReactCompositeComponent.js</span><br></pre></td></tr></table></figure><p>1) obtain <code>ReactDOMComponent[6]</code> through `ReactCompositeComponent[ins] {Figure-I};</p><p>2) cascading call of <code>React.createElement()</code> in <code>App[ins].render()</code> to create the new DOM tree {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-IV/">post four</a>}, in which the only different DOM node is:</p><p><img src="https://cdn-images-1.medium.com/max/800/1*iXWsob9J4Jpb7k3ILaUu9w.png" alt></p><p>3) the first comparison of diffing algorithm is between types of the old and new root elements;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldUpdateReactComponent</span>(<span class="params">prevElement, nextElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevEmpty = prevElement === <span class="literal">null</span> || prevElement === <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> nextEmpty = nextElement === <span class="literal">null</span> || nextElement === <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevEmpty || nextEmpty) &#123;</span><br><span class="line">    <span class="keyword">return</span> prevEmpty === nextEmpty;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> prevType = <span class="keyword">typeof</span> prevElement;</span><br><span class="line">  <span class="keyword">var</span> nextType = <span class="keyword">typeof</span> nextElement;</span><br><span class="line">  <span class="keyword">if</span> (prevType === <span class="string">'string'</span> || prevType === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextType === <span class="string">'string'</span> || nextType === <span class="string">'number'</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nextType === <span class="string">'object'</span> &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shouldUpdateReactComponent@renderers/shared/shared/shouldUpdateReactComponent.js</span><br></pre></td></tr></table></figure><p>4) if they are not the same, build the new tree from scratch — the component mounting process is similar to that discussed in {<a href="https://hackernoon.com/understanding-the-react-source-code-v-812d69a79fb9" target="_blank" rel="noopener">post five</a>};</p><blockquote><p><a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener">whenever the root elements have different types, React will tear down the old tree and build the new tree from scratch</a></p></blockquote><p>5) if the a the same so, start the DOM updating process.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">receiveComponent: <span class="function"><span class="keyword">function</span> (<span class="params">nextElement, transaction, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevElement = <span class="keyword">this</span>._currentElement;</span><br><span class="line">  <span class="keyword">this</span>._currentElement = nextElement;</span><br><span class="line">  <span class="keyword">this</span>.updateComponent(transaction,</span><br><span class="line">                       prevElement,</span><br><span class="line">                       nextElement,</span><br><span class="line">                       context);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">updateComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  context</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastProps = prevElement.props;</span><br><span class="line">  <span class="keyword">var</span> nextProps = <span class="keyword">this</span>._currentElement.props;</span><br><span class="line">  <span class="comment">// scr: code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 1)</span></span><br><span class="line">  <span class="keyword">this</span>._updateDOMProperties(lastProps, nextProps, transaction);</span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 2)</span></span><br><span class="line">  <span class="keyword">this</span>._updateDOMChildren(lastProps, nextProps, transaction, context);</span><br><span class="line"><span class="comment">// scr: code that is not applicable this time</span></span><br><span class="line">...</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactDOMComponent@renderers/dom/shared/ReactDOMComponent.js</span><br></pre></td></tr></table></figure><p>1) get the <code>props</code> from the old virtual DOM (<code>lastProps</code>) and the newly created one (<code>nextProps</code>);</p><p>2) <code>ReactDOMComponent._updateDOMProperties()</code> checks the old and new versions of a DOM’s props, and calls <code>CSSPropertyOperations.setValueForStyles()</code> to update the DOM if different;</p><p>3) <code>ReactDOMComponent._updateDOMChildren()</code> checks the old and new versions of a DOM’s content (text, inner HTML), and calls <code>ReactDOMComponent.updateTextContent()</code> to update the DOM’s (text) content if different.</p><p>The static call stack,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...                                                            ___</span><br><span class="line">ReactReconciler.receiveComponent()      &lt;----------------|      |</span><br><span class="line">  |-ReactDOMComponent.receiveComponent()                 |      |</span><br><span class="line">    |-this.updateComponent()                             |      |</span><br><span class="line">      |-this._updateDOMProperties()                      |   diffing</span><br><span class="line">        |-CSSPropertyOperations.setValueForStyles()      |      |</span><br><span class="line">      |-this._updateDOMChildren()                        |      |</span><br><span class="line">        |-this.updateTextContent()                       |      |</span><br><span class="line">        |-recursing children (not the focus this time) --|      |</span><br><span class="line">                                                               ---</span><br></pre></td></tr></table></figure><p>By observing the static call stack, it is not hard to deduce the how the recursion works.</p><p>1) one iteration of this recursion updates the properties of one virtual DOM;</p><p>2) <code>ReactDOMComponent.updateDOMChildren()</code> is also responsible to go through the current virtual DOM’s direct children and invoke the next iteration for each of them.</p><blockquote><p>note that sub DOM recursing is not the focus of this post</p></blockquote><p>I collapse some method calls in the above call stack,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-ReactReconciler.receiveComponent()</span><br><span class="line">  |-ReactDOMComponent[n].receiveComponent()</span><br><span class="line">    |-this.updateComponent()</span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">|-ReactDOMComponent[n].updateComponent()</span><br></pre></td></tr></table></figure><p>and draw the call stack in action for clarity:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">|-ReactDOMComponent[<span class="number">6</span>].updateComponent()</span><br><span class="line">  |-<span class="keyword">this</span>._updateDOMProperties() <span class="comment">// scr: ----&gt; same</span></span><br><span class="line">  |-<span class="keyword">this</span>._updateDOMChildren</span><br><span class="line">    |-recursing children (not the focus <span class="keyword">this</span> time...)</span><br><span class="line">      |-ReactDOMComponent[<span class="number">4</span>].updateComponent()</span><br><span class="line">        |-<span class="keyword">this</span>._updateDOMProperties() <span class="comment">// scr: ----&gt; same</span></span><br><span class="line">        |-<span class="keyword">this</span>._updateDOMChildren</span><br><span class="line">          |-recursing children (not the focus <span class="keyword">this</span> time...)</span><br><span class="line">            |-ReactDOMComponent[<span class="number">2</span>].updateComponent()</span><br><span class="line">              |-<span class="keyword">this</span>._updateDOMProperties() <span class="comment">// scr: ----&gt; same</span></span><br><span class="line">              |-<span class="keyword">this</span>._updateDOMChildren     <span class="comment">// scr: ----&gt; same</span></span><br><span class="line">            |-ReactDOMComponent[<span class="number">3</span>].updateComponent()</span><br><span class="line">              |-<span class="keyword">this</span>._updateDOMProperties() <span class="comment">// scr: ----&gt; same</span></span><br><span class="line">              |-<span class="keyword">this</span>._updateDOMChildren     <span class="comment">// scr: ----&gt; same</span></span><br><span class="line">      |-ReactDOMComponent[<span class="number">5</span>].updateComponent()</span><br><span class="line">        |-<span class="keyword">this</span>._updateDOMProperties()</span><br><span class="line">          |-CSSPropertyOperations.setValueForStyles()</span><br><span class="line">        |-<span class="keyword">this</span>._updateDOMChildren</span><br><span class="line">          |-<span class="keyword">this</span>.updateTextContent()</span><br></pre></td></tr></table></figure><h2 id="ReactDOMComponent-updateDOMProperties-—check-if-a-DOM-changed"><a href="#ReactDOMComponent-updateDOMProperties-—check-if-a-DOM-changed" class="headerlink" title="ReactDOMComponent._updateDOMProperties() —check if a DOM changed"></a><code>ReactDOMComponent._updateDOMProperties()</code> —check if a DOM changed</h2><blockquote><p>This is the overlooked method in {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a> *6}<br>In this article we focus on only STYLE updating related code.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">_updateDOMProperties: <span class="function"><span class="keyword">function</span>(<span class="params">lastProps, nextProps, transaction</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> propKey;</span><br><span class="line">  <span class="keyword">var</span> styleName;</span><br><span class="line">  <span class="keyword">var</span> styleUpdates;</span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 1)</span></span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> lastProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      nextProps.hasOwnProperty(propKey) ||</span><br><span class="line">      !lastProps.hasOwnProperty(propKey) ||</span><br><span class="line">      lastProps[propKey] == <span class="literal">null</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      <span class="keyword">var</span> lastStyle = <span class="keyword">this</span>._previousStyleCopy;</span><br><span class="line">      <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastStyle) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastStyle.hasOwnProperty(styleName)) &#123;</span><br><span class="line">          styleUpdates = styleUpdates || &#123;&#125;;</span><br><span class="line">          styleUpdates[styleName] = <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>._previousStyleCopy = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ... &#123;</span><br><span class="line">      <span class="comment">// scr: not the focus this time</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: --------------------------------------------------&gt; end 1)</span></span><br><span class="line">  <span class="keyword">for</span> (propKey <span class="keyword">in</span> nextProps) &#123;</span><br><span class="line">    <span class="keyword">var</span> nextProp = nextProps[propKey];</span><br><span class="line">    <span class="keyword">var</span> lastProp = propKey === STYLE</span><br><span class="line">        ? <span class="keyword">this</span>._previousStyleCopy</span><br><span class="line">        : lastProps != <span class="literal">null</span> ? lastProps[propKey] : <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !nextProps.hasOwnProperty(propKey) ||</span><br><span class="line">      nextProp === lastProp ||</span><br><span class="line">      (nextProp == <span class="literal">null</span> &amp;&amp; lastProp == <span class="literal">null</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (propKey === STYLE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nextProp) &#123;</span><br><span class="line">        <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line">       <span class="comment">// scr: -------------------------------------------------&gt; 2)</span></span><br><span class="line">       nextProp = <span class="keyword">this</span>._previousStyleCopy = <span class="built_in">Object</span>.assign(&#123;&#125;, nextProp);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._previousStyleCopy = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (lastProp) &#123; <span class="comment">// scr: ----------------------------------&gt; 3)</span></span><br><span class="line">        <span class="comment">// scr: the comment applies here -----------------------&gt; a)</span></span><br><span class="line">        <span class="comment">// Unset styles on `lastProp` but not on `nextProp`. </span></span><br><span class="line">                   </span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> lastProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            lastProp.hasOwnProperty(styleName) &amp;&amp;</span><br><span class="line">            (!nextProp || !nextProp.hasOwnProperty(styleName))</span><br><span class="line">          ) &#123;</span><br><span class="line">            styleUpdates = styleUpdates || &#123;&#125;;</span><br><span class="line">            styleUpdates[styleName] = <span class="string">''</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// scr: the comment applies here -----------------------&gt; b)</span></span><br><span class="line">        <span class="comment">// Update styles that changed since `lastProp`.</span></span><br><span class="line">        <span class="keyword">for</span> (styleName <span class="keyword">in</span> nextProp) &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            nextProp.hasOwnProperty(styleName) &amp;&amp;</span><br><span class="line">            lastProp[styleName] !== nextProp[styleName]</span><br><span class="line">          ) &#123;</span><br><span class="line">            styleUpdates = styleUpdates || &#123;&#125;;</span><br><span class="line">            styleUpdates[styleName] = nextProp[styleName];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: -----------------------------------------&gt; 4)</span></span><br><span class="line">        <span class="comment">// Relies on `updateStylesByID` not mutating `styleUpdates`.</span></span><br><span class="line">        styleUpdates = nextProp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">      <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (styleUpdates) &#123; <span class="comment">// scr: ----------------------------------&gt; 5)</span></span><br><span class="line">    CSSPropertyOperations.setValueForStyles(</span><br><span class="line">      getNode(<span class="keyword">this</span>),</span><br><span class="line">      styleUpdates,</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactDOMComponent@renderers/dom/shared/ReactDOMComponent.js</span><br></pre></td></tr></table></figure><p>1) if the new props do not contain “<code>style</code>” at all,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (nextProps.hasOwnProperty(propKey) ||...) &#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="comment">// scr: else, do something</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>mark all the existing style entries as ‘remove’, note that existing styles are stored in <code>this._previousStyleCopy</code> in step 2);</p><p>2) copy <code>nextProp</code> (current styles) to <code>this._previousStyleCopy</code>;</p><p>3) if there are existing styles,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lastProp = propKey === STYLE</span><br><span class="line">        ? <span class="keyword">this</span>._previousStyleCopy</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (lastProp) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>update by a) marking existing style entries that are not in <code>nextProp</code> as ‘remove’ and b) marking style entries in <code>nextProp</code> as ‘add’ if it is different from the existing entry on the same key;</p><p>4) if not, simply mark all the styles in <code>nextProp</code> as ‘add’;</p><p>5) conduct the real DOM operations. Note that <code>getNode()</code> is an alias to <code>ReactDOMComponentTree.getNodeFromInstance()</code> that uses <code>ReactDOMComponent._hostNode</code> to get the associated DOM element {Figure-III} {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a>}.</p><blockquote><p>ctl-f “ReactDOMComponent[ins]._hostNode”</p></blockquote><h2 id="CSSPropertyOperations-setValueForStyles-—-update-props"><a href="#CSSPropertyOperations-setValueForStyles-—-update-props" class="headerlink" title="CSSPropertyOperations.setValueForStyles() — update props"></a><code>CSSPropertyOperations.setValueForStyles()</code> — update props</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">setValueForStyles: <span class="function"><span class="keyword">function</span>(<span class="params">node, styles, component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> style = node.style;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> styleName <span class="keyword">in</span> styles) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!styles.hasOwnProperty(styleName)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// scr: DEV code or code that is not applicable</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCustomProperty) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (styleValue) &#123;</span><br><span class="line">      style[styleName] = styleValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        code that is not applicable <span class="keyword">this</span> time</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">CSSPropertyOperations@renderers/dom/shared/CSSPropertyOperations.js</span><br></pre></td></tr></table></figure><p>Here the only line that is applicable here is <code>style[styleName] = styleValue;</code> that set the <code>node.style</code> with <code>styles</code> marked in the previous method.</p><p>As a result, <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style" target="_blank" rel="noopener">Node.style</a><code>[‘color’] = ‘red’</code>.</p><h2 id="updateDOMChildren-—check-if-a-DOM’s-content-changed-and-recurse-its-children"><a href="#updateDOMChildren-—check-if-a-DOM’s-content-changed-and-recurse-its-children" class="headerlink" title="_updateDOMChildren —check if a DOM’s content changed (and recurse its children)"></a><code>_updateDOMChildren</code> —check if a DOM’s content changed (and recurse its children)</h2><blockquote><p>We omit the <code>dangerouslySetInnerHTML</code> related code and focus only on hot paths</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">_updateDOMChildren: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  lastProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  context</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lastContent = CONTENT_TYPES[<span class="keyword">typeof</span> lastProps.children]</span><br><span class="line">      ? lastProps.children</span><br><span class="line">      : <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> nextContent = CONTENT_TYPES[<span class="keyword">typeof</span> nextProps.children]</span><br><span class="line">      ? nextProps.children</span><br><span class="line">      : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// scr: code that is not applicable</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Note the use of `!=` which checks for null or undefined.</span></span><br><span class="line">  <span class="comment">// scr: used by recursing children, to be continued...</span></span><br><span class="line">  <span class="keyword">var</span> lastChildren = lastContent != <span class="literal">null</span> ? <span class="literal">null</span> : lastProps.children;</span><br><span class="line">  <span class="keyword">var</span> nextChildren = nextContent != <span class="literal">null</span> ? <span class="literal">null</span> : nextProps.children;</span><br><span class="line">  <span class="comment">// scr: code that is not applicable</span></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (lastChildren != <span class="literal">null</span> &amp;&amp; nextChildren == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// scr: recursing children, to be continued...</span></span><br><span class="line">    <span class="keyword">this</span>.updateChildren(<span class="literal">null</span>, transaction, context);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastHasContentOrHtml &amp;&amp; !nextHasContentOrHtml) &#123;</span><br><span class="line">    <span class="comment">// scr: DEV code and code that is not applicable</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nextContent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastContent !== nextContent) &#123;</span><br><span class="line">      <span class="keyword">this</span>.updateTextContent(<span class="string">''</span> + nextContent);</span><br><span class="line">      <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHtml != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// scr: code that is not applicable</span></span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextChildren != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// scr: recursing children, to be continued...</span></span><br><span class="line">    <span class="keyword">this</span>.updateChildren(nextChildren, transaction, context);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactDOMComponent@renderers/dom/shared/ReactDOMComponent.js</span><br></pre></td></tr></table></figure><p>The only line that is applicable here is</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.updateTextContent(‘’ + nextContent);</span><br></pre></td></tr></table></figure><h2 id="ReactDOMComponent-updateTextContent-—-update-content"><a href="#ReactDOMComponent-updateTextContent-—-update-content" class="headerlink" title="ReactDOMComponent.updateTextContent() — update content"></a><code>ReactDOMComponent.updateTextContent()</code> — update content</h2><p>Presumably <code>ReactDOMComponent.updateTextContent()</code> is used to set the text from <code>&#39;start&#39;</code> to <code>&#39;end&#39;</code>. But the call stack of this process is a bit too deep for this simple operation,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">updateTextContent: <span class="function"><span class="keyword">function</span>(<span class="params">nextContent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prevChildren = <span class="keyword">this</span>._renderedChildren;</span><br><span class="line">  <span class="comment">// Remove any rendered children. scr: -------&gt; the comment applies</span></span><br><span class="line">  ReactChildReconciler.unmountChildren(prevChildren, <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> prevChildren) &#123;</span><br><span class="line">    <span class="comment">// scr: sanity check</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set new text content. scr: ---------------&gt; the comment applies</span></span><br><span class="line">  <span class="keyword">var</span> updates = [makeTextContent(nextContent)];</span><br><span class="line">  processQueue(<span class="keyword">this</span>, updates);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processQueue</span>(<span class="params">inst, updateQueue</span>) </span>&#123;</span><br><span class="line">  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactMultiChild@renderers/shared/stack/reconciler/ReactMultiChild.js</span><br></pre></td></tr></table></figure><p>Here <code>ReactComponentBrowserEnvironment</code> is injected as <code>ReactComponentEnvironment</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dangerouslyProcessChildrenUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">parentInst, updates</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = ReactDOMComponentTree.getNodeFromInstance(parentInst);</span><br><span class="line">  DOMChildrenOperations.processUpdates(node, updates);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactDOMIDOperations@renderers/dom/client/ReactDOMIDOperations.js</span><br></pre></td></tr></table></figure><blockquote><p>The <code>ReactDOMComponentTree.getNodeFromInstance()</code> method is discussed in the previous section.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">processUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">parentNode, updates</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; updates.length; k++) &#123;</span><br><span class="line">    <span class="keyword">var</span> update = updates[k];</span><br><span class="line">    <span class="keyword">switch</span> (update.type) &#123;</span><br><span class="line">      <span class="comment">// scr: code that is not applicable</span></span><br><span class="line">...</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'TEXT_CONTENT'</span>:</span><br><span class="line">        setTextContent(parentNode, update.content);</span><br><span class="line">        <span class="comment">// scr: DEV code</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">DOMChildrenOperations@renderers/dom/client/utils/DOMChildrenOperations.js</span><br></pre></td></tr></table></figure><p>As expected, the last card in this stack is <code>setTextContent()</code> which sets <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent" target="_blank" rel="noopener">Node.textContent</a> directly. This method is covered in {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/">post five</a>} so I will not repeat its implementation.</p><p>The sub call stack of <code>ReactDOMComponent.updateTextContent()</code> and the ‘end’ result of it:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-ReactDOMComponent.updateTextContent()</span><br><span class="line">  |-processQueue()</span><br><span class="line">    |-ReactComponentEnvironment.processChildrenUpdates()</span><br><span class="line">    |=ReactDOMIDOperations.dangerouslyProcessChildrenUpdates()</span><br><span class="line">      |-ReactDOMComponentTree.getNodeFromInstance()</span><br><span class="line">      |-DOMChildrenOperations.processUpdates()</span><br><span class="line">        |-setTextContent()</span><br><span class="line">          |-Node.textContent = &apos;end&apos;</span><br></pre></td></tr></table></figure><p>In the next post we are going to further investigate the diffing algorithm by observing the mutation of DOM trees, which also concludes this series (for a period of time). I hope you will feel more</p><p><img src="https://cdn-images-1.medium.com/max/800/1*ISOaQsLWeezLiUbaKhO5LQ.png" alt></p><p>next time when using <code>setState()</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UI updating, in its essential, is data change. React offers a straightforward and intuitive way to program front-end Apps as most moving parts are converged in the form of states, and most UI tasks can be done with a single&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/800/1*EBJi5HtjKTjMrczt0fibcQ.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;…, I mean, a single method, &lt;code&gt;setState()&lt;/code&gt;. In this article, we are going unfold the &lt;code&gt;setState()&lt;/code&gt; implementation, and peek inside the diffing algorithm by mutating an individual DOM element.&lt;/p&gt;
    
    </summary>
    
      <category term="Understanding The React Source Code" scheme="https://holmeshe.me/categories/Understanding-The-React-Source-Code/"/>
    
    
      <category term="JavaScript" scheme="https://holmeshe.me/tags/JavaScript/"/>
    
      <category term="react.js" scheme="https://holmeshe.me/tags/react-js/"/>
    
      <category term="setstate" scheme="https://holmeshe.me/tags/setstate/"/>
    
      <category term="virtual dom" scheme="https://holmeshe.me/tags/virtual-dom/"/>
    
      <category term="diffing" scheme="https://holmeshe.me/tags/diffing/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The React Source Code - UI Updating (Transactions) VII</title>
    <link href="https://holmeshe.me/understanding-react-js-source-code-initial-rendering-VII/"/>
    <id>https://holmeshe.me/understanding-react-js-source-code-initial-rendering-VII/</id>
    <published>2018-01-28T11:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p>Last time we discussed the core <code>Transaction</code> class and <code>ReactDefaultBatchingStrategyTransaction</code>. The instantiation is not the sole <code>Transaction</code> involved in UI updating but merely the one that leads.</p><p>In this post, we are going to examine the other <code>Transaction</code>s which, together with <code>ReactDefaultBatchingStrategyTransaction</code>, outline the UI updating processing logic.</p><a id="more"></a><p><strong><em>Files used in this article</em></strong>:</p><p><em>renderers/shared/stack/reconciler/ReactUpdates.js</em>: defines <code>flushBatchedUpdates()</code> that is the entry point method of this post; it also defines <code>ReactUpdatesFlushTransaction</code>, one of the <code>Transaction</code> s we are going to discuss</p><p><em>shared/utils/PooledClass.js</em>: defines <code>PooledClass</code> for enabling <em>instance pooling</em></p><p><em>renderers/dom/client/ReactReconcileTransaction.js</em>: defines <code>ReactReconcileTransaction</code>, another <code>Transaction</code> we are going to discuss</p><blockquote><p>We start with the <code>ReactUpdates.flushBatchedUpdates()</code> {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-VI/">last post</a> *8}.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, <span class="literal">null</span>, transaction);</span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (asapEnqueued) &#123; <span class="comment">// scr: not applied</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ReactUpdates@renderers/shared/stack/reconciler/ReactUpdates.js</span><br></pre></td></tr></table></figure><p>As mentioned before, it processes all the <code>dirtyComponents</code> by initiating a <code>ReactUpdatesFlushTransaction</code> that will invoke <code>runBatchedUpdates</code> eventually.</p><h1 id="PooledClass-maintain-an-instance-pool"><a href="#PooledClass-maintain-an-instance-pool" class="headerlink" title="PooledClass - maintain an instance pool"></a><code>PooledClass</code> - maintain an instance pool</h1><p>The two uncommon methods <code>getPooled()</code>, <code>release()</code> are inherited from <code>PooledClass</code>, which provides the <em>instance pooling</em> capacity:</p><p>a) if there is no allocated instance (in this case, <code>ReactUpdatesFlushTransaction</code>) in the pool, <code>getPooled()</code> creates a new one;</p><p>b) if instances exist in the pool, <code>getPooled()</code> simply returned the instance;</p><p>c) <code>release()</code> does not release the instance, instead, it simply put the instance back to the pool.</p><p>Like any other kinds of pools, the end purpose of this <em>instance pooling</em> is to reduce the overhead of superfluous resource (in this case, memory) allocation and destruction.</p><p>Back to our specific case above:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>ReactUpdatesFlushTransaction</code> instances are allocated only when the first time the <code>while</code> loop is executed. After that instances can be obtained through <code>getPooled()</code> from the pool directly.</p><blockquote><p>This level of understanding of <code>PooledClass</code> is sufficient for the rest of this post. So feel free to fast travel to the the next section by ctrl-f “ReactUpdatesFlushTransaction”.</p></blockquote><p>Now we look at its implementation:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PooledClass = &#123;</span><br><span class="line">  addPoolingTo: addPoolingTo,                     <span class="comment">// scr: ------&gt; 1)</span></span><br><span class="line">  oneArgumentPooler: (oneArgumentPooler: Pooler), <span class="comment">// scr: ------&gt; 2)</span></span><br><span class="line">...<span class="comment">// scr: not used</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = PooledClass;</span><br><span class="line"></span><br><span class="line">PooledClass@shared/utils/PooledClass.js</span><br></pre></td></tr></table></figure><p>1) <code>addPoolingTo()</code>  is a “public” method that adds the pooling functionality to a class;</p><p>2) <code>oneArgumentPooler()</code> is the <code>getPooled()</code> underlying implementation.</p><p>Next we look at <code>addPoolingTo()</code>‘s function body:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> DEFAULT_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> DEFAULT_POOLER = oneArgumentPooler;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addPoolingTo = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  CopyConstructor: Class&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pooler: Pooler,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Class</span>&lt;<span class="title">T</span>&gt; &amp; </span>&#123;</span><br><span class="line">  getPooled(): <span class="comment">/* arguments of the constructor */</span> T,</span><br><span class="line">  release(): <span class="keyword">void</span>,</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">var</span> NewKlass = (CopyConstructor: any);</span><br><span class="line">  NewKlass.instancePool = [];              <span class="comment">// scr: -------------&gt; 1)</span></span><br><span class="line">  NewKlass.getPooled = pooler || DEFAULT_POOLER; <span class="comment">// scr: -------&gt; 2)</span></span><br><span class="line">  <span class="keyword">if</span> (!NewKlass.poolSize) &#123;</span><br><span class="line">    NewKlass.poolSize = DEFAULT_POOL_SIZE; <span class="comment">// scr: -------------&gt; 3)</span></span><br><span class="line">  &#125;</span><br><span class="line">  NewKlass.release = standardReleaser;     <span class="comment">// scr: -------------&gt; 4)</span></span><br><span class="line">  <span class="keyword">return</span> NewKlass;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">addPoolingTo@shared/utils/PooledClass.js</span><br></pre></td></tr></table></figure><p>1) <code>instancePool</code> is the pool;</p><p>2) attach <code>DEFAULT_POOLER</code> (a.k.a., <code>oneArgumentPooler</code>) to the <code>getPooled()</code>;</p><p>3) set <code>poolSize</code> to 10;</p><p>4) attach <code>standardReleaser()</code> to the <code>release()</code>.</p><p>And this is how <code>getPooled()</code> and <code>release()</code> are implemented:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oneArgumentPooler = <span class="function"><span class="keyword">function</span>(<span class="params">copyFieldsFrom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Klass = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span> (Klass.instancePool.length) &#123;           <span class="comment">// scr: -----------&gt; 1)</span></span><br><span class="line">    <span class="keyword">var</span> instance = Klass.instancePool.pop(); <span class="comment">// scr: -----------&gt; 1)</span></span><br><span class="line">    Klass.call(instance, copyFieldsFrom);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Klass(copyFieldsFrom);   <span class="comment">// scr: ----------------&gt; 2)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">oneArgumentPooler@shared/utils/PooledClass.js</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> standardReleaser = <span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Klass = <span class="keyword">this</span>;</span><br><span class="line">...</span><br><span class="line">  instance.destructor();</span><br><span class="line">  <span class="keyword">if</span> (Klass.instancePool.length &lt; Klass.poolSize) &#123; <span class="comment">// scr: ----&gt; 3)</span></span><br><span class="line">    Klass.instancePool.push(instance);              <span class="comment">// scr: ----&gt; 3)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">standardReleaser@shared/utils/PooledClass.js</span><br></pre></td></tr></table></figure><p>1) corresponds to b), in which</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Klass.call(instance, copyFieldsFrom);</span><br></pre></td></tr></table></figure><p>invokes <code>Klass</code> constructor with the designated parameters (<code>copyFieldsFrom</code>) to initialize the pooling enabled class; and</p><p>2) corresponds to a); and</p><p>3) corresponds to c).</p><p>Last, we look at how <code>addPoolingTo()</code> is used from the outside (<code>ReactUpdatesFlushTransaction</code>):</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ReactUpdatesFlushTransaction@renderers/shared/stack/reconciler/ReactUpdates.js</span><br></pre></td></tr></table></figure><h1 id="ReactUpdatesFlushTransaction"><a href="#ReactUpdatesFlushTransaction" class="headerlink" title="ReactUpdatesFlushTransaction"></a><code>ReactUpdatesFlushTransaction</code></h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactUpdatesFlushTransaction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">  <span class="keyword">this</span>.dirtyComponentsLength = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.callbackQueue = CallbackQueue.getPooled();</span><br><span class="line">  <span class="keyword">this</span>.reconcileTransaction =</span><br><span class="line">  ReactUpdates.ReactReconcileTransaction.getPooled(  <span class="comment">// scr: ---&gt; 2)</span></span><br><span class="line">    <span class="comment">/* useCreateElement */</span> <span class="literal">true</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 1)</span></span><br><span class="line"><span class="built_in">Object</span>.assign(ReactUpdatesFlushTransaction.prototype, Transaction, &#123;</span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRANSACTION_WRAPPERS; <span class="comment">// scr: -----------------------&gt; 3)</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destructor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dirtyComponentsLength = <span class="literal">null</span>;</span><br><span class="line">    CallbackQueue.release(<span class="keyword">this</span>.callbackQueue);</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue = <span class="literal">null</span>;</span><br><span class="line">    ReactUpdates.ReactReconcileTransaction.release( <span class="comment">// scr: ----&gt; 2)</span></span><br><span class="line">      <span class="keyword">this</span>.reconcileTransaction</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.reconcileTransaction = <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  perform: <span class="function"><span class="keyword">function</span>(<span class="params">method, scope, a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Transaction.perform.call(</span><br><span class="line">      <span class="keyword">this</span>,</span><br><span class="line">      <span class="keyword">this</span>.reconcileTransaction.perform, <span class="comment">// scr: ---------------&gt; 2)</span></span><br><span class="line">      <span class="keyword">this</span>.reconcileTransaction,</span><br><span class="line">      method,</span><br><span class="line">      scope,</span><br><span class="line">      a,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ReactUpdatesFlushTransaction@renderers/shared/stack/reconciler/ReactUpdates.js</span><br></pre></td></tr></table></figure><p>1) it is another instantiation of <code>Transaction</code> that overrides the <code>perform()</code> method;</p><p>2) instead of calling <code>ReactUpdate.runBatchedUpdates</code> (the callback) directly, the overridden <code>ReactUpdatesFlushTransaction.perform()</code> nest calls another <code>Transaction</code> (<code>ReactReconcileTransaction</code>)’s <code>perform()</code> method and pass <code>method</code> (i.e., <code>ReactUpdate.runBatchedUpdates()</code>) as its callback. Note that <code>ReactReconcileTransaction</code> is also pooling enabled.</p><p>3) <code>TRANSACTION_WRAPPERS</code> defines its pre and post-functions:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> NESTED_UPDATES = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dirtyComponentsLength = dirtyComponents.length;</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.dirtyComponentsLength !== dirtyComponents.length) &#123;</span><br><span class="line">      dirtyComponents.splice(<span class="number">0</span>, <span class="keyword">this</span>.dirtyComponentsLength);</span><br><span class="line">      flushBatchedUpdates();      <span class="comment">// scr: ----------------------&gt; a)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dirtyComponents.length = <span class="number">0</span>; <span class="comment">// scr: ----------------------&gt; b)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> UPDATE_QUEUEING = &#123; <span class="comment">// scr: ------&gt; we omit this wrapper for now</span></span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ReactUpdatesFlushTransaction@renderers/shared/stack/reconciler/ReactUpdates.js</span><br></pre></td></tr></table></figure><p>in which, <code>NESTED_UPDATES</code>‘s <code>initialize()</code> 1.5) stores the number of <code>dirtyComponents</code>; its <code>close()</code> 3) check if the number has changed. If they are different {a} the <code>flushBatchedUpdates()</code> is called to reiterate the process; or {b} it set <code>dirtyComponents.length</code> back to <code>0</code>, and returns back to the upper level <code>Transaction</code>, <code>ReactDefaultBatchingStrategyTransaction</code> {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-VI/">last post</a>}.</p><blockquote><p>I will not examine the <code>CallbackQueue</code> related operations (in <code>UPDATE_QUEUEING</code>) and will leave them for later articles when discussing component’s life cycle. *9</p></blockquote><p>To recap:</p><p><img src="https://cdn-images-1.medium.com/max/800/1*TTVPZGOHLeCtwo4VOs8dxQ.png" alt></p><h1 id="ReactReconcileTransaction"><a href="#ReactReconcileTransaction" class="headerlink" title="ReactReconcileTransaction"></a><code>ReactReconcileTransaction</code></h1><p>It is another <code>Transaction</code> and nothing is out of ordinary.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Mixin = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see <span class="variable">Transaction</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@abstract</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@final</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;array&lt;object&gt;&#125;</span> </span>List of operation wrap procedures.</span></span><br><span class="line"><span class="comment">   *   <span class="doctag">TODO:</span> convert to array&lt;TransactionWrapper&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRANSACTION_WRAPPERS; <span class="comment">// scr: -----------------------&gt; 1)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// scr: ---------------------&gt; we omit all CallbackQueue s for now</span></span><br><span class="line">  getReactMountReady: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reactMountReady;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: ---------------------&gt; we omit all CallbackQueue s for now</span></span><br><span class="line">  getUpdateQueue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ReactUpdateQueue;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  checkpoint: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// scr: -----------------------&gt; not used</span></span><br><span class="line">    <span class="comment">// reactMountReady is the our only stateful wrapper</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reactMountReady.checkpoint();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  rollback: <span class="function"><span class="keyword">function</span>(<span class="params">checkpoint</span>) </span>&#123; <span class="comment">// scr: ---------------&gt; not used</span></span><br><span class="line">    <span class="keyword">this</span>.reactMountReady.rollback(checkpoint);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: ------------------------------------&gt; for instance pooling</span></span><br><span class="line">  destructor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    CallbackQueue.release(<span class="keyword">this</span>.reactMountReady);</span><br><span class="line">    <span class="keyword">this</span>.reactMountReady = <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(ReactReconcileTransaction.prototype, Transaction, Mixin);</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 2)</span></span><br><span class="line">PooledClass.addPoolingTo(ReactReconcileTransaction);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = ReactReconcileTransaction;</span><br><span class="line"></span><br><span class="line">ReactReconcileTransaction@renderers/dom/client/ReactReconcileTransaction.js</span><br></pre></td></tr></table></figure><p>1) Its wrappers are defined in <code>TRANSACTION_WRAPPERS</code>;</p><p>2) as mentioned before, this class is pooling enabled.</p><p>Next we look at its three wrapper:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensures that, when possible, the selection range (currently selected text</span></span><br><span class="line"><span class="comment"> * input) is not disturbed by performing the transaction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> SELECTION_RESTORATION = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;Selection&#125;</span> </span>Selection information.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  initialize: ReactInputSelection.getSelectionInformation,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Selection&#125;</span> </span>sel Selection information returned from `initialize`.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  close: ReactInputSelection.restoreSelection,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Suppresses events (blur/focus) that could be inadvertently dispatched due to</span></span><br><span class="line"><span class="comment"> * high level DOM manipulations (like temporarily removing a text input from the</span></span><br><span class="line"><span class="comment"> * DOM).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> EVENT_SUPPRESSION = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;boolean&#125;</span> </span>The enabled status of `ReactBrowserEventEmitter` before</span></span><br><span class="line"><span class="comment">   * the reconciliation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentlyEnabled = ReactBrowserEventEmitter.isEnabled();</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> currentlyEnabled;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;boolean&#125;</span> </span>previouslyEnabled Enabled status of</span></span><br><span class="line"><span class="comment">   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`</span></span><br><span class="line"><span class="comment">   *   restores the previous value.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params">previouslyEnabled</span>) </span>&#123;</span><br><span class="line">    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Provides a queue for collecting `componentDidMount` and</span></span><br><span class="line"><span class="comment"> * `componentDidUpdate` callbacks during the transaction.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> ON_DOM_READY_QUEUEING = &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initializes the internal `onDOMReady` queue.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reactMountReady.reset();</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reactMountReady.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [</span><br><span class="line">  SELECTION_RESTORATION,</span><br><span class="line">  EVENT_SUPPRESSION,</span><br><span class="line">  ON_DOM_READY_QUEUEING,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">ReactReconcileTransaction@renderers/dom/client/ReactReconcileTransaction.js</span><br></pre></td></tr></table></figure><p>The comment is quite clear here:</p><p><code>SELECTION_RESTORATION</code> is for storing the focus state of text fields before the UI updating (<code>initialize()</code>), and it restores the state after (<code>close()</code>);</p><p><code>EVENT_SUPPRESSION</code> is for storing the toggle state for enabling event, and disable event temporarily before (<code>initialize()</code>), and it restores the state after UI updating (<code>close()</code>).</p><blockquote><p>Again, I will not examine the <code>CallbackQueue</code> related operations (in <code>ON_DOM_READY_QUEUEING</code>) here and will leave them for later articles when discussing component’s life cycle. *10</p></blockquote><p>It is important to note that <code>ReactReconcileTransaction</code> relies on the default <code>Transaction.perform()</code>. Its callback is the <code>ReactUpdate.runBatchedUpdates</code> which is passed all the way down to this level.</p><blockquote><p>ctrl-f “runBatchedUpdates” to examine its route.</p></blockquote><p>And this <code>ReactUpdate.runBatchedUpdates</code> will lead to the content of my next post.</p><p>to recap:</p><p><img src="https://cdn-images-1.medium.com/max/800/1*LdLvliZSl0br2eGIo-Yx3w.png" alt></p><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*zpe_HdKTihr3HNjzjUy3tw.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Last time we discussed the core &lt;code&gt;Transaction&lt;/code&gt; class and &lt;code&gt;ReactDefaultBatchingStrategyTransaction&lt;/code&gt;. The instantiation is not the sole &lt;code&gt;Transaction&lt;/code&gt; involved in UI updating but merely the one that leads.&lt;/p&gt;
&lt;p&gt;In this post, we are going to examine the other &lt;code&gt;Transaction&lt;/code&gt;s which, together with &lt;code&gt;ReactDefaultBatchingStrategyTransaction&lt;/code&gt;, outline the UI updating processing logic.&lt;/p&gt;
    
    </summary>
    
      <category term="Understanding The React Source Code" scheme="https://holmeshe.me/categories/Understanding-The-React-Source-Code/"/>
    
    
      <category term="JavaScript" scheme="https://holmeshe.me/tags/JavaScript/"/>
    
      <category term="react.js" scheme="https://holmeshe.me/tags/react-js/"/>
    
      <category term="component" scheme="https://holmeshe.me/tags/component/"/>
    
      <category term="setstate" scheme="https://holmeshe.me/tags/setstate/"/>
    
      <category term="transaction" scheme="https://holmeshe.me/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The React Source Code - UI Updating (Transaction) VI</title>
    <link href="https://holmeshe.me/understanding-react-js-source-code-initial-rendering-VI/"/>
    <id>https://holmeshe.me/understanding-react-js-source-code-initial-rendering-VI/</id>
    <published>2018-01-25T11:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p>To some extent, the sophisticated and efficient UI updating is what makes React React. But before we dive into the well-known mechanisms (virtual DOM and  diffing algorithm) that empower the UI updating, we need to understand <code>Transaction</code> which transfers the control from the high-level API <code>setState()</code> to those underlying processing logic.</p><a id="more"></a><p><strong><em>Files used in this article</em></strong>:</p><p><em>renderers/shared/utils/Transaction.js</em>: defines the core <code>Transaction</code> class</p><p><em>renderers/shared/stack/reconciler/ReactDefaultBatchingStrategy.js</em>: defines <code>ReactDefaultBatchingStrategyTransaction</code> and its API wrapper <code>ReactDefaultBatchingStrategy</code></p><p><em>renderers/shared/stack/reconciler/ReactUpdates.js</em>: defines the <code>enqueueUpdate()</code> that uses <code>ReactDefaultBatchingStrategy</code></p><blockquote><p>Unlike the previous posts that start from everyday APIs and move down the call stack. This post will take a bottom up approach.</p></blockquote><p>So firstly, we look at the</p><h1 id="Transaction-the-core-class"><a href="#Transaction-the-core-class" class="headerlink" title="Transaction the core class"></a>Transaction the core class</h1><p>The only de facto “public” method of this class is perform that also offers its core functionality:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;function&#125;</span> </span>method Member of scope to call.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>scope Scope to invoke from.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object?=&#125;</span> </span>a Argument to pass to the method.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object?=&#125;</span> </span>b Argument to pass to the method.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object?=&#125;</span> </span>c Argument to pass to the method.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object?=&#125;</span> </span>d Argument to pass to the method.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object?=&#125;</span> </span>e Argument to pass to the method.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object?=&#125;</span> </span>f Argument to pass to the method.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return <span class="type">&#123;*&#125;</span> </span>Return value from `method`.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  perform: <span class="function"><span class="keyword">function</span>&lt;</span></span><br><span class="line"><span class="function">    <span class="title">A</span>,</span></span><br><span class="line"><span class="function">    <span class="title">B</span>,</span></span><br><span class="line"><span class="function">    <span class="title">C</span>,</span></span><br><span class="line"><span class="function">    <span class="title">D</span>,</span></span><br><span class="line"><span class="function">    <span class="title">E</span>,</span></span><br><span class="line"><span class="function">    <span class="title">F</span>,</span></span><br><span class="line"><span class="function">    <span class="title">G</span>,</span></span><br><span class="line"><span class="function">    <span class="title">T</span>: (<span class="params">a: A, b: B, c: C, d: D, e: E, f: F</span>) =&gt; <span class="title">G</span>,</span></span><br><span class="line"><span class="function">  &gt;(<span class="params">method: T, scope: any, a: A, b: B, c: C, d: D, e: E, f: F</span>): <span class="title">G</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* eslint-enable space-before-function-paren */</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">var</span> errorThrown;</span><br><span class="line">    <span class="keyword">var</span> ret;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._isInTransaction = <span class="literal">true</span>;</span><br><span class="line">...</span><br><span class="line">      <span class="comment">// one of these calls threw.</span></span><br><span class="line">      errorThrown = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">this</span>.initializeAll(<span class="number">0</span>);</span><br><span class="line">      ret = method.call(scope, a, b, c, d, e, f);</span><br><span class="line">      errorThrown = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorThrown) &#123;</span><br><span class="line">...</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeAll(<span class="number">0</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">          <span class="keyword">this</span>.closeAll(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._isInTransaction = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">TransactionImpl@renderers/shared/utils/Transaction.js</span><br></pre></td></tr></table></figure><p>Besides the invocation of the callback method passed to it as the first argument, <code>perform()</code> simply 1) invokes <code>initializeAll()</code> before the callback and 2)  <code>closeAll()</code> after.</p><p>Here the <code>errorThrown</code> is used to indicate an exception occurred within <code>method.call()</code>, in which case the logic jump directly to <code>finally</code> block before <code>errorThrown</code> can get a chance to be set to <code>false</code>.</p><p>Next we look at the implementation of the two methods that are invoked before and after <code>perform()</code>,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  initializeAll: <span class="function"><span class="keyword">function</span>(<span class="params">startIndex: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> transactionWrappers = <span class="keyword">this</span>.transactionWrappers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex; i &lt; transactionWrappers.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> wrapper = transactionWrappers[i];</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">this</span>.wrapperInitData[i] = OBSERVED_ERROR;</span><br><span class="line">        <span class="keyword">this</span>.wrapperInitData[i] = wrapper.initialize</span><br><span class="line">          ? wrapper.initialize.call(<span class="keyword">this</span>)</span><br><span class="line">          : <span class="literal">null</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.wrapperInitData[i] === OBSERVED_ERROR) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.initializeAll(i + <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  closeAll: <span class="function"><span class="keyword">function</span>(<span class="params">startIndex: number</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line">    <span class="keyword">var</span> transactionWrappers = <span class="keyword">this</span>.transactionWrappers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = startIndex; i &lt; transactionWrappers.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> wrapper = transactionWrappers[i];</span><br><span class="line">      <span class="keyword">var</span> initData = <span class="keyword">this</span>.wrapperInitData[i];</span><br><span class="line">      <span class="keyword">var</span> errorThrown;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        errorThrown = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (initData !== OBSERVED_ERROR &amp;&amp; wrapper.close) &#123;</span><br><span class="line">          wrapper.close.call(<span class="keyword">this</span>, initData);</span><br><span class="line">        &#125;</span><br><span class="line">        errorThrown = <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorThrown) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeAll(i + <span class="number">1</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.wrapperInitData.length = <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type Transaction = <span class="keyword">typeof</span> TransactionImpl;</span><br><span class="line"></span><br><span class="line">TransactionImpl@renderers/shared/utils/Transaction.js</span><br></pre></td></tr></table></figure><p>These two methods simply iterate <code>this.transactionWrappers</code> and call their <code>initialize()</code> and <code>close()</code> respectively.</p><p>The <code>this.transactionWrappers</code> is initialized in the de fecto constructor of <code>Transaction</code> with <code>this.getTransactionWrappers()</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  reinitializeTransaction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionWrappers = <span class="keyword">this</span>.getTransactionWrappers();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.wrapperInitData) &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrapperInitData.length = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.wrapperInitData = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._isInTransaction = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">TransactionImpl@renderers/shared/utils/Transaction.js</span><br></pre></td></tr></table></figure><p>We will see what exactly are those <code>this.transactionWrappers</code> very soon.</p><p>The exception handling detail here is a bit interesting. Take <code>initializeAll()</code> as an instance. In the case that an exception occurs within <code>initialize()</code>, a <code>finally</code> block (instead of a <code>catch</code>) processes the <code>initialize()</code> of the rest of <code>this.transactionWrappers</code> (i.e., from <code>i + 1</code> to <code>transactionWrappers.length-1</code>). Then the exception interrupts the <code>for</code> loop and the entire <code>initializeAll()</code> logic and processes all the way to the <code>finally</code> block within <code>perform()</code>, the <code>initializeAll()</code>’s caller, which effectively skips</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = method.call(scope, a, b, c, d, e, f);</span><br></pre></td></tr></table></figure><p>in the case of a exceptional initialization. At last, <code>closeAll()</code> is invoked within the same <code>finally</code> block to finalize the transaction.</p><p>Now we know what is a <code>Transaction</code> in its essence, but what is it used for? In order to answer this question, we take a <code>Transaction</code> instantiation as an example that is the transactional entry point of  UI updating.</p><h1 id="ReactDefaultBatchingStrategyTransaction"><a href="#ReactDefaultBatchingStrategyTransaction" class="headerlink" title="ReactDefaultBatchingStrategyTransaction"></a><code>ReactDefaultBatchingStrategyTransaction</code></h1><p>Firstly <code>ReactDefaultBatchingStrategyTransaction</code> is a subclass of <code>Transaction</code> that implements <code>getTransactionWrappers()</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">Object</span>.assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123;</span><br><span class="line">  getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ReactDefaultBatchingStrategyTransaction@renderers/shared/stack/reconciler/ReactDefaultBatchingStrategy.js</span><br></pre></td></tr></table></figure><p>Next, <code>TRANSACTION_WRAPPERS</code> are the source of <code>this.transactionWrappers</code> that offers the pre (<code>initialize()</code>) and post (<code>close()</code>) functions for <code>perform()</code> used in the last section.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;; <span class="comment">// scr: -----------------------------------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;; <span class="comment">// scr: -----------------------------------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];  <span class="comment">// scr: -------------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDefaultBatchingStrategyTransaction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">&#125; <span class="comment">// scr: ------------------------------------------------------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 3)</span></span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> ReactDefaultBatchingStrategyTransaction();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">ReactDefaultBatchingStrategyTransaction@renderers/shared/stack/reconciler/ReactDefaultBatchingStrategy.js</span><br></pre></td></tr></table></figure><p>1) in the constructor of <code>ReactDefaultBatchingStrategyTransaction</code> the super class <code>Transaction</code>’s constructor gets called, which initializes <code>this.transactionWrappers</code> with <code>FLUSH_BATCHED_UPDATES</code> defined in 2)</p><p>2) defines the two wrapper and their respective <code>initialize()</code> and <code>close()</code>, which is used in the <code>Transaction.initializeAll()</code> and <code>Transaction.closeAll()</code> in the loops iterating <code>FLUSH_BATCHED_UPDATES</code></p><p>3) defines <code>ReactDefaultBatchingStrategyTransaction</code> as a singleton.</p><p>Last we look at the public API offered by <code>ReactDefaultBatchingStrategy</code> that can be called from the outside world</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The code is written this way to avoid extra allocations</span></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123; <span class="comment">// scr: --------&gt; not applied here</span></span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDefaultBatchingStrategy@renderers/shared/stack/reconciler/ReactDefaultBatchingStrategy.js</span><br></pre></td></tr></table></figure><p><code>ReactDefaultBatchingStrategy</code> is injected {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-II/">post two</a> *5} to <code>ReactUpdates</code> as <code>batchingStrategy</code>. And the <code>ReactDefaultBatchingStrategy.batchedUpdates()</code> is used by <code>ReactUpdates.enqueueUpdate()</code>, the underlying method of the UI updating entry point <code>setState()</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123; <span class="comment">// scr: ----------&gt; &#123;a&#125;</span></span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// scr: -----------------------------------------------------&gt; &#123;b&#125;</span></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  <span class="keyword">if</span> (component._updateBatchNumber == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// scr: this field is used for sanity check later</span></span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactUpdates@renderers/shared/stack/reconciler/ReactUpdates.js</span><br></pre></td></tr></table></figure><p>Here is a similar recursion trick as we saw in <a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/">last post</a>.</p><p>1) When the method is entered the first time, <code>ReactDefaultBatchingStrategy.isBatchingUpdates</code> is false, which triggers branch {a} that leads to <code>ReactDefaultBatchingStrategy.batchedUpdates()</code>;</p><p>2) <code>batchedUpdates()</code> sets <code>ReactDefaultBatchingStrategy.isBatchingUpdates</code> to true, and initializes a <code>transaction</code>;</p><p>3) the <code>callback</code> argument of <code>batchedUpdates</code> is <code>enqueueUpdate()</code> itself, so <code>enqueueUpdate</code> will be entered again with <code>transaction.perform()</code> straight away. Note that the pre-methods (<code>initialize()</code>) of both wrappers are <code>emptyFunction</code> so nothing happens between the two times invocation of <code>enqueueUpdate()</code>;</p><p>4) when <code>enqueueUpdate()</code> is entered the second time (within the context of the <code>transaction</code> just initialized), branch {b} is executed;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">dirtyComponents.push(component);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>5) after <code>enqueueUpdate()</code> returned post-method (<code>close()</code>) of <code>FLUSH_BATCHED_UPDATES</code> is called; This is the workhorse method that processes all the <code>dirtyComponents</code> marked in the previous step(s)</p><blockquote><p>*8 we will come back to this <code>FLUSH_BATCHED_UPDATES.close()</code> and <code>ReactUpdates.flushBatchedUpdates()</code> in the next post</p></blockquote><p>6) last, post-method (<code>close()</code>) of <code>RESET_BATCHED_UPDATES</code> is called, which sets <code>ReactDefaultBatchingStrategy.isBatchingUpdates</code> back to <code>false</code> and completes the circle.</p><p>It is important to note that any successive calls of <code>enqueueUpdate()</code> between 3) and 6) are supposed to be executed in the context of <code>ReactDefaultBatchingStrategy.isBatchingUpdates:false</code>, meaning, branch {b} will be taken in such case. So it’s like</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-&gt;dirtyComponents.push(component);</span><br><span class="line">-&gt;dirtyComponents.push(component);</span><br><span class="line">-&gt;dirtyComponents.push(component);</span><br><span class="line">...</span><br><span class="line">-----&gt;ReactUpdates.flushBatchedUpdates</span><br></pre></td></tr></table></figure><h1 id="Wrap-up"><a href="#Wrap-up" class="headerlink" title="Wrap-up"></a>Wrap-up</h1><p><img src="https://cdn-images-1.medium.com/max/800/1*HfouUUp41H3fSAYHWF0C_A.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;To some extent, the sophisticated and efficient UI updating is what makes React React. But before we dive into the well-known mechanisms (virtual DOM and  diffing algorithm) that empower the UI updating, we need to understand &lt;code&gt;Transaction&lt;/code&gt; which transfers the control from the high-level API &lt;code&gt;setState()&lt;/code&gt; to those underlying processing logic.&lt;/p&gt;
    
    </summary>
    
      <category term="Understanding The React Source Code" scheme="https://holmeshe.me/categories/Understanding-The-React-Source-Code/"/>
    
    
      <category term="JavaScript" scheme="https://holmeshe.me/tags/JavaScript/"/>
    
      <category term="react.js" scheme="https://holmeshe.me/tags/react-js/"/>
    
      <category term="component" scheme="https://holmeshe.me/tags/component/"/>
    
      <category term="setstate" scheme="https://holmeshe.me/tags/setstate/"/>
    
      <category term="transaction" scheme="https://holmeshe.me/tags/transaction/"/>
    
  </entry>
  
  <entry>
    <title>Understanding The React Source Code - Initial Rendering (Class Component) V</title>
    <link href="https://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/"/>
    <id>https://holmeshe.me/understanding-react-js-source-code-initial-rendering-V/</id>
    <published>2018-01-12T11:00:00.000Z</published>
    <updated>2020-12-22T10:48:38.121Z</updated>
    
    <content type="html"><![CDATA[<p>Last time we completed the upper half of the class component rendering logic which is similar to albeit different from simple component rendering in the following respects: 1) it instantiates one additional <code>ReactCompositeComponent</code> to represent the class component (<code>App</code>); and 2) it calls <code>App.render()</code> that triggers cascading <code>React.createElement()</code>s to establish a <code>ReactElement</code> tree.</p><p>This time we are going to explore more branches in lower half by examining how the <code>ReactElements</code> in the tree is transformed to their respective <code>ReactDOMComponents</code>, and eventually, to real DOM objects.</p><a id="more"></a><p><strong><em>Files used in this article</em></strong>:</p><p><em>renderers/dom/shared/ReactDOMComponent.js</em>: offers the one of the methods that this post focuses on, <code>_createInitialChildren</code></p><p><em>renderers/dom/client/utils/setTextContent.js</em>: DOM operation, setting text</p><p><em>renderers/dom/client/utils/DOMLazyTree.js</em>: DOM operation, appending child</p><p><em>renderers/shared/stack/reconciler/ReactMultiChild.js</em>: the intermediate method to <code>traverseAllChildren</code> as well as the other method in focus, <code>mountChildren()</code></p><p><em>shared/utils/traverseAllChildren.js</em>: method that iterates direct sub <code>ReactElements</code> and instantiates their respective <code>ReactDOMComponents</code></p><p><strong><em>Notations used in the call stack</em></strong>:<br>↻ loop<br>? condition</p><blockquote><p>I use {} to reference the previous post that is relevant to the methods (or logic process) being discussed.</p></blockquote><p>The process discussed in this post occurs majorly within <code>ReactDOMComponent[6].mountComponent()</code>. The major task of this method, that derives a DOM object from <code>ReactDOMComponent[6]</code>, is covered in {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a>}. This task is numbered as 0) for later reference.</p><p>In this post, we are going to address one of the methods that we overlooked on purpose last time, <code>_createInitialChildren</code> which is used for handling the newly introduced <code>ReactElement</code> tree as the class component’s children. It was used in a niche case, a text child, in {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a> *7} and only a side branch was triggered. This side branch, as well as the entire method will be discussed in detail in this post.</p><blockquote><p><code>_createInitialChildren</code> is our protagonist today; please search *7 in <a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a> if you want to check its role in the simple component rendering. The other overlooked method <code>_updateDOMProperties</code> in {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a> *6} will be discussed in later articles.</p></blockquote><p>To be more specific, this method 1) transforms <code>ReactElement</code>s to their corresponding <code>ReactDOMComonent</code>s; 2) (recursively) calls <code>ReactDOMComponent[*].mountComponent()</code> to create the DOM objects; and 3) appends them to the root DOM node that is created in 0).</p><p>So firstly let’s recap step 0) in the context of class component.</p><h1 id="ReactDOMComponent-6-mountComponent-before-createInitialChildren-—create-the-DOM-element-6"><a href="#ReactDOMComponent-6-mountComponent-before-createInitialChildren-—create-the-DOM-element-6" class="headerlink" title="ReactDOMComponent[6].mountComponent() (before _createInitialChildren)—create the DOM element[6]"></a><code>ReactDOMComponent[6].mountComponent()</code> (before <code>_createInitialChildren</code>)—create the DOM element[6]</h1><blockquote><p>time-saving hint: this paragraph is here to keep the post self-contained, the detail of the <code>ReactDOMComponent</code> creation process has been covered in {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a>}</p></blockquote><p>Designated data structure:</p><p><img src="https://cdn-images-1.medium.com/max/800/1*LAhX4p34wuseVi1QIk9dJw.png" alt></p><p>Call stack in action:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">|~mountComponentIntoNode()                                    |</span><br><span class="line">  |-ReactReconciler.mountComponent()                          |</span><br><span class="line">    |-ReactCompositeComponent[T].mountComponent()             |</span><br><span class="line">      |-ReactCompositeComponent[T].performInitialMount()  upper half</span><br><span class="line">        |-ReactReconciler.mountComponent()                    |</span><br><span class="line">          |-ReactCompositeComponent[ins].mountComponent()     |</span><br><span class="line">            |-<span class="keyword">this</span>.performInitialMount()                      |</span><br><span class="line">              |-<span class="keyword">this</span>._renderValidatedComponent()              |</span><br><span class="line">              |-instantiateReactComponent()                  _|_ </span><br><span class="line">                (we are here)                                 |</span><br><span class="line">              |-ReactDOMComponent[<span class="number">6</span>].mountComponent(          |</span><br><span class="line">                  transaction, <span class="comment">// scr: -----&gt; not of interest |</span></span><br><span class="line">                  hostParent,  <span class="comment">// scr: -----&gt; null            |</span></span><br><span class="line">                  hostContainerInfo,<span class="comment">// scr:---------------------&gt; ReactDOMContainerInfo[ins]                                lower half</span></span><br><span class="line">                  context      <span class="comment">// scr: -----&gt; not of interest |</span></span><br><span class="line">                )                                             |</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>This step creates a DOM object with <code>ReactDOMComponent[6]</code>, and set up its attributes.</p><p>To recap: it 1) initializes properties of <code>ReactDOMComponent[6]</code>; 2) creates a <code>div</code> DOM element using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement" target="_blank" rel="noopener">document.createElement()</a>; 3) creates a double link between <code>ReactDOMComponent[6]</code> and the DOM object; 4) &amp; 5) set the properties and attributes of the newly created DOM object; and 6) embeds the DOM object in <code>DOMLazyTree[1]</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">mountComponent: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">  hostParent,</span></span></span><br><span class="line"><span class="function"><span class="params">  hostContainerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">  context</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 1)</span></span><br><span class="line">  <span class="keyword">this</span>._rootNodeID = globalIdCounter++;</span><br><span class="line">  <span class="keyword">this</span>._domID = hostContainerInfo._idCounter++;</span><br><span class="line">  <span class="keyword">this</span>._hostParent = hostParent;</span><br><span class="line">  <span class="keyword">this</span>._hostContainerInfo = hostContainerInfo; <span class="comment">// scr: ------------&gt; ReactDOMContainerInfo[ins]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> props = <span class="keyword">this</span>._currentElement.props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">this</span>._tag) &#123; <span class="comment">// scr: ---&gt; no condition is met here</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: -----&gt; sanity check</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We create tags in the namespace of their parent container, except HTML</span></span><br><span class="line"><span class="comment">// tags get no namespace.</span></span><br><span class="line">  <span class="keyword">var</span> namespaceURI;</span><br><span class="line">  <span class="keyword">var</span> parentTag;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hostParent != <span class="literal">null</span>) &#123; <span class="comment">// scr: -----&gt; it is null</span></span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hostContainerInfo._tag) &#123;</span><br><span class="line">    namespaceURI = hostContainerInfo._namespaceURI; <span class="comment">// scr: -------&gt; "http://www.w3.org/1999/xhtml"</span></span><br><span class="line">    parentTag = hostContainerInfo._tag;        <span class="comment">// scr: ------&gt; "div"</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (namespaceURI == <span class="literal">null</span> || </span><br><span class="line">      namespaceURI === DOMNamespaces.svg &amp;&amp; </span><br><span class="line">      parentTag === <span class="string">'foreignobject'</span></span><br><span class="line">  ) &#123; <span class="comment">// scr: -----&gt; no</span></span><br><span class="line">...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (namespaceURI === DOMNamespaces.html) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._tag === <span class="string">'svg'</span>) &#123;               <span class="comment">// scr: -----&gt; no</span></span><br><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._tag === <span class="string">'math'</span>) &#123;       <span class="comment">// scr: -----&gt; no</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._namespaceURI = namespaceURI;  <span class="comment">// scr: ---------------------&gt; "http://www.w3.org/1999/xhtml"</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">// scr: ------&gt; DEV code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> mountImage;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (transaction.useCreateElement) &#123; <span class="comment">// scr: ---------------------&gt; transaction related logic, we assume it is true</span></span><br><span class="line">    <span class="keyword">var</span> ownerDocument = hostContainerInfo._ownerDocument;</span><br><span class="line">    <span class="keyword">var</span> el;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (namespaceURI === DOMNamespaces.html) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._tag === <span class="string">'script'</span>) &#123;         <span class="comment">// scr: -----&gt; no</span></span><br><span class="line">...</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (props.is) &#123;                <span class="comment">// scr: -----&gt; no</span></span><br><span class="line">...</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.</span></span><br><span class="line">        <span class="comment">// See discussion in https://github.com/facebook/react/pull/6896</span></span><br><span class="line">        <span class="comment">// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 2)</span></span><br><span class="line">        <span class="comment">// scr: ---------&gt; HTML DOM API</span></span><br><span class="line">        el = ownerDocument.createElement(<span class="keyword">this</span>._currentElement.type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ------&gt; no</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 3)</span></span><br><span class="line">    ReactDOMComponentTree.precacheNode(<span class="keyword">this</span>, el); <span class="comment">// scr: --------&gt; doubly link (._hostNode &amp; .internalInstanceKey)</span></span><br><span class="line">    <span class="keyword">this</span>._flags |= Flags.hasCachedChildNodes; <span class="comment">// scr: ------------&gt;</span></span><br><span class="line">bit wise its flags</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 4)</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._hostParent) &#123; <span class="comment">// scr: ------&gt; it is the root element</span></span><br><span class="line">      DOMPropertyOperations.setAttributeForRoot(el); <span class="comment">// scr: -----&gt; data-reactroot</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 5)</span></span><br><span class="line">    <span class="keyword">this</span>._updateDOMProperties( <span class="comment">//*6</span></span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      props,</span><br><span class="line">      transaction</span><br><span class="line">    ); <span class="comment">// scr: --------------------------&gt; style:&#123; “color”: “blue” &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 6)</span></span><br><span class="line">    <span class="keyword">var</span> lazyTree = DOMLazyTree(el); <span class="comment">// scr: ------&gt; DOMLazyTree[ins]</span></span><br><span class="line">    <span class="keyword">this</span>._createInitialChildren(transaction, props, context, lazyTree);</span><br><span class="line">...</span><br><span class="line">  &#125; <span class="comment">// if (transaction.useCreateElement)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mountImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOMComponent@renderers/dom/shared/ReactDOMComponent.js</span><br></pre></td></tr></table></figure><blockquote><p><code>ReactDOMComponent[6]</code> gets its DOM node, its children are next in the line</p></blockquote><h1 id="ReactDOMComponent-6-createInitialChildren-—create-DOM-elements-2-5"><a href="#ReactDOMComponent-6-createInitialChildren-—create-DOM-elements-2-5" class="headerlink" title="ReactDOMComponent[6]._createInitialChildren() —create DOM elements[2-5]"></a><code>ReactDOMComponent[6]._createInitialChildren()</code> —create DOM elements[2-5]</h1><p>Designated data structure:</p><p><img src="https://cdn-images-1.medium.com/max/800/1*hMrLon7ozG8wkTLiw4M6Dw.png" alt></p><p>As mentioned before, this method was used to create the string child node (<code>‘hello world’</code>) in {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a>}. We will reuse this side branch in this post when rendering similar nodes (i.e., [3] and [5]), and we name the branch {1}.</p><p>In the case of class component, route {2} is hit when this method is accessed the first time. To be specific, this branch handles the <code>ReactElement</code> tree. As mentioned, it 1) transforms <code>ReactElement</code>s to <code>ReactDOMComponents</code> (a), generates DOM nodes with <code>ReactDOMComponents</code> (b), and 2) insert DOM nodes to the root node generated with <code>ReactDOMComponent[6]</code> in last step.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">_createInitialChildren: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  transaction, <span class="regexp">//</span> scr: not of interest</span></span></span><br><span class="line"><span class="function"><span class="params">  props,       <span class="regexp">//</span> scr: -------------------&gt; ReactElement[<span class="number">6</span>].props</span></span></span><br><span class="line"><span class="function"><span class="params">  context,     <span class="regexp">//</span> scr: not of interest</span></span></span><br><span class="line"><span class="function"><span class="params">  lazyTree     <span class="regexp">//</span> scr: -------------------&gt; DOMLazyTree[ins]</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Intentional use of != to avoid catching zero/false.</span></span><br><span class="line">  <span class="comment">// scr: it is named as 'dangerous', let's avoid touching it</span></span><br><span class="line">  <span class="keyword">var</span> innerHTML = props.dangerouslySetInnerHTML;</span><br><span class="line">  <span class="keyword">if</span> (innerHTML != <span class="literal">null</span>) &#123; <span class="comment">// scr: so no innerHTML</span></span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> contentToUse = CONTENT_TYPES[<span class="keyword">typeof</span> props.children] ? props.children : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> childrenToUse = contentToUse != <span class="literal">null</span> ? <span class="literal">null</span> : props.children;</span><br><span class="line">    <span class="comment">// scr: some comments</span></span><br><span class="line">    <span class="keyword">if</span> (contentToUse != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// scr: some comments</span></span><br><span class="line">      <span class="keyword">if</span> (contentToUse !== <span class="string">''</span>) &#123; <span class="comment">// scr: ----------------&gt; route &#123;1&#125;</span></span><br><span class="line">...<span class="comment">// scr: DEV code</span></span><br><span class="line">        DOMLazyTree.queueText(lazyTree, contentToUse);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenToUse != <span class="literal">null</span>) &#123; <span class="comment">// scr: ---------&gt; route &#123;2&#125;</span></span><br><span class="line">      <span class="keyword">var</span> mountImages = <span class="keyword">this</span>.mountChildren(childrenToUse, transaction, context);  <span class="comment">// scr: --------------------------------&gt; 1)</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mountImages.length; i++) &#123; <span class="attr">scr</span>: ------&gt; <span class="number">2</span>)</span><br><span class="line">        DOMLazyTree.queueChild(lazyTree, mountImages[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactDOMComponent@renderers/dom/shared/ReactDOMComponent.js</span><br></pre></td></tr></table></figure><blockquote><p>The call hierarchy and iteration is a bit complex from now on, so this time I’ll first establish an overview of the big picture before diving into any detail.</p></blockquote><p>The static call stack:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...                                            (outer recursion)</span><br><span class="line">ReactDOMComponent[<span class="number">6</span>].mountComponent()    &lt;-------------------------|</span><br><span class="line">    (we are here)                                                  |</span><br><span class="line">  |-<span class="keyword">this</span>._createInitialChildren()                                  |</span><br><span class="line">  ?&#123;<span class="number">1</span>&#125;                                                             |</span><br><span class="line">    |-DOMLazyTree.queueText()                                      |</span><br><span class="line">  ?&#123;<span class="number">2</span>&#125;                                                             |</span><br><span class="line">    |-<span class="keyword">this</span>.mountChildren()        <span class="comment">// scr: ---------------&gt; 1)(a)   |</span></span><br><span class="line">      |-<span class="keyword">this</span>._reconcilerInstantiateChildren()                      |</span><br><span class="line">        |-ReactChildReconciler.instantiateChildren()               |</span><br><span class="line">          |-traverseAllChildren()                                  |</span><br><span class="line">            |-traverseAllChildrenImpl()  &lt;------|inner             |</span><br><span class="line">              |↻traverseAllChildrenImpl() ------|recursion         |</span><br><span class="line">                |-instantiateChild()                               |</span><br><span class="line">                  |-instantiateReactComponent()                    |</span><br><span class="line">      |↻ReactDOMComponent.mountComponent()      <span class="comment">// scr: -&gt; 1)(b)---|</span></span><br><span class="line">    |↻DOMLazyTree.queueChild()    <span class="comment">// scr: ---------------&gt; 2)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>First we examine the bottom of the (complex) stack that operates on the DOM level (by understanding the end purpose, we can be a bit relieved in facing the complex call graph).</p><h2 id="DOMLazyTree-queueText-and-DOMLazyTree-queueChild"><a href="#DOMLazyTree-queueText-and-DOMLazyTree-queueChild" class="headerlink" title="DOMLazyTree.queueText() and DOMLazyTree.queueChild()"></a><code>DOMLazyTree.queueText()</code> and <code>DOMLazyTree.queueChild()</code></h2><p><code>DOMLazyTree.queueText()</code> has only one effective line in this walk-through:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueText</span>(<span class="params">tree, text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (enableLazy) &#123; <span class="comment">// scr: NO, I mean, false</span></span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setTextContent(tree.node, text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queueText@renderers/dom/client/utils/DOMLazyTree.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> setTextContent = <span class="function"><span class="keyword">function</span> (<span class="params">node, text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (text) &#123;</span><br><span class="line">    <span class="keyword">var</span> firstChild = node.firstChild;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (firstChild &amp;&amp; firstChild === node.lastChild &amp;&amp; firstChild.nodeType === <span class="number">3</span>) &#123; <span class="comment">// scr: false</span></span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  node.textContent = text; <span class="comment">// scr: the only effective line</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTextContent@renderers/dom/client/utils/setTextContent.js</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent" target="_blank" rel="noopener">Node.textContent</a> is a DOM standard property that represents, well, text content of a node. Apparently, it is the end purpose of route {1}.</p><p><code>DOMLazyTree.queueChild()</code> has one line as well:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueChild</span>(<span class="params">parentTree, childTree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (enableLazy) &#123; <span class="comment">// scr: again, false</span></span><br><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parentTree.node.appendChild(childTree.node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queueChild@renderers/dom/client/utils/DOMLazyTree.js</span><br></pre></td></tr></table></figure><p>Here <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild" target="_blank" rel="noopener">Node.appendChild()</a> is yet another DOM standard API that inserts a node to another as child. Apparently, it is the last stop of route {2}.</p><p>Now we can replace these two methods with their respective essence line.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...                                          (outer recursion)</span><br><span class="line">ReactDOMComponent[<span class="number">6</span>].mountComponent()    &lt;-------------------------|</span><br><span class="line">  |-<span class="keyword">this</span>._createInitialChildren()                                  |</span><br><span class="line">  ?&#123;<span class="number">1</span>&#125;                                                             |</span><br><span class="line">    |-node.textContent = text;                                     |</span><br><span class="line">  ?&#123;<span class="number">2</span>&#125;                                                             |</span><br><span class="line">    |-<span class="keyword">this</span>.mountChildren()        <span class="comment">// scr: ---------------&gt; 1)(a)   |</span></span><br><span class="line">      |-<span class="keyword">this</span>._reconcilerInstantiateChildren()                      |</span><br><span class="line">        |-ReactChildReconciler.instantiateChildren()               |</span><br><span class="line">          |-traverseAllChildren()                                  |</span><br><span class="line">            |-traverseAllChildrenImpl()  &lt;------|inner             |</span><br><span class="line">              |↻traverseAllChildrenImpl() ------|recursion         |</span><br><span class="line">                |-instantiateChild()                               |</span><br><span class="line">                  |-instantiateReactComponent()                    |</span><br><span class="line">      |↻ReactDOMComponent.mountComponent() <span class="comment">// scr: ------&gt; 1)(b)---|</span></span><br><span class="line">    |↻node.appendChild()                   <span class="comment">// scr: ------&gt; 2)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Extrapolate-the-big-picture"><a href="#Extrapolate-the-big-picture" class="headerlink" title="Extrapolate the big picture"></a>Extrapolate the big picture</h2><p>To do so, we start from methods that we already know.</p><p>First, <code>instantiateReactComponent()</code> which instantiates a <code>ReactDOMComponent</code> from <code>ReactElement</code> (we do not have any “composite” <code>ReactElement</code> in the tree now so all the components being created are <code>ReactDOMComponent</code>s), which is also the end of the deeply nested call hierarchy {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-II/">post two</a>}</p><p>Second, <code>ReactDOMComponent.mountComponent()</code> which initializes the <code>ReactDOMComponents</code> created in the previous step and create the corresponding DOM nodes based on them. {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a>} &amp; {beginning}</p><p>Considering the above two operations an {OG} (operation group), it is now easier to explain how the rest of the <code>ReactElement</code> tree is processed.</p><p>Here is a high-level explanation:</p><ol><li><p>when outer recursion of <code>ReactDOMComponent.mountComponent()</code> is called for non-leaf node, branch {2} will be taken to trigger {OG} for each of the component’s children;</p></li><li><p>when outer recursion of <code>ReactDOMComponent.mountComponent()</code> is called for leaf node that contains text, branch {1} will be in action, which set <code>node.textContent</code>;</p></li><li><p>when outer recursion of <code>ReactDOMComponent.mountComponent()</code> is called for leaf node that does not contain text, <code>_createInitialChildren()</code> will not be called at all.</p></li></ol><p>Please note that in this process <code>ReactDOMComponent.mountComponent()</code> is used repeatedly to create DOM node for the respective <code>ReactDOMComponent</code> instance, so you might need to check its implementation in the beginning of this text if it is not in your (brain) cache.</p><p>It’s time to draw the call stack in action:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ReactDOMComponent[<span class="number">6</span>].mountComponent()</span><br><span class="line">  |-<span class="keyword">this</span>._createInitialChildren()</span><br><span class="line">    |-<span class="keyword">this</span>.mountChildren() </span><br><span class="line">...           |↻instantiateReactComponent()[<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">      |-ReactDOMComponent[<span class="number">5</span>].mountComponent()</span><br><span class="line">        |-<span class="keyword">this</span>._createInitialChildren()</span><br><span class="line">          |-node.textContent = text; <span class="comment">// scr: [5] done</span></span><br><span class="line">      |-ReactDOMComponent[<span class="number">4</span>].mountComponent()</span><br><span class="line">        |-<span class="keyword">this</span>._createInitialChildren()</span><br><span class="line">          |-<span class="keyword">this</span>.mountChildren() </span><br><span class="line">...                 |↻instantiateReactComponent()[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">          |-ReactDOMComponent[<span class="number">2</span>].mountComponent() <span class="comment">// scr: [2] done</span></span><br><span class="line">          |-ReactDOMComponent[<span class="number">3</span>].mountComponent()</span><br><span class="line">            |-<span class="keyword">this</span>._createInitialChildren()</span><br><span class="line">              |-node.textContent = text; <span class="comment">// scr: [3] done</span></span><br><span class="line">        |↻node[<span class="number">4</span>].appendChild()[<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// scr: [4] done</span></span><br><span class="line"></span><br><span class="line">    |↻node[<span class="number">6</span>].appendChild()[<span class="number">4</span>,<span class="number">5</span>] <span class="comment">// scr: [6] done</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>In this call stack I omit the deep nested call hierarchy that is used to instantiate the <code>ReactDOMComponent</code> from <code>ReactElement</code> as we are going to examine it next.</p><h2 id="The-deep-nested-loop-of-instantiateReactComponent"><a href="#The-deep-nested-loop-of-instantiateReactComponent" class="headerlink" title="The deep nested loop of instantiateReactComponent()"></a>The deep nested loop of <code>instantiateReactComponent()</code></h2><p>In particular, we need to pay attention to the arguments to keep track the input &amp; output across the fairly deep and complex chain that enlists recursion and callback.</p><p>Starting from inside <code>ReactDOMComponent._createInitialChildren()</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> mountImages = <span class="keyword">this</span>.mountChildren(</span><br><span class="line">  childrenToUse, <span class="comment">// scr:----------&gt; ReactElement[6].props.children</span></span><br><span class="line">  transaction,   <span class="comment">// scr: not of interest</span></span><br><span class="line">  context        <span class="comment">// scr: not of interest</span></span><br><span class="line">);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Next we look at the implementation of <code>ReactDOMComponent.mountChildren()</code>. As mentioned before, it 1) instantiates all the children of <code>ReactDOMComponents</code>; and 2) initializes those <code>ReactDOMComponent</code> by calling <code>ReactDOMComponent.mountComponent()</code>.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mountChildren: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nestedChildren, <span class="regexp">//</span> scr:----------&gt; ReactElement[<span class="number">6</span>].props.children</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,    <span class="regexp">//</span> scr: not of interest</span></span></span><br><span class="line"><span class="function"><span class="params">  context         <span class="regexp">//</span> scr: not of interest</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// scr: ------------------------------------------------------&gt; 1)</span></span><br><span class="line">  <span class="keyword">var</span> children = <span class="keyword">this</span>._reconcilerInstantiateChildren(nestedChildren, transaction, context);</span><br><span class="line">  <span class="keyword">this</span>._renderedChildren = children;</span><br><span class="line">  <span class="keyword">var</span> mountImages = [];</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> children) &#123;</span><br><span class="line">    <span class="keyword">if</span> (children.hasOwnProperty(name)) &#123;</span><br><span class="line">      <span class="keyword">var</span> child = children[name];</span><br><span class="line">      <span class="keyword">var</span> selfDebugID = <span class="number">0</span>;</span><br><span class="line">...<span class="comment">// scr: DEV code</span></span><br><span class="line">                                                   (outer recursion)      </span><br><span class="line">      <span class="comment">// scr: --------------------------------------------------&gt; 2)</span></span><br><span class="line">      <span class="keyword">var</span> mountImage = ReactReconciler.mountComponent(child, transaction, <span class="keyword">this</span>, <span class="keyword">this</span>._hostContainerInfo, context, selfDebugID);</span><br><span class="line">      </span><br><span class="line">      child._mountIndex = index++;</span><br><span class="line">      mountImages.push(mountImage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...<span class="comment">// scr: DEV code</span></span><br><span class="line">  <span class="keyword">return</span> mountImages;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactDOMComponent@renderers/dom/shared/ReactDOMComponent.js</span><br></pre></td></tr></table></figure><p>2) was referred to as “outer recursion” before and is yet another <code>ReactReconciler.mountComponent()</code> {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-II/">post two</a>}, so we focus on 1)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_reconcilerInstantiateChildren: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nestedChildren, <span class="regexp">//</span> scr:----------&gt; ReactElement[<span class="number">6</span>].props.children</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,    <span class="regexp">//</span> scr: not of interest</span></span></span><br><span class="line"><span class="function"><span class="params">  context         <span class="regexp">//</span> scr: not of interest</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">...<span class="comment">// scr: DEV code</span></span><br><span class="line">  <span class="keyword">return</span> ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ReactMultiChild@renderers/shared/stack/reconciler/ReactMultiChild.js</span><br></pre></td></tr></table></figure><p>which is a direct call of</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">instantiateChildren: <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  nestedChildNodes, <span class="regexp">//</span> scr: --------&gt; ReactElement[<span class="number">6</span>].props.children</span></span></span><br><span class="line"><span class="function"><span class="params">  transaction,      <span class="regexp">//</span> scr: not of interest</span></span></span><br><span class="line"><span class="function"><span class="params">  context,          <span class="regexp">//</span> scr: not of interest</span></span></span><br><span class="line"><span class="function"><span class="params">  selfDebugID</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) // 0 <span class="title">in</span> <span class="title">production</span> <span class="title">and</span> <span class="title">for</span> <span class="title">roots</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nestedChildNodes == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> childInstances = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: DEV code</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> childInstances;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">instantiateChildren@renderers/shared/stack/reconciler/ReactChildReconciler.js</span><br></pre></td></tr></table></figure><p>which is, again, a direct call to <code>traverseAllChildren()</code>. Note that <code>instantiateChild</code> is the callback method which is invoked for each child.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiateChild</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  childInstances, <span class="regexp">//</span> scr: ---&gt; the output parameter childInstances is passed all the way down here</span></span></span><br><span class="line"><span class="function"><span class="params">  child,      <span class="regexp">//</span> scr: --&gt; a ReactElement</span></span></span><br><span class="line"><span class="function"><span class="params">  name,       <span class="regexp">//</span> scr: --&gt; unique name for indexing in childInstances</span></span></span><br><span class="line"><span class="function"><span class="params">  selfDebugID <span class="regexp">//</span> scr: --&gt; undefined</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">... <span class="comment">// scr: DEV code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="literal">null</span> &amp;&amp; keyUnique) &#123;</span><br><span class="line">    childInstances[name] = instantiateReactComponent(child, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">instantiateChild@renderers/shared/stack/reconciler/ReactChildReconciler.js</span><br></pre></td></tr></table></figure><p>It in turn calls <code>instantiateReactComponent()</code> {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-I/">post one</a>} directly.</p><p>We move on to <code>traverseAllChildren()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children, <span class="regexp">//</span> scr: ---------&gt; ReactElement[<span class="number">6</span>].props.children</span></span></span><br><span class="line"><span class="function"><span class="params">  callback, <span class="regexp">//</span> scr: ---------&gt; instantiateChild</span></span></span><br><span class="line"><span class="function"><span class="params">  traverseContext <span class="regexp">//</span> scr: ---&gt; output parameter, initialized as &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> traverseAllChildrenImpl(children, <span class="string">''</span>, callback, traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">traverseAllChildren@shared/utils/traverseAllChildren.js</span><br></pre></td></tr></table></figure><p>yet another direct call to <code>traverseAllChildrenImpl()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traverseAllChildrenImpl</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  children,  <span class="regexp">//</span> scr: ---------&gt; ReactElement[<span class="number">6</span>].props.children</span></span></span><br><span class="line"><span class="function"><span class="params">  nameSoFar, <span class="regexp">//</span> scr: ---------&gt; <span class="string">''</span></span></span></span><br><span class="line"><span class="function"><span class="params">  callback,  <span class="regexp">//</span> scr: ---------&gt; instantiateChild</span></span></span><br><span class="line"><span class="function"><span class="params">  traverseContext <span class="regexp">//</span> scr: ---&gt; output parameter, initialized as &#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> children;</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'undefined'</span> || type === <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    <span class="comment">// All of the above are perceived as null.</span></span><br><span class="line">    children = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// scr: -------------------------------------------------------&gt; &#123;a&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (children === <span class="literal">null</span> || type === <span class="string">'string'</span> || type === <span class="string">'number'</span> || type === <span class="string">'object'</span> &amp;&amp; children.$$<span class="keyword">typeof</span> === REACT_ELEMENT_TYPE) &#123;</span><br><span class="line">    callback(traverseContext, children,</span><br><span class="line">    <span class="comment">// If it's the only child, treat the name as if it was wrapped in an array</span></span><br><span class="line">    <span class="comment">// so that it's consistent if the number of children grows.</span></span><br><span class="line">    nameSoFar === <span class="string">''</span> ? SEPARATOR + getComponentKey(children, <span class="number">0</span>) : nameSoFar);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> child;</span><br><span class="line">  <span class="keyword">var</span> nextName;</span><br><span class="line">  <span class="keyword">var</span> subtreeCount = <span class="number">0</span>; <span class="comment">// Count of children found in the current subtree.</span></span><br><span class="line">  <span class="keyword">var</span> nextNamePrefix = nameSoFar === <span class="string">''</span> ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"><span class="comment">// scr: -------------------------------------------------------&gt; &#123;b&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, i);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">... <span class="comment">// scr: this branch will not be called here</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> subtreeCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">traverseAllChildrenImpl@shared/utils/traverseAllChildren.js</span><br></pre></td></tr></table></figure><p>After those directly one-line calls of another method, <code>traverseAllChildrenImpl()</code> is the true workhouse. this method was also referred to as “inner recursion” soon before.</p><p>The logic of <code>traverseAllChildrenImpl()</code> is quite straight forward: when it is called the first time (and the type of <code>children</code> parameter is <code>array</code>), it calls itself for every <code>ReactElement</code> within the array; when it is called successively (<code>children</code> is <code>ReactElement</code>), it invokes the aforementioned callback that internally relies on <code>instantiateReactComponent()</code> {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-I/">post one</a>} to transform a <code>ReactElement</code> to an empty and uninitialized <code>ReactDOMComonent</code>.</p><blockquote><p>Note that “inner recursion” works on DIRECT children only while the “outer recursion” traverse the ENTIRE <code>ReactElement</code> tree.</p></blockquote><p>After all the <code>ReactElements</code> are transformed to <code>ReactDOMComonent</code>s, the output is returned all the way back to <code>ReactDOMComponent.mountChildren()</code> and complete the circle.</p><blockquote><p>To better understand the full circle, you might need to refer to different pieces of the puzzle back and forth, for example, the beginning of this text where <code>ReactDOMComponent.mountComponent()</code> is discussed; the two DOM operations (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild" target="_blank" rel="noopener">Node.appendChild</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent" target="_blank" rel="noopener">Node.textContent</a>) that define the stack bottom; the discussion of the big picture; as well as this section.</p></blockquote><p>At last, after all the DOM nodes are generated, the logic returns back to <code>ReactReconciler.mountComponent()</code> and the new node tree is inserted to the designated <code>div</code> container. {<a href="http://holmeshe.me/understanding-react-js-source-code-initial-rendering-III/">post three</a>}</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">|~mountComponentIntoNode()                                    |</span><br><span class="line">  |-ReactReconciler.mountComponent()                          |</span><br><span class="line">    |-ReactCompositeComponent[T].mountComponent()             |</span><br><span class="line">      |-ReactCompositeComponent[T].performInitialMount()  upper half</span><br><span class="line">        |-ReactReconciler.mountComponent()                    |</span><br><span class="line">          |-ReactCompositeComponent[ins].mountComponent()     |</span><br><span class="line">            |-<span class="keyword">this</span>.performInitialMount()                      |</span><br><span class="line">              |-<span class="keyword">this</span>._renderValidatedComponent()              |</span><br><span class="line">              |-instantiateReactComponent()                  _|_ </span><br><span class="line">              |-ReactDOMComponent[<span class="number">6</span>].mountComponent(          |</span><br><span class="line">                  transaction, <span class="comment">// scr: -----&gt; not of interest |</span></span><br><span class="line">                  hostParent,  <span class="comment">// scr: -----&gt; null            |</span></span><br><span class="line">                  hostContainerInfo,<span class="comment">// scr:---------------------&gt; ReactDOMContainerInfo[ins]                                    | </span></span><br><span class="line">                  context      <span class="comment">// scr: -----&gt; not of interest |</span></span><br><span class="line">                )                                             |</span><br><span class="line">                                                              |</span><br><span class="line">... <span class="comment">// the content of this section                        lower half</span></span><br><span class="line">        |-_mountImageIntoNode()                  (HTML DOM specific)</span><br><span class="line">            markup,    <span class="comment">// scr: --&gt; DOMLazyTree[ins]           |</span></span><br><span class="line">            container, <span class="comment">// scr: --&gt; document.getElementById(‘root’)</span></span><br><span class="line">            wrapperInstance, <span class="comment">// scr:----&gt; same                |</span></span><br><span class="line">            shouldReuseMarkup, <span class="comment">// scr:--&gt; same                |</span></span><br><span class="line">            transaction, <span class="comment">// scr: -------&gt; same                |</span></span><br><span class="line">          )                                                  _|_</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Last time we completed the upper half of the class component rendering logic which is similar to albeit different from simple component rendering in the following respects: 1) it instantiates one additional &lt;code&gt;ReactCompositeComponent&lt;/code&gt; to represent the class component (&lt;code&gt;App&lt;/code&gt;); and 2) it calls &lt;code&gt;App.render()&lt;/code&gt; that triggers cascading &lt;code&gt;React.createElement()&lt;/code&gt;s to establish a &lt;code&gt;ReactElement&lt;/code&gt; tree.&lt;/p&gt;
&lt;p&gt;This time we are going to explore more branches in lower half by examining how the &lt;code&gt;ReactElements&lt;/code&gt; in the tree is transformed to their respective &lt;code&gt;ReactDOMComponents&lt;/code&gt;, and eventually, to real DOM objects.&lt;/p&gt;
    
    </summary>
    
      <category term="Understanding The React Source Code" scheme="https://holmeshe.me/categories/Understanding-The-React-Source-Code/"/>
    
    
      <category term="JavaScript" scheme="https://holmeshe.me/tags/JavaScript/"/>
    
      <category term="react" scheme="https://holmeshe.me/tags/react/"/>
    
      <category term="react.js" scheme="https://holmeshe.me/tags/react-js/"/>
    
      <category term="programming" scheme="https://holmeshe.me/tags/programming/"/>
    
      <category term="code" scheme="https://holmeshe.me/tags/code/"/>
    
  </entry>
  
</feed>
