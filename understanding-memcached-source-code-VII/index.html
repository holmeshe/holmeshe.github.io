<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Holmes He</title>

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="socketmemcachedevent drivenstate machinemultithreading">
  
  
  
  
  <meta name="description" content="In classic multithreading, large amounts of slow and blocking operations, mostly, I/O, can easily drain out available thread resources, which severely constrains the maximum number of requests a serve">
<meta name="keywords" content="socket,memcached,event driven,state machine,multithreading">
<meta property="og:type" content="article">
<meta property="og:title" content="Understanding The Memcached Source Code - Event Driven I">
<meta property="og:url" content="https://holmeshe.me/understanding-memcached-source-code-VII/index.html">
<meta property="og:site_name" content="Holmes He">
<meta property="og:description" content="In classic multithreading, large amounts of slow and blocking operations, mostly, I/O, can easily drain out available thread resources, which severely constrains the maximum number of requests a serve">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://holmeshe.me/gallery/spade.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/heart.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/club.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/diamond.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/mem-thread.png">
<meta property="og:image" content="https://holmeshe.me/gallery/threads-comm.png">
<meta property="og:updated_time" content="2020-12-22T10:48:38.121Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Understanding The Memcached Source Code - Event Driven I">
<meta name="twitter:description" content="In classic multithreading, large amounts of slow and blocking operations, mostly, I/O, can easily drain out available thread resources, which severely constrains the maximum number of requests a serve">
<meta name="twitter:image" content="https://holmeshe.me/gallery/spade.svg">
  
  <link rel="icon" href="/gallery/air-balloon.svg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   
>
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Code Talks" src=" /gallery/air-balloon.svg">
              </a>
            
          </h1>
          
          <div class="site-description">
            \{C}0de<t>a1k(s) =>
            <text id="message">
              
            </text>
            ( ͡° ͜ʖ ͡°)
            <a class='ext-link' href="/atom.xml">
              <i class="fas fa-rss fa-lg"></i>
            </a>
          </div>
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Series</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-understanding-memcached-source-code-VII" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Understanding The Memcached Source Code - Event Driven I
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/understanding-memcached-source-code-VII/" class="article-date">
	  <time datetime="2019-01-17T20:00:00.000Z" itemprop="datePublished">January 18, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Memcached-Source-Code/">Memcached Source Code</a>
 
      
    </div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p>
<p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p>
<p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I - this article</text></a> <a href="/understanding-memcached-source-code-VIII/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p>
<p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent harsh (not complete)</text></a> for data distribution,</p>
<p>are built around it.</p>
<p>In classic <em>multithreading</em>, large amounts of slow and blocking operations, mostly, I/O, can easily drain out available thread resources, which severely constrains the maximum number of requests a server can handle per unit time. More specific, threads are scheduled out and put into sleep in the middle of procedures that contain blocking I/O, despite piling up requests packets queuing within the network stack. In such situation, server side will show low throughput, low CPU saturation and high latency. </p>
<a id="more"></a>
<p class="back"><br>Here is a <a href="https://hackernoon.com/back-end-performance-those-metrics-we-care-about-ade678e87969" target="_blank" rel="noopener">post</a> around server side performance. Feel free to check it out.<br></p>

<h1 id="An-introduction-to-event-driven"><a href="#An-introduction-to-event-driven" class="headerlink" title="An introduction to event driven"></a>An introduction to event driven</h1><p>This is where asynchronous <strong>event driven</strong> model comes in, which drops the idea that <em>context</em> of a <em>session</em> must be coupled with a thread. In such model, <em>session</em> contexts are contained within and managed by a <strong>drive machine</strong> and a thread is fully unleashed with unblocking I/O operations. More specific, 1) when I/O occurs in the middle of a procedure, a thread does not block but instantly switch to the processing of another <em>request</em>; and 2) when the I/O completes, the <em>context</em> will be picked up by the <strong>drive machine</strong> to resume the interrupted <em>session</em>. As such, a potentially slow procedure is effectively divided into multiple manageable pieces, and the cutting points are marked by I/O operations. This results in more performant single threaded architecture in comparison to those employ thousands of threads.</p>
<p class="back"><br>In my understanding, <strong>event driven</strong> model, in its essential, is yet another instance of “divide and conquer” and “trade space for time” in a not very obvious way.<br></p>

<p>On the other hand, <em>multithreading</em> can be still used in <strong>event driven</strong> model purely for the purpose of parallelism. Thus, in practice, the number of threads employed does not exceed that of CPU cores. I will discuss the <strong>Memcached</strong> <em>multithreading</em> soon in <a href="#Thread-model">Thread model</a>.</p>
<h1 id="The-drive-machine"><a href="#The-drive-machine" class="headerlink" title="The drive machine"></a>The drive machine</h1><p>From a developer’s point of view, there are numerous ways to program an asynchronous <strong>even driven</strong> server. <strong>Memcached</strong> adopts an approach called <em>state machine</em>, in which logic flow is divided into non-linear fragments identified with <strong>state</strong>s, which is normally controled by a huge <code>switch case</code>. The brightside of this approach is that the mentioned breakdown of slow procedure is sincerely reflected by the logic fragments. But it makes the code style a bit different from what most developers are already used to.</p>
<p>Following is how the event <strong>drive</strong>n state <strong>machine</strong> actually looks like.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> addrlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> nreqs = settings.reqs_per_event;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(c-&gt;state) &#123;</span><br><span class="line">        <span class="keyword">case</span> conn_listening:</span><br><span class="line">            addrlen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">...</span><br><span class="line">            sfd = accept(c-&gt;sfd, (struct sockaddr *)&amp;addr, &amp;addrlen);</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (sfd == <span class="number">-1</span>) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (settings.maxconns_fast &amp;&amp;</span><br><span class="line">                stats_state.curr_conns + stats_state.reserved_fds &gt;= settings.maxconns - <span class="number">1</span>) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,</span><br><span class="line">                                     DATA_BUFFER_SIZE, c-&gt;transport);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_waiting:</span><br><span class="line">...</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_read:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_parse_cmd :</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_new_cmd:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_nread:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_swallow:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_write:</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_closing:</span><br><span class="line">            <span class="keyword">if</span> (IS_UDP(c-&gt;transport))</span><br><span class="line">                conn_cleanup(c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                conn_close(c);</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_closed:</span><br><span class="line">            <span class="comment">/* This only happens if dormando is an idiot. */</span></span><br><span class="line">            <span class="built_in">abort</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> conn_watch:</span><br><span class="line">            <span class="comment">/* We handed off our connection to the logger thread. */</span></span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> conn_max_state:</span><br><span class="line">            assert(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">drive_machine@memcached.c</text></center>
<p>The omitted switch blocks will be discussed in detail in following posts, so no worries.</p>
<h1 id="Thread-model"><a href="#Thread-model" class="headerlink" title="Thread model"></a>Thread model</h1><p>The thread model of <strong>Memcached</strong> is quite standard. There is a <em>dispatcher thread</em>, and there are preconfigured number of <em>worker thread</em>s. Each thread runs an independent <strong>drive machine</strong> described above. The <em>dispatcher thread</em>, of which the responsible is to distribute <em>request</em>s among <em>worker thread</em>s, only executes code under <code>conn_listening</code>. The actual requests are completed by <em>worker thread</em>s running on the rest of the <strong>state</strong>s.</p>
<p><img src="/gallery/mem-thread.png" alt="Thread model"></p>
<p>Next we go through the bootstrap portion of <code>main</code> function which establishes the various building blocks of <strong>event driven</strong> as well as the <em>multithreading</em> mechanism. And we will also see locations of the discussed sub-system <code>***_init</code> methods in relation to the whole initialization process.</p>
<p>First thing first, all the <em>system initialization</em> relevant procedures are executed in the discussed <em>dispatcher thread</em>.</p>
<p>The call stack of this process is</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">|-main</span><br><span class="line">  |-hash_init          (LRU II)</span><br><span class="line">  |-assoc_init         (LRU II)</span><br><span class="line">  |-conn_init</span><br><span class="line">  |-slabs_init         (Slab I)</span><br><span class="line">  |-memcached_thread_init</span><br><span class="line">    |-setup_thread</span><br><span class="line">    |-create_worker</span><br><span class="line">  |-server_sockets</span><br><span class="line">    |-new_socket</span><br><span class="line">    |-conn_new</span><br></pre></td></tr></table></figure>
<h1 id="System-initialization"><a href="#System-initialization" class="headerlink" title="System initialization"></a>System initialization</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">...<span class="comment">// scr: -----------------------------------------------------&gt; *)</span></span><br><span class="line">...<span class="comment">// scr: initialize `settings` using default values and command line arguements</span></span><br><span class="line">...<span class="comment">// scr: sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hash_init(hash_type) != <span class="number">0</span>) &#123; <span class="comment">// scr: ---------------&gt; LRU II</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to initialize hash_algorithm!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EX_USAGE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: initialize `settings` &amp; sanity check</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxcore != <span class="number">0</span>) &#123; <span class="comment">// scr: --------------------------------&gt; 1)</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim_new</span>;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * First try raising to infinity; if that fails, try bringing</span></span><br><span class="line"><span class="comment">         * the soft limit to the hard.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (getrlimit(RLIMIT_CORE, &amp;rlim) == <span class="number">0</span>) &#123;</span><br><span class="line">            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;</span><br><span class="line">            <span class="keyword">if</span> (setrlimit(RLIMIT_CORE, &amp;rlim_new)!= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* failed. try raising just to the old max */</span></span><br><span class="line">                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;</span><br><span class="line">                (<span class="keyword">void</span>)setrlimit(RLIMIT_CORE, &amp;rlim_new);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * getrlimit again to see what we ended up with. Only fail if</span></span><br><span class="line"><span class="comment">         * the soft limit ends up 0, because then no core files will be</span></span><br><span class="line"><span class="comment">         * created at all.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((getrlimit(RLIMIT_CORE, &amp;rlim) != <span class="number">0</span>) || rlim.rlim_cur == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to ensure corefile creation\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rlim) != <span class="number">0</span>) &#123; <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to getrlimit number of files\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rlim.rlim_cur = settings.maxconns;</span><br><span class="line">        rlim.rlim_max = settings.maxconns;</span><br><span class="line">        <span class="keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;rlim) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to set rlimit for open files. Try starting as root or requesting smaller maxconns value.\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: -----------------------------------------------------&gt; *)</span></span><br><span class="line"></span><br><span class="line">    main_base = event_init(); <span class="comment">// scr: --------------------------&gt; 2)</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">    assoc_init(settings.hashpower_init); <span class="comment">// scr: -----------&gt; LRU II</span></span><br><span class="line">    conn_init(); <span class="comment">// scr: ---------------------------------------&gt; 3)</span></span><br><span class="line">    slabs_init(settings.maxbytes, settings.factor, preallocate,</span><br><span class="line">            use_slab_sizes ? slab_sizes : <span class="literal">NULL</span>); <span class="comment">// scr: ---&gt; Slab I</span></span><br><span class="line">...</span><br><span class="line">    memcached_thread_init(settings.num_threads, main_base); <span class="comment">//scr:4)</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: maintainer threads initialization</span></span><br><span class="line">...<span class="comment">// scr: unix socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the listening socket, bind it, and init */</span></span><br><span class="line">    <span class="keyword">if</span> (settings.socketpath == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        <span class="keyword">if</span> (portnumber_filename != <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        errno = <span class="number">0</span>; <span class="comment">// scr: -------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.port &amp;&amp; server_sockets(settings.port, tcp_transport,</span><br><span class="line">                                           portnumber_file)) &#123;</span><br><span class="line">            vperror(<span class="string">"failed to listen on TCP port %d"</span>, settings.port);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        errno = <span class="number">0</span>; <span class="comment">// scr: -------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.udpport &amp;&amp; server_sockets(settings.udpport, udp_transport,</span><br><span class="line">                                              portnumber_file)) &#123;</span><br><span class="line">            vperror(<span class="string">"failed to listen on UDP port %d"</span>, settings.udpport);</span><br><span class="line">            <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (portnumber_file) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">1000</span>);</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (event_base_loop(main_base, <span class="number">0</span>) != <span class="number">0</span>) &#123; <span class="comment">// scr: ----------&gt; 6)</span></span><br><span class="line">        retval = EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: finalization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">main@memcached.c</text></center>
<p>The two relevant steps are 4) and 5) which will be discussed in the  following sections.</p>
<p>1) Raise the limit for core dump file size as well as the number of file descriptors.</p>
<p>2) Call <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6" target="_blank" rel="noopener">event_init</a> to initialize the <strong>libevent</strong> framework. The value returned is called an <em>event base</em>.</p>
<p>3) For all potential connections, call <a href="#" onclick="return false;" data-toggle="collapse" data-target="#conn_init">conn_init</a> to allocate space to store their respective <em>context</em>s (located using file descriptor in global variable <code>conns</code>). The role of <em>context</em> in <strong>event driven</strong> model has already been discussed in <a href="#An-introduction-to-event-driven">introduction</a>.</p>
<div id="conn_init" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rl) == <span class="number">0</span>) &#123;</span><br><span class="line">        max_fds = rl.rlim_max;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to query maximum file descriptor; "</span></span><br><span class="line">                        <span class="string">"falling back to maxconns\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((conns = <span class="built_in">calloc</span>(max_fds, <span class="keyword">sizeof</span>(conn *))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to allocate connection structures\n"</span>);</span><br><span class="line">        <span class="comment">/* This is unrecoverable so bail out early. */</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">conn_init@memcached.c</text></center><br></div>

<p>4) Preallocate threads and their associated resources using <a href="#memcached-thread-init">memcached_thread_init</a>.</p>
<p>5) Setup the socket and first event listener - <code>conn_listening</code>.</p>
<p>6) Call <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event_8h.html#a76e311cff042dab77125e309315a0617" target="_blank" rel="noopener">event_base_loop</a> to start the <strong>event loop</strong>.</p>
<p>*) Other miscellaneous system operations, such as setting the signal handler for <code>SIGINT</code> and <code>SIGTERM</code>; <code>setbuf</code> <code>stderr</code> to <code>NULL</code>; dropping the root privileges of the process; and daemonizing. If those names do not ring a bell, $\lt$$\lt$Advanced UNIX Programming$\gt$$\gt$ is your friend.</p>
<h1 id="Threads-initialization"><a href="#Threads-initialization" class="headerlink" title="Threads initialization"></a>Threads initialization</h1><p>The core data structure of <em>multithreading</em> mechanism is</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> thread_id;        <span class="comment">/* unique ID of this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span>    <span class="comment">/* libevent handle this thread uses */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">notify_event</span>;</span>  <span class="comment">/* listen event for notify pipe */</span></span><br><span class="line">    <span class="keyword">int</span> notify_receive_fd;      <span class="comment">/* receiving end of notify pipe */</span></span><br><span class="line">    <span class="keyword">int</span> notify_send_fd;         <span class="comment">/* sending end of notify pipe */</span></span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">conn_queue</span> *<span class="title">new_conn_queue</span>;</span> <span class="comment">/* queue of new connections to handle */</span></span><br><span class="line">...<span class="comment">// scr: cas &amp; log</span></span><br><span class="line">&#125; LIBEVENT_THREAD;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">LIBEVENT_THREAD@memcached.h</text></center>
<h2 id="memcached-thread-init"><a href="#memcached-thread-init" class="headerlink" title="memcached_thread_init"></a>memcached_thread_init</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memcached_thread_init</span><span class="params">(<span class="keyword">int</span> nthreads, struct event_base *main_base)</span> </span>&#123;</span><br><span class="line">...<span class="comment">// scr: initialize all sorts of mutexes and condition variables</span></span><br><span class="line"></span><br><span class="line">    threads = <span class="built_in">calloc</span>(nthreads, <span class="keyword">sizeof</span>(LIBEVENT_THREAD)); <span class="comment">// scr:  1)</span></span><br><span class="line">    <span class="keyword">if</span> (! threads) &#123;</span><br><span class="line">        perror(<span class="string">"Can't allocate thread descriptors"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatcher_thread.base = main_base; <span class="comment">// scr: ----------------&gt; 2)</span></span><br><span class="line">    dispatcher_thread.thread_id = pthread_self(); <span class="comment">// scr: ------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (pipe(fds)) &#123; <span class="comment">// scr: -------------------------------&gt; 4)</span></span><br><span class="line">            perror(<span class="string">"Can't create notify pipe"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        threads[i].notify_receive_fd = fds[<span class="number">0</span>]; <span class="comment">// scr: ---------&gt; 4)</span></span><br><span class="line">        threads[i].notify_send_fd = fds[<span class="number">1</span>]; <span class="comment">// scr: ------------&gt; 4)</span></span><br><span class="line"></span><br><span class="line">        setup_thread(&amp;threads[i]); <span class="comment">// scr: ---------------------&gt; 5)</span></span><br><span class="line">        <span class="comment">/* Reserve three fds for the libevent base, and two for the pipe */</span></span><br><span class="line">        stats_state.reserved_fds += <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create threads after we've done all the libevent setup. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nthreads; i++) &#123;</span><br><span class="line">        create_worker(worker_libevent, &amp;threads[i]); <span class="comment">// scr: ---&gt; 6)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for all the threads to set themselves up before returning. */</span></span><br><span class="line">    pthread_mutex_lock(&amp;init_lock);</span><br><span class="line">    wait_for_thread_registration(nthreads);</span><br><span class="line">    pthread_mutex_unlock(&amp;init_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">conn_init@memcached.c</text></center>
<p>1) Allocate memory for an array of <a href="#Threads-initialization">LIBEVENT_THREAD</a>. The number of thread is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#num_threads">num_threads</a> Each element represents one thread. As described above, better the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#num_threads">num_threads</a> does not exceed the number of cores.</p>
<div id="num_threads" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.num_threads = <span class="number">4</span>;         <span class="comment">/* N workers */</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            settings.num_threads = atoi(optarg);</span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Number of threads must be greater than 0\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* There're other problems when you get above 64 threads.</span></span><br><span class="line"><span class="comment">             * In the future we should portably detect # of cores for the</span></span><br><span class="line"><span class="comment">             * default.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (settings.num_threads &gt; <span class="number">64</span>) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"WARNING: Setting a high number of worker"</span></span><br><span class="line">                                <span class="string">"threads is not recommended.\n"</span></span><br><span class="line">                                <span class="string">" Set this value to the number of cores in"</span></span><br><span class="line">                                <span class="string">" your machine or less.\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">num_threads@memcached.c</text></center><br></div>

<p>2) Set the <em>event base</em> for the <a href="#" onclick="return false;" data-toggle="collapse" data-target="#dispatcher_thread">dispatcher_thread</a> which represents the main thread itself. Note that <a href="#" onclick="return false;" data-toggle="collapse" data-target="#dispatcher_thread">dispatcher_thread</a> is a global variable so the reference is accessible to all the <em>worker thread</em>s.</p>
<div id="dispatcher_thread" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> LIBEVENT_DISPATCHER_THREAD dispatcher_thread;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">dispatcher_thread@thread.c</text></center><br></div>

<p>3) Set the thread id for <a href="#" onclick="return false;" data-toggle="collapse" data-target="#dispatcher_thread">dispatcher_thread</a>.</p>
<p>4) Initialize the <a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a> <code>fd</code>s for each of the <em>worker thread</em>. Here the <code>notify_send_fd</code> is used for communication between <em>dispatcher thread</em> and <em>worker thread</em>s - whenever the <em>dispatcher thread</em> <a href="http://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener">write</a>s to <code>notify_send_fd</code>, an <strong>event</strong> is generated on the other side, <code>notify_receive_fd</code>, which is listened by <em>worker thread</em>s. Again, $\lt$$\lt$Advanced UNIX Programming$\gt$$\gt$ gives more information about <code>pipe</code>.</p>
<p>5) The full method name is supposed to be <code>setup_libevent_for_each_thread</code>. Will examine this method in the <a href="#setup-thread">next section</a>.</p>
<p>6) Call <a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html" target="_blank" rel="noopener">pthread_create</a> to create the actual <em>worker threads</em>. Will examine this method in <a href="#create-worker">create_worker</a>.</p>
<h2 id="setup-thread"><a href="#setup-thread" class="headerlink" title="setup_thread"></a>setup_thread</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_thread</span><span class="params">(LIBEVENT_THREAD *me)</span> </span>&#123;</span><br><span class="line">    me-&gt;base = event_init(); <span class="comment">// scr: ---------------------------&gt; 1)</span></span><br><span class="line">    <span class="keyword">if</span> (! me-&gt;base) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't allocate event base\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Listen for notifications from other threads */</span></span><br><span class="line">    event_set(&amp;me-&gt;notify_event, me-&gt;notify_receive_fd, <span class="comment">// scr: &gt; 2)</span></span><br><span class="line">              EV_READ | EV_PERSIST, thread_libevent_process, me);</span><br><span class="line">    event_base_set(me-&gt;base, &amp;me-&gt;notify_event); <span class="comment">// scr: -------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event_add(&amp;me-&gt;notify_event, <span class="number">0</span>) == <span class="number">-1</span>) &#123; <span class="comment">// scr: -------&gt; 2)</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't monitor libevent notify pipe\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me-&gt;new_conn_queue = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct conn_queue)); <span class="comment">//scr:3)</span></span><br><span class="line">    <span class="keyword">if</span> (me-&gt;new_conn_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"Failed to allocate memory for connection queue"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    cq_init(me-&gt;new_conn_queue);</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: stat &amp; cas</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">setup_thread@thread.c</text></center>
<p>1) Call <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event__compat_8h.html#aa72d84e78eb6f08dc580e6245c087cb6" target="_blank" rel="noopener">event_init</a> to initialize the <strong>libevent</strong> instance for the <em>worker thread</em>. As discussed in <a href="#Thread-model">thread model</a>, each <em>worker thread</em> runs its own <strong>drive machine</strong>.</p>
<p>2) Set the <code>thread_libevent_process</code> as the callback of events emitted from the discussed <code>notify_receive_fd</code>. The major function of <code>thread_libevent_process</code> is to link the actual <strong>drive machine</strong> to <strong>event</strong>s, which we will see very soon in <a href="#thread-libevent-process">inter-thread communication</a>.</p>
<p>3) Allocate and initialize the connection queue of the <em>worker thread</em>.</p>
<h2 id="create-worker"><a href="#create-worker" class="headerlink" title="create_worker"></a>create_worker</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create_worker</span><span class="params">(<span class="keyword">void</span> *(*func)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span>  attr;</span><br><span class="line">    <span class="keyword">int</span>             ret;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = pthread_create(&amp;((LIBEVENT_THREAD*)arg)-&gt;thread_id, &amp;attr, func, arg)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't create thread: %s\n"</span>,</span><br><span class="line">                strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">create_worker@thread.c</text></center>
<p>As mentioned, this method calls <a href="http://man7.org/linux/man-pages/man3/pthread_create.3.html" target="_blank" rel="noopener">pthread_create</a> to create the actual <em>worker thread</em>s. The callback passed through is <a href="#" onclick="return false;" data-toggle="collapse" data-target="#worker_libevent">worker_libevent</a> which essentially starts the <strong>event loop</strong> using <a href="http://www.wangafu.net/~nickm/libevent-2.1/doxygen/html/event_8h.html#a76e311cff042dab77125e309315a0617" target="_blank" rel="noopener">event_base_loop</a>, this time, on <em>worker thread</em>s rather than <em>dispatch thread</em>.</p>
<div id="worker_libevent" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">worker_libevent</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    LIBEVENT_THREAD *me = arg;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    event_base_loop(me-&gt;base, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">worker_libevent@thread.c</text></center><br></div>

<h1 id="Socket-initialization"><a href="#Socket-initialization" class="headerlink" title="Socket initialization"></a>Socket initialization</h1><p>The methods involved in socket initialization reconcile the initialization of both <em>TCP</em> and <em>UDP</em> while the following discussion covers only the <em>TCP</em> logic branch. And we consider <a href="#" onclick="return false;" data-toggle="collapse" data-target="#portnumber_file">portnumber_file</a> is not set so as to focus on the critical path.</p>
<div id="portnumber_file" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *portnumber_filename = getenv(<span class="string">"MEMCACHED_PORT_FILENAME"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (portnumber_filename != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(portnumber_filename)+<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">    temp_portnumber_filename = <span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="built_in">snprintf</span>(temp_portnumber_filename,</span><br><span class="line">             len,</span><br><span class="line">             <span class="string">"%s.lck"</span>, portnumber_filename);</span><br><span class="line"></span><br><span class="line">    portnumber_file = fopen(temp_portnumber_filename, <span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">if</span> (portnumber_file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to open \"%s\": %s\n"</span>,</span><br><span class="line">                temp_portnumber_filename, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:6029</text></center><br></div>

<p>Unlike <em>worker thread</em>s that listen to internal (<a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a>) <code>fd</code>s, <em>dispatch thread</em> is responsible for <strong>event</strong>s generated from external socket <code>fd</code>s (by network requests). The method that initializes sockets is <code>server_sockets</code>.</p>
<p>If network interface is not indicated by <a href="#" onclick="return false;" data-toggle="collapse" data-target="#inter">inter</a>, <a href="#" onclick="return false;" data-toggle="collapse" data-target="#server_sockets">server_sockets</a> is equivalent to</p>
<div id="inter" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.inter = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:209</text></center><br></div>

<div id="server_sockets" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">server_sockets</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">enum</span> network_transport transport,</span></span></span><br><span class="line"><span class="function"><span class="params">                          FILE *portnumber_file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (settings.inter == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> server_socket(settings.inter, port, transport, portnumber_file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">server_sockets@memcached.c</text></center><br></div>

<h2 id="server-socket"><a href="#server-socket" class="headerlink" title="server_socket"></a>server_socket</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">server_socket</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *interface,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">enum</span> network_transport transport,</span></span></span><br><span class="line"><span class="function"><span class="params">                         FILE *portnumber_file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">ling</span> = &#123;</span><span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">ai</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span> = &#123;</span> .ai_flags = AI_PASSIVE,</span><br><span class="line">                              .ai_family = AF_UNSPEC &#125;;</span><br><span class="line">    <span class="keyword">char</span> port_buf[NI_MAXSERV];</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="keyword">int</span> success = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flags =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">-1</span>) &#123;</span><br><span class="line">        port = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">snprintf</span>(port_buf, <span class="keyword">sizeof</span>(port_buf), <span class="string">"%d"</span>, port);</span><br><span class="line">    error= getaddrinfo(interface, port_buf, &amp;hints, &amp;ai); <span class="comment">// scr: 1)</span></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (next= ai; next; next= next-&gt;ai_next) &#123; <span class="comment">// scr: --------&gt; 2)</span></span><br><span class="line">        conn *listen_conn_add;</span><br><span class="line">        <span class="keyword">if</span> ((sfd = new_socket(next)) == <span class="number">-1</span>) &#123; <span class="comment">// scr: ----------&gt; 3)</span></span><br><span class="line">            <span class="comment">/* getaddrinfo can return "junk" addresses,</span></span><br><span class="line"><span class="comment">             * we make sure at least one works before erroring.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">                <span class="comment">/* ...unless we're out of fds */</span></span><br><span class="line">                perror(<span class="string">"server_socket"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EX_OSERR);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 4)</span></span><br><span class="line">        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</span><br><span class="line">        <span class="keyword">if</span> (IS_UDP(transport)) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">"setsockopt"</span>);</span><br><span class="line"></span><br><span class="line">            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (<span class="keyword">void</span> *)&amp;ling, <span class="keyword">sizeof</span>(ling));</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">"setsockopt"</span>);</span><br><span class="line"></span><br><span class="line">            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (<span class="keyword">void</span> *)&amp;flags, <span class="keyword">sizeof</span>(flags));</span><br><span class="line">            <span class="keyword">if</span> (error != <span class="number">0</span>)</span><br><span class="line">                perror(<span class="string">"setsockopt"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// scr: --------------------------------------------------------&gt; 5)</span></span><br><span class="line">        <span class="keyword">if</span> (bind(sfd, next-&gt;ai_addr, next-&gt;ai_addrlen) == <span class="number">-1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            success++;</span><br><span class="line">            <span class="keyword">if</span> (!IS_UDP(transport) &amp;&amp; listen(sfd, settings.backlog) == <span class="number">-1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (portnumber_file != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IS_UDP(transport)) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// scr: ---------------------------------------&gt; 6)</span></span><br><span class="line">            <span class="keyword">if</span> (!(listen_conn_add = conn_new(sfd, conn_listening,</span><br><span class="line">                                             EV_READ | EV_PERSIST, <span class="number">1</span>,</span><br><span class="line">                                             transport, main_base))) &#123;</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"failed to create listening connection\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            listen_conn_add-&gt;next = listen_conn; <span class="comment">// scr: -------&gt; 7)</span></span><br><span class="line">            listen_conn = listen_conn_add;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    freeaddrinfo(ai);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return zero iff we detected no errors in starting up connections */</span></span><br><span class="line">    <span class="keyword">return</span> success == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">server_socket@memcached.c</text></center>
<p>1) Get all the available network interfaces.</p>
<p>2) Iterate all the network interfaces and setup the sockets with the following steps.</p>
<p>3) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#new_socket">new_socket</a> encapsulates the operation of <a href="http://man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="noopener">socket</a> creation as well as that of setting it to non-block.</p>
<div id="new_socket" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">new_socket</span><span class="params">(struct addrinfo *ai)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((sfd = socket(ai-&gt;ai_family, ai-&gt;ai_socktype, ai-&gt;ai_protocol)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags = fcntl(sfd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span> ||</span><br><span class="line">        fcntl(sfd, F_SETFL, flags | O_NONBLOCK) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"setting O_NONBLOCK"</span>);</span><br><span class="line">        close(sfd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">new_socket@memcached.c</text></center><br></div>

<p>4) Tweak the newly created <a href="http://man7.org/linux/man-pages/man7/socket.7.html" target="_blank" rel="noopener">socket</a> <code>fd</code> using <a href="http://man7.org/linux/man-pages/man2/setsockopt.2.html" target="_blank" rel="noopener">setsockopt</a>, in which</p>
<p><code>SO_REUSEADDR</code> allows binding to a port in <code>TIME_WAIT</code>. This is useful for instantly rebooting a server on a “not fresh” TCP port;</p>
<p><code>SO_KEEPALIVE</code> sends heartbeats to detect an absent client, and to release the resource for network connection in both kernel and user space; <a href="/network-essentials-setsockopt-SO_KEEPALIVE/">learn more</a></p>
<p><code>SO_LINGER</code> enables fast close of a connection on <code>RST</code>; <a href="http://deepix.github.io/2016/10/21/tcprst.html" target="_blank" rel="noopener">learn more</a></p>
<p><code>TCP_NODELAY</code> disables <em>nagle</em> to improve latency. <a href="/network-essentials-setsockopt-TCP_NODELAY/">learn more</a></p>
<p>5) <a href="http://man7.org/linux/man-pages/man2/bind.2.html" target="_blank" rel="noopener">bind</a> and start <a href="http://man7.org/linux/man-pages/man2/listen.2.html" target="_blank" rel="noopener">listen</a>ing to the <code>fd</code>.</p>
<p>6) <a href="#" onclick="return false;" data-toggle="collapse" data-target="#conn_new">conn_new</a> initializes the <em>context</em> for the <code>fd</code> and adds it to <strong>libevent</strong> with initial <strong>state</strong> set to <code>conn_listening</code> and callback as <code>event_handler</code>. Here <code>event_handler</code> is another transient method leading to the <strong>drive machine</strong> on <em>dispatcher thread</em>. Likewise, this method will be discussed soon in <a href="#event-handler">inter-thread communication</a>.</p>
<div id="conn_new" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">conn *<span class="title">conn_new</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> sfd, <span class="keyword">enum</span> conn_states init_state,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">int</span> event_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> <span class="keyword">int</span> read_buffer_size, <span class="keyword">enum</span> network_transport transport,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct event_base *base)</span> </span>&#123;</span><br><span class="line">    conn *c;</span><br><span class="line">...<span class="comment">// scr: initialize context conn</span></span><br><span class="line">    c-&gt;state = init_state;</span><br><span class="line">...<span class="comment">// scr: initialize context conn</span></span><br><span class="line"></span><br><span class="line">    event_set(&amp;c-&gt;event, sfd, event_flags, event_handler, (<span class="keyword">void</span> *)c);</span><br><span class="line">    event_base_set(base, &amp;c-&gt;event);</span><br><span class="line">    c-&gt;ev_flags = event_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event_add(&amp;c-&gt;event, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">"event_add"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:120</text></center><br></div>

<p>7) Add the <em>context</em> to the head of a global list <a href="#" onclick="return false;" data-toggle="collapse" data-target="#listen_conn">listen_conn</a>.</p>
<div id="listen_conn" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">static</span> conn *listen_conn = <span class="literal">NULL</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:120</text></center><br></div>

<p>Next we briefly go through the process that handles a new connection to wrap up the</p>
<h1 id="Inter-thread-communication"><a href="#Inter-thread-communication" class="headerlink" title="Inter-thread communication"></a>Inter-thread communication</h1><p><img src="/gallery/threads-comm.png" alt="Inter-thread communication"></p>
<h2 id="event-handler"><a href="#event-handler" class="headerlink" title="event_handler"></a>event_handler</h2><p>Firstly, after a TCP connection completes, the <code>fd</code> monitored by <em>dispatcher thread</em> notifies <strong>libevent</strong>, which invokes the mentioned <a href="#" onclick="return false;" data-toggle="collapse" data-target="#event_handler">event_handler</a>. Next, the logic flow enters the code snippet we got in the beginning - the <strong>drive machine</strong>, with <em>context</em> <strong>state</strong> initialized as <code>conn_listening</code> in <a href="#Socket-initialization">socket initialization</a>.</p>
<div id="event_handler" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">event_handler</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> fd, <span class="keyword">const</span> short which, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    conn *c;</span><br><span class="line"></span><br><span class="line">    c = (conn *)arg;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    c-&gt;which = which;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* sanity */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    drive_machine(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait for next event */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">event_handler@memcached.c</text></center><br></div>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(c-&gt;state) &#123;</span><br><span class="line">        <span class="keyword">case</span> conn_listening:</span><br><span class="line">            addrlen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">...</span><br><span class="line">                  <span class="comment">// scr: --------------------------------------&gt; 1)</span></span><br><span class="line">            sfd = accept(c-&gt;sfd, (struct sockaddr *)&amp;addr, &amp;addrlen);</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (sfd == <span class="number">-1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (settings.maxconns_fast &amp;&amp;</span><br><span class="line">                stats_state.curr_conns + stats_state.reserved_fds &gt;= settings.maxconns - <span class="number">1</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// scr: ----------------------------------------&gt; 2)</span></span><br><span class="line">                dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,</span><br><span class="line">                                     DATA_BUFFER_SIZE, c-&gt;transport);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">drive_machine@memcached.c</text></center>
<p>At this stage, the <strong>drive machine</strong> 1) <a href="http://man7.org/linux/man-pages/man2/accept.2.html" target="_blank" rel="noopener">accept</a>s the connection and derives another <code>fd</code> that can be <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener">read</a> from. It 2) then calls <code>dispatch_conn_new</code> with the new <code>fd</code> and other relevant information including the next <strong>state</strong>, <code>conn_new_cmd</code>.</p>
<h2 id="dispatch-conn-new"><a href="#dispatch-conn-new" class="headerlink" title="dispatch_conn_new"></a>dispatch_conn_new</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_conn_new</span><span class="params">(<span class="keyword">int</span> sfd, <span class="keyword">enum</span> conn_states init_state, <span class="keyword">int</span> event_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> read_buffer_size, <span class="keyword">enum</span> network_transport transport)</span> </span>&#123;</span><br><span class="line">    CQ_ITEM *item = cqi_new();</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tid = (last_thread + <span class="number">1</span>) % settings.num_threads; <span class="comment">// scr: &gt; 1)</span></span><br><span class="line"></span><br><span class="line">    LIBEVENT_THREAD *thread = threads + tid; <span class="comment">// scr: -----------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">    last_thread = tid; <span class="comment">// scr: ---------------------------------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">    item-&gt;sfd = sfd; <span class="comment">// scr: -----------------------------------&gt; 2)</span></span><br><span class="line">    item-&gt;init_state = init_state;</span><br><span class="line">    item-&gt;event_flags = event_flags;</span><br><span class="line">    item-&gt;read_buffer_size = read_buffer_size;</span><br><span class="line">    item-&gt;transport = transport;</span><br><span class="line"></span><br><span class="line">    cq_push(thread-&gt;new_conn_queue, item); <span class="comment">// scr: -------------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    MEMCACHED_CONN_DISPATCH(sfd, thread-&gt;thread_id);</span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">'c'</span>;</span><br><span class="line">    <span class="keyword">if</span> (write(thread-&gt;notify_send_fd, buf, <span class="number">1</span>) != <span class="number">1</span>) &#123; <span class="comment">// scr: --&gt; 4)</span></span><br><span class="line">        perror(<span class="string">"Writing to thread notify pipe"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">dispatch_conn_new@thread.c</text></center>
<p>1) Round robin the threads established in <a href="#Threads-initialization">threads initialization</a>.</p>
<p>2) Initializes a <a href="#" onclick="return false;" data-toggle="collapse" data-target="#CQ_ITEM">CQ_ITEM</a> instance. Here <a href="#" onclick="return false;" data-toggle="collapse" data-target="#CQ_ITEM">CQ_ITEM</a> is an intermediate object passed to <em>worker thread</em>s through <em>connection queue</em>, so <em>worker thread</em>s can create new <em>context</em> based on it.</p>
<div id="CQ_ITEM" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">conn_queue_item</span> <span class="title">CQ_ITEM</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn_queue_item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>               sfd;</span><br><span class="line">    <span class="keyword">enum</span> conn_states  init_state;</span><br><span class="line">    <span class="keyword">int</span>               event_flags;</span><br><span class="line">    <span class="keyword">int</span>               read_buffer_size;</span><br><span class="line">    <span class="keyword">enum</span> network_transport     transport;</span><br><span class="line">    CQ_ITEM          *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">CQ_ITEM@thread.c</text></center><br></div>

<p>3) Push <a href="#" onclick="return false;" data-toggle="collapse" data-target="#CQ_ITEM">CQ_ITEM</a> to the <em>connection queue</em>.</p>
<p>4) Write to <code>notify_send_fd</code> with the command <code>&#39;c&#39;</code>.</p>
<p>As discussed <a href="#memcached-thread-init">before</a>, 4) generates an <strong>event</strong> on the other side of the <a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a> (on the chosen <em>worker thread</em>), which invokes</p>
<h2 id="thread-libevent-process"><a href="#thread-libevent-process" class="headerlink" title="thread_libevent_process"></a>thread_libevent_process</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thread_libevent_process</span><span class="params">(<span class="keyword">int</span> fd, short which, <span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    LIBEVENT_THREAD *me = arg;</span><br><span class="line">    CQ_ITEM *item;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> timeout_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(fd, buf, <span class="number">1</span>) != <span class="number">1</span>) &#123; <span class="comment">// scr: -----------------------&gt; 1)</span></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't read from libevent pipe\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (buf[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">        item = cq_pop(me-&gt;new_conn_queue); <span class="comment">// scr: -------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != item) &#123;</span><br><span class="line">            conn *c = conn_new(item-&gt;sfd, item-&gt;init_state, item-&gt;event_flags,</span><br><span class="line">                               item-&gt;read_buffer_size, item-&gt;transport,</span><br><span class="line">                               me-&gt;base); <span class="comment">// scr: --------------&gt; 3)</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c-&gt;thread = me; <span class="comment">// scr: ------------------------&gt; 4)</span></span><br><span class="line">            &#125;</span><br><span class="line">            cqi_free(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* we were told to pause and report in */</span></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">thread_libevent_process@thread.c</text></center>
<p>1) Read the command (i.e., <code>&#39;c&#39;</code>) from the <a href="http://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">pipe</a>.</p>
<p>2) Read the <code>CQ_ITEM</code> from the <em>connection queue</em>.</p>
<p>3) Call <code>conn_new</code>. In <a href="#server-socket">server_socket</a> we know that <code>conn_new</code> establishes the <em>context</em>, this time, for the new connection, and adds the <a href="http://man7.org/linux/man-pages/man2/accept.2.html" target="_blank" rel="noopener">accept</a>ed <code>fd</code> to <strong>libevent</strong>. Here on <em>worker thread</em>, the callback is set to <code>event_handler</code>, which essentially connects the <strong>drive machine</strong> to the upcoming <strong>event</strong>s on the same connection.</p>
<p>4) Set the <a href="#Threads-initialization">thread information</a> to the context.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf" target="_blank" rel="noopener">Why Threads Are A Bad Idea</a></p>
<p>W. Richard Stevens. 1992. Advanced Programming in the UNIX Environment. Addison Wesley Longman Publishing Co., Inc., Redwood City, CA, USA. </p>
<p><a href="http://deepix.github.io/2016/10/21/tcprst.html" target="_blank" rel="noopener">Resetting a TCP connection and SO_LINGER</a></p>
<p><a href="https://www.usenix.org/legacy/publications/library/proceedings/usenix99/full_papers/pai/pai_html/node7.html" target="_blank" rel="noopener">Single-process event-driven</a></p>

      
    </div>
    
    <p>
    <div>
        
          That's it. Did I make a serious mistake? or miss out on anything important? Or you simply like the read. Link me on <a class="ext-link" href='https://medium.com/source-code/understanding-the-memcached-source-code-event-driven-i-cd6c947c4092'>
            <i class="fa fa-medium" aria-hidden="true"></i>
          </a>  -- I'd be chuffed to hear your feedback.
        
    </div>
    
    <p>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Memcached-Source-Code/">Memcached Source Code</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/event-driven/">event driven</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcached/">memcached</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/multithreading/">multithreading</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/socket/">socket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/state-machine/">state machine</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/understanding-memcached-source-code-VIII/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Understanding The Memcached Source Code-Event Driven II
        
      </div>
    </a>
  
  
    <a href="/understanding-memcached-source-code-VI/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Understanding The Memcached Source Code - LRU III</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#An-introduction-to-event-driven"><span class="nav-number">1.</span> <span class="nav-text">An introduction to event driven</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#The-drive-machine"><span class="nav-number">2.</span> <span class="nav-text">The drive machine</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Thread-model"><span class="nav-number">3.</span> <span class="nav-text">Thread model</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#System-initialization"><span class="nav-number">4.</span> <span class="nav-text">System initialization</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Threads-initialization"><span class="nav-number">5.</span> <span class="nav-text">Threads initialization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#memcached-thread-init"><span class="nav-number">5.1.</span> <span class="nav-text">memcached_thread_init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setup-thread"><span class="nav-number">5.2.</span> <span class="nav-text">setup_thread</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#create-worker"><span class="nav-number">5.3.</span> <span class="nav-text">create_worker</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Socket-initialization"><span class="nav-number">6.</span> <span class="nav-text">Socket initialization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#server-socket"><span class="nav-number">6.1.</span> <span class="nav-text">server_socket</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Inter-thread-communication"><span class="nav-number">7.</span> <span class="nav-text">Inter-thread communication</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#event-handler"><span class="nav-number">7.1.</span> <span class="nav-text">event_handler</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dispatch-conn-new"><span class="nav-number">7.2.</span> <span class="nav-text">dispatch_conn_new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#thread-libevent-process"><span class="nav-number">7.3.</span> <span class="nav-text">thread_libevent_process</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">8.</span> <span class="nav-text">Reference</span></a></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2020 Holmes He 
        
              <a class='ext-link' href="https://creativecommons.org/licenses/by-nd/4.0/">
                <img style="padding-bottom:4px" src="https://mirrors.creativecommons.org/presskit/buttons/80x15/svg/by-nd.svg"/>
              </a>
              <a class='ext-link' href="mailto:holmeshe@hotmail.com">
                <i style="color:#9ea6a6;" class="fas fa-envelope"></i>
              </a>
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>, icons by <a href="https://www.flaticon.com/authors/prettycons" title="prettycons">prettycons</a>, <a href="https://www.freepik.com/" title="Freepik">Freepik</a> and <a href="https://www.flaticon.com/authors/google" title="Google">Google</a> on <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>

    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-104935393-1', 'auto');
ga('send', 'pageview');

</script>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-5381847417546942",
    enable_page_level_ads: true
  });
</script>
<!-- End Google Analytics -->
<!--<script type="text/javascript"> var infolinks_pid = 3169448; var infolinks_wsid = 0; </script> <script type="text/javascript" src="//resources.infolinks.com/js/infolinks_main.js"></script> -->





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  <script type="text/javascript" src="/js/cust.js" async=""></script>
</body>
</html>
