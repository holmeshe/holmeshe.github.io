<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Holmes He</title>

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="socketmemcachedevent drivenstate machinemultithreading">
  
  
  
  
  <meta name="description" content="In classic multithreading, blocking I/O operations constrain the maximum number of requests a server can handle. Hence asynchronous event driven model is used to eliminate the throughput bottleneck. A">
<meta name="keywords" content="socket,memcached,event driven,state machine,multithreading">
<meta property="og:type" content="article">
<meta property="og:title" content="Understanding The Memcached Source Code-Event Driven II">
<meta property="og:url" content="https://holmeshe.me/understanding-memcached-source-code-VIII/index.html">
<meta property="og:site_name" content="Holmes He">
<meta property="og:description" content="In classic multithreading, blocking I/O operations constrain the maximum number of requests a server can handle. Hence asynchronous event driven model is used to eliminate the throughput bottleneck. A">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://holmeshe.me/gallery/spade.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/heart.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/club.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/diamond.svg">
<meta property="og:image" content="https://holmeshe.me/gallery/msglist.png">
<meta property="og:updated_time" content="2020-12-28T09:58:45.608Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Understanding The Memcached Source Code-Event Driven II">
<meta name="twitter:description" content="In classic multithreading, blocking I/O operations constrain the maximum number of requests a server can handle. Hence asynchronous event driven model is used to eliminate the throughput bottleneck. A">
<meta name="twitter:image" content="https://holmeshe.me/gallery/spade.svg">
  
  <link rel="icon" href="/gallery/air-balloon.svg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   
>
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="124px" height="124px" alt="Code Talks" src=" /gallery/air-balloon.svg">
              </a>
            
          </h1>
          
          <div class="site-description">
            \{C}0de<t>a1k(s) =>
            <text id="message">
              
            </text>
            ( ͡° ͜ʖ ͡°)
            <a class='ext-link' href="/atom.xml">
              <i class="fas fa-rss fa-lg"></i>
            </a>
          </div>
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">Series</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-understanding-memcached-source-code-VIII" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      Understanding The Memcached Source Code-Event Driven II
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/understanding-memcached-source-code-VIII/" class="article-date">
	  <time datetime="2019-01-27T20:00:00.000Z" itemprop="datePublished">January 28, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Memcached-Source-Code/">Memcached Source Code</a>
 
      
    </div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="/understanding-memcached-source-code-I/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/spade.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">slab allocator (I, </text></a> <a href="/understanding-memcached-source-code-II/"><text style="color:black;font-weight:bold;">II, </text></a> <a href="/understanding-memcached-source-code-III/"><text style="color:black;font-weight:bold;">III)</text></a> is the core module of the cache system, which largely determines how efficient the bottleneck resource, memory, can be utilized. The other 3 parts, namely,</p>
<p><a href="/understanding-memcached-source-code-IV/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/heart.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">LRU algorithm (I</text></a> <a href="/understanding-memcached-source-code-V/"><text style="color:black;font-weight:bold;">, II</text></a> <a href="/understanding-memcached-source-code-VI/"><text style="color:black;font-weight:bold;">, III)</text></a> for entry expiration; and an</p>
<p><a href="/understanding-memcached-source-code-VII/" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/club.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">event driven model (I</text></a> <a href="#"><text style="color:black;font-weight:bold;">, II - this article</text></a> <a href="/understanding-memcached-source-code-IX/"><text style="color:black;font-weight:bold;">, III)</text></a> based on libevent; and the</p>
<p><a href="#" class="fancybox"><img align="left" style="padding-right:10px;" src="/gallery/diamond.svg" width="30" height="30"> <text style="color:black;font-weight:bold;">consistent hashing (not complete)</text></a> for data distribution,</p>
<p>are built around it.</p>
<p>In classic <em>multithreading</em>, blocking I/O operations constrain the maximum number of requests a server can handle. Hence asynchronous <strong>event driven</strong> model is used to eliminate the throughput bottleneck. As such, the synchronous and potentially slow process is divided into logic segments that are free of I/O, and are executed asynchronously.</p>
<p>When it comes to asynchronization, extra space is required to store <em>context</em>s. This is because the logic segments, that could be associated with different <em>session</em>s, are executed in an interleaved way. For instance, in the case when asynchronization is implemented (emulated) using synchronous <em>multithreading</em>, the “extra space” is in the form of thread stack. Whilst <em>context</em>s are maintained in user land in <strong>event driven</strong>.</p>
<p><code>conn</code> is the representative of those <em>context</em>s in <strong>Memcached</strong>.</p>
<a id="more"></a>
<h1 id="Core-data-structure-conn"><a href="#Core-data-structure-conn" class="headerlink" title="Core data structure - conn"></a>Core data structure - conn</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">conn</span> <span class="title">conn</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conn</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>    sfd;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> conn_states  state;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> <span class="title">event</span>;</span></span><br><span class="line">    short  ev_flags;</span><br><span class="line">    short  which;   <span class="comment">/** which events were just triggered */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>   *rbuf;   <span class="comment">/** buffer to read commands into */</span></span><br><span class="line">    <span class="keyword">char</span>   *rcurr;  <span class="comment">/** but if we parsed some already, this is where we stopped */</span></span><br><span class="line">    <span class="keyword">int</span>    rsize;   <span class="comment">/** total allocated size of rbuf */</span></span><br><span class="line">    <span class="keyword">int</span>    rbytes;  <span class="comment">/** how much data, starting from rcur, do we have unparsed */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>   *wbuf;</span><br><span class="line">    <span class="keyword">char</span>   *wcurr;</span><br><span class="line">    <span class="keyword">int</span>    wsize;</span><br><span class="line">    <span class="keyword">int</span>    wbytes;</span><br><span class="line">    <span class="comment">/** which state to go into after finishing current write */</span></span><br><span class="line">    <span class="keyword">enum</span> conn_states  write_and_go;</span><br><span class="line">    <span class="keyword">void</span>   *write_and_free; <span class="comment">/** free this memory after finishing writing */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>   *ritem;  <span class="comment">/** when we read in an item's value, it goes here */</span></span><br><span class="line">    <span class="keyword">int</span>    rlbytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data for the nread state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * item is used to hold an item structure created after reading the command</span></span><br><span class="line"><span class="comment">     * line of set/add/replace commands, but before we finished reading the actual</span></span><br><span class="line"><span class="comment">     * data. The data is read into ITEM_data(item) to avoid extra copying.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>   *item;     <span class="comment">/* for commands set/add/replace  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data for the swallow state */</span></span><br><span class="line">    <span class="keyword">int</span>    sbytes;    <span class="comment">/* how many bytes to swallow */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* data for the mwrite state */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">iov</span>;</span></span><br><span class="line">    <span class="keyword">int</span>    iovsize;   <span class="comment">/* number of elements allocated in iov[] */</span></span><br><span class="line">    <span class="keyword">int</span>    iovused;   <span class="comment">/* number of elements used in iov[] */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">msglist</span>;</span></span><br><span class="line">    <span class="keyword">int</span>    msgsize;   <span class="comment">/* number of elements allocated in msglist[] */</span></span><br><span class="line">    <span class="keyword">int</span>    msgused;   <span class="comment">/* number of elements used in msglist[] */</span></span><br><span class="line">    <span class="keyword">int</span>    msgcurr;   <span class="comment">/* element in msglist[] being transmitted now */</span></span><br><span class="line">    <span class="keyword">int</span>    msgbytes;  <span class="comment">/* number of bytes in current msg */</span></span><br><span class="line"></span><br><span class="line">    item   **ilist;   <span class="comment">/* list of items to write out */</span></span><br><span class="line">    <span class="keyword">int</span>    isize;</span><br><span class="line">    item   **icurr;</span><br><span class="line">    <span class="keyword">int</span>    ileft;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> protocol protocol;   <span class="comment">/* which protocol this connection speaks */</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> request_addr_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *hdrbuf; <span class="comment">/* udp packet headers */</span></span><br><span class="line">    <span class="keyword">int</span>    hdrsize;   <span class="comment">/* number of headers' worth of space is allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span>   noreply;   <span class="comment">/* True if the reply should not be sent. */</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    short cmd; <span class="comment">/* current command being processed */</span></span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> keylen;</span><br><span class="line">    conn   *next;     <span class="comment">/* Used for generating a list of conn structures */</span></span><br><span class="line">    LIBEVENT_THREAD *thread; <span class="comment">/* Pointer to the thread object serving this connection */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Properties-in-discussion"><a href="#Properties-in-discussion" class="headerlink" title="Properties in discussion"></a>Properties in discussion</h2><p><code>fd</code> - the file descriptor a <strong>event</strong> is rooted. used by <a href="../understanding-memcached-source-code-VII/">last post</a></p>
<p><code>state</code> - the main focus of this post</p>
<p><code>rbuf</code> - <em>read buffer</em> address. used by <a href="#try-read-network">try_read_network</a></p>
<p><code>rcurr</code> - address of unprocessed data. used by <a href="#try-read-network">try_read_network</a></p>
<p><code>rsize</code> - current size of the <em>read buffer</em>. used by <a href="#try-read-network">try_read_network</a></p>
<p><code>rbytes</code> - size of data to be processed (it is also used as an indicator for leftover data in various places). initialised by <a href="#try-read-network">try_read_network</a>, updated by <a href="#process-get-command">process_get_command</a>, used by <a href="#try-read-command">try_read_command</a></p>
<p><code>last_cmd_time</code> - updated when start processing a command. used by <a href="#try-read-network">try_read_network</a></p>
<p><code>ilist</code> - the <strong>item</strong> list that is associated with the context; <code>icurr</code> and <code>ileft</code> indicate the current entry and number of entries left. used by <a href="#process-get-command">process_get_command</a>, <a href="#Finish-read">conn_release_items</a></p>
<p><code>iov</code> - the actual storage for pointers of output data, which is used by <code>msglist</code>; <code>iovsize</code>, and <code>iovused</code> are its allocated size and used size respectively. initialised by <a href="#try-read-command">process_command</a>, used by <a href="#add-iov">add_iov</a>, <a href="#add-iov">ensure_iov_space</a></p>
<p class="back"><br>Here the data structures (<code>struct msghdr</code> and <code>struct iovec</code>) is required by <a href="http://man7.org/linux/man-pages/man3/sendmsg.3p.html" target="_blank" rel="noopener">sendmsg</a>. The relevant text about the API is pasted bellow.<br></p>

<blockquote>
<p>The msg_iov and msg_iovlen fields of message specify zero or more buffers containing the data to be sent.  msg_iov points to an array of iovec structures; msg_iovlen shall be set to the dimension of this array. In each iovec structure, the iov_base field specifies a storage area and the iov_len field gives its size in bytes. Some of these sizes can be zero. The data from each storage area indicated by msg_iov is sent in turn.<br>…</p>
</blockquote>
<p><code>msglist</code> - the list that stores the <code>struct msghdr</code> themselves; <code>msgsize</code> and <code>msgused</code> are its allocated size and used size respectively; <code>msgbytes</code> indicates totall size of the output data size; <code>msgcurr</code> points to the index that has been processed (written).</p>
<blockquote>
<p>Yet nothing is bette than a chart to demonstrate the data structures and the layout in memory.</p>
</blockquote>
<a href="#" id="fig_core_ds" style="visibility: hidden"></a>
<p><img src="/gallery/msglist.png" alt="msglist &amp; iov"></p>
<h2 id="State-switch"><a href="#State-switch" class="headerlink" title="State switch"></a>State switch</h2><p>An <strong>event</strong> triggers cascading changes of <code>state</code>s which in turn invokes various procedures, before <strong>drive machine</strong> relinquishes control and waits for a new <strong>event</strong> arrival. In <a href="../understanding-memcached-source-code-VII/">last post</a>, we have seen this process on <em>dispatch thread</em>, in which </p>
<p>1) <code>conn_listening</code> is triggered by a new connection;</p>
<p>2) <a href="/understanding-memcached-source-code-VII/#dispatch-conn-new">dispatch_conn_new</a> is invoked, which transfer the new accepted <code>fd</code>, as well as succeeding <strong>event</strong>s to one of the <em>worker thread</em>s;</p>
<p>3) <em>dispatch thread</em> gives up CPU and waits for new “new connection” <strong>event</strong>s.</p>
<p>In this post, we are going to see more complex <em>state switch</em>es that effectively link together the procedures we discussed in <a href="/understanding-memcached-source-code-VI/">LRU III</a>,</p>
<p class="back"><br>The <strong>state</strong> of a given session is represented by <code>conn.state</code> of its associated <em>context</em>.<br></p>

<p>and this time we are going to adopt a similar approach as <a href="/understanding-memcached-source-code-VI/">LRU III</a>, i.e., sending <em>telnet commands</em> to a <strong>Memcached</strong> instance, to navigate the outermost layer of the <strong>Memcached</strong> application.</p>
<p class="back"><br>We will also switch ON the convenient <a href="#" onclick="return false;" data-toggle="collapse" data-target="#verbose">verbose</a> with <code>-vvv</code> to better observe the internal state transitions.<br></p>

<div id="verbose" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="string">'v'</span>:</span><br><span class="line">    settings.verbose++;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5518</text></center><br></div>

<h1 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h1><p>Firstly (as usual) we <em>telnet</em> to the <strong>Memcached</strong> instance, and add some <strong>item</strong>s</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...<span class="comment">// add some items</span></span><br><span class="line">~telnet localhost <span class="number">11211</span></span><br><span class="line">Trying <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is '^]'.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Telnet input</text></center>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;<span class="number">36</span> <span class="keyword">new</span> <span class="keyword">auto</span>-negotiating client connection</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Server verbose</text></center>
<p class="back"><br>Here <code>36</code> is the accepted <code>fd</code>. As mentioned, the following operations will be on this <code>fd</code>.<br></p>

<p>Next we send the exact same read command to the <strong>Memcached</strong> instance as in <a href="/understanding-memcached-source-code-VI/#Read">LRU III</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; get test</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Telnet input</text></center>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">36</span>: going from conn_new_cmd to conn_waiting</span><br><span class="line"><span class="number">36</span>: going from conn_waiting to conn_read</span><br><span class="line"><span class="number">36</span>: going from conn_read to conn_parse_cmd</span><br><span class="line"><span class="number">36</span>: Client <span class="keyword">using</span> the ascii protocol</span><br><span class="line">&lt;<span class="number">36</span> get test</span><br><span class="line">&gt; FOUND KEY test</span><br><span class="line">&gt;<span class="number">36</span> sending key test</span><br><span class="line">&gt;<span class="number">36</span> END</span><br><span class="line"><span class="number">36</span>: going from conn_parse_cmd to conn_mwrite</span><br><span class="line"><span class="number">36</span>: going from conn_mwrite to conn_new_cmd</span><br><span class="line"><span class="number">36</span>: going from conn_new_cmd to conn_waiting</span><br><span class="line"><span class="number">36</span>: going from conn_waiting to conn_read</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">Server verbose</text></center>
<p>As mentioned in <a href="/understanding-memcached-source-code-VII/#event-handler">last post</a>, the initial state of <em>worker thread</em>s is</p>
<h2 id="conn-new-cmd"><a href="#conn-new-cmd" class="headerlink" title="conn_new_cmd"></a>conn_new_cmd</h2><p>so we get started from here.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drive_machine</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nreqs = settings.reqs_per_event; <span class="comment">// scr: --------&gt; 1)</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_new_cmd:</span><br><span class="line">            <span class="comment">/* Only process nreqs at a time to avoid starving other</span></span><br><span class="line"><span class="comment">               connections */</span></span><br><span class="line">            --nreqs; <span class="comment">// scr: ----------------------------&gt; 1)</span></span><br><span class="line">            <span class="keyword">if</span> (nreqs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                reset_cmd_handler(c); <span class="comment">// scr: -----------&gt; 2)</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pthread_mutex_lock(&amp;c-&gt;thread-&gt;stats.mutex);</span><br><span class="line">                c-&gt;thread-&gt;stats.conn_yields++;</span><br><span class="line">                pthread_mutex_unlock(&amp;c-&gt;thread-&gt;stats.mutex);</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;rbytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">                &#125;</span><br><span class="line">                stop = <span class="literal">true</span>; <span class="comment">// scr: --------------------&gt; 3)</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reset_cmd_handler</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    c-&gt;cmd = <span class="number">-1</span>;</span><br><span class="line">    c-&gt;substate = bin_no_state;</span><br><span class="line">    <span class="keyword">if</span>(c-&gt;item != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        item_remove(c-&gt;item);</span><br><span class="line">        c-&gt;item = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    conn_shrink(c);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;rbytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        conn_set_state(c, conn_parse_cmd); <span class="comment">// scr: -----&gt; 2a)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        conn_set_state(c, conn_waiting); <span class="comment">// scr: -------&gt; 2b)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4361 & reset_cmd_handler</text></center>
<p>1) <code>nreqs</code> (<a href="#" onclick="return false;" data-toggle="collapse" data-target="#reqs_per_event">settings.reqs_per_event</a>) is the maximum requests one <em>event loop</em> iteration should handle. Note that the threshold is needed because new connections will not be handled if one <em>event loop</em> iteration takes too long to complete. Note also that the connection being interrupted will be fired again and get the chance to enter the <strong>drive machine</strong> with a “read” event since the descriptor is set with <code>EV_PERSIST</code> in the <a href="/understanding-memcached-source-code-VII/#event-handler">last post</a>.</p>
<div id="reqs_per_event" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">settings.reqs_per_event = <span class="number">20</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">    settings.reqs_per_event = atoi(optarg);</span><br><span class="line">    <span class="keyword">if</span> (settings.reqs_per_event == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Number of requests per event must be greater than 0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:5545, 6112</text></center><br></div>

<p>2) Initializes the relevant properties in the <em>context</em> for a new command.</p>
<p>2a) If there are leftover data, then switch to <code>conn_parse_cmd</code> directly.</p>
<p>2b) If it is a fresh <em>session</em>, then switch to <code>conn_waiting</code>.</p>
<p>3) Yield the current iteration when the threshold is reached.</p>
<h2 id="conn-waiting"><a href="#conn-waiting" class="headerlink" title="conn_waiting"></a>conn_waiting</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_waiting:</span><br><span class="line">            <span class="keyword">if</span> (!update_event(c, EV_READ | EV_PERSIST)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Couldn't update event\n"</span>);</span><br><span class="line">                conn_set_state(c, conn_closing);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            conn_set_state(c, conn_read);</span><br><span class="line">            stop = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4322</text></center>
<p>Simply reset the descriptor with the original flags (i.e., <code>EV_READ</code>, <code>EV_PERSIST</code>), update the state of the <em>context</em> to the next hop (<code>conn_read</code>), and relinquish the CPU.</p>
<h2 id="conn-read"><a href="#conn-read" class="headerlink" title="conn_read"></a>conn_read</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> conn_read:</span><br><span class="line">    res = IS_UDP(c-&gt;transport) ? try_read_udp(c) : try_read_network(c); <span class="comment">//1)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">    <span class="keyword">case</span> READ_NO_DATA_RECEIVED:</span><br><span class="line">        conn_set_state(c, conn_waiting);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ_DATA_RECEIVED:</span><br><span class="line">        conn_set_state(c, conn_parse_cmd); <span class="comment">// scr: ---------------------&gt; 2)</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ_ERROR:</span><br><span class="line">        conn_set_state(c, conn_closing);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> READ_MEMORY_ERROR: <span class="comment">/* Failed to allocate more memory */</span></span><br><span class="line">        <span class="comment">/* State already set by try_read_network */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4334</text></center>
<p>1) Read from the file descriptor and save the data to the <em>context</em>.</p>
<p>2) Switch to the next state, <code>conn_parse_cmd</code>.</p>
<h3 id="try-read-network"><a href="#try-read-network" class="headerlink" title="try_read_network"></a>try_read_network</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> try_read_result <span class="title">try_read_network</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> try_read_result gotdata = READ_NO_DATA_RECEIVED;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">int</span> num_allocs = <span class="number">0</span>;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;rcurr != c-&gt;rbuf) &#123; <span class="comment">// scr: -------------------------&gt; 1)</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;rbytes != <span class="number">0</span>) <span class="comment">/* otherwise there's nothing to copy */</span></span><br><span class="line">            memmove(c-&gt;rbuf, c-&gt;rcurr, c-&gt;rbytes);</span><br><span class="line">        c-&gt;rcurr = c-&gt;rbuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;rbytes &gt;= c-&gt;rsize) &#123; <span class="comment">// scr: -------------------&gt; 2)</span></span><br><span class="line">            <span class="keyword">if</span> (num_allocs == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> gotdata;</span><br><span class="line">            &#125;</span><br><span class="line">            ++num_allocs;</span><br><span class="line">            <span class="keyword">char</span> *new_rbuf = <span class="built_in">realloc</span>(c-&gt;rbuf, c-&gt;rsize * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (!new_rbuf) &#123;</span><br><span class="line">...<span class="comment">// scr: error handling</span></span><br><span class="line">            &#125;</span><br><span class="line">            c-&gt;rcurr = c-&gt;rbuf = new_rbuf;</span><br><span class="line">            c-&gt;rsize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> avail = c-&gt;rsize - c-&gt;rbytes; <span class="comment">// scr: --------------&gt; 3)</span></span><br><span class="line">        res = read(c-&gt;sfd, c-&gt;rbuf + c-&gt;rbytes, avail);</span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">            gotdata = READ_DATA_RECEIVED;</span><br><span class="line">            c-&gt;rbytes += res;</span><br><span class="line">            <span class="keyword">if</span> (res == avail) &#123; <span class="comment">// scr: -----------------------&gt; 3a)</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// scr: --------------------------------&gt; 3b)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> READ_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123; <span class="comment">//src:3b)</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> READ_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotdata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:try_read_network</text></center>
<p>Here the <code>while (1)</code> is used to handle logic flow for buffer expanding instead of loop.</p>
<p>1) Move <code>rcurr</code> to the beginning of the <em>read buffer</em>.</p>
<p>2) If the data size exceeds the <em>read buffer</em> size, try expanding the buffer (for at most 4 times).</p>
<p>3) Calculate the available buffer space for <a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="noopener">read</a>ing from the socket, and update <code>rbytes</code> accordingly.</p>
<p>3a) Goto 2) if the buffer is full.</p>
<p>3b) Return <code>READ_DATA_RECEIVED</code>, which switches the state to <code>conn_parse_cmd</code> in the <strong>state machine</strong> pass through.</p>
<h2 id="conn-parse-cmd"><a href="#conn-parse-cmd" class="headerlink" title="conn_parse_cmd"></a>conn_parse_cmd</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">case</span> conn_parse_cmd :</span><br><span class="line">    <span class="keyword">if</span> (try_read_command(c) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* wee need more data! */</span></span><br><span class="line">        conn_set_state(c, conn_waiting);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:try_read_network</text></center>
<h3 id="try-read-command"><a href="#try-read-command" class="headerlink" title="try_read_command"></a>try_read_command</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">try_read_command</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line">    assert(c-&gt;rcurr &lt;= (c-&gt;rbuf + c-&gt;rsize));</span><br><span class="line">    assert(c-&gt;rbytes &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;protocol == negotiating_prot || c-&gt;transport == udp_transport)  &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">char</span>)c-&gt;rbuf[<span class="number">0</span>] == (<span class="keyword">unsigned</span> <span class="keyword">char</span>)PROTOCOL_BINARY_REQ) &#123;</span><br><span class="line">            c-&gt;protocol = binary_prot;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c-&gt;protocol = ascii_prot; <span class="comment">// scr: -------------------------&gt; 1)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">1</span>) &#123; <span class="comment">// scr: ---------------------------&gt; ~)</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%d: Client using the %s protocol\n"</span>, c-&gt;sfd,</span><br><span class="line">                    prot_text(c-&gt;protocol));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;protocol == binary_prot) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> *el, *cont;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;rbytes == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        el = <span class="built_in">memchr</span>(c-&gt;rcurr, <span class="string">'\n'</span>, c-&gt;rbytes); <span class="comment">// scr: ---------------&gt; 2)</span></span><br><span class="line">        <span class="keyword">if</span> (!el) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">        &#125;</span><br><span class="line">        cont = el + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((el - c-&gt;rcurr) &gt; <span class="number">1</span> &amp;&amp; *(el - <span class="number">1</span>) == <span class="string">'\r'</span>) &#123;</span><br><span class="line">            el--;</span><br><span class="line">        &#125;</span><br><span class="line">        *el = <span class="string">'\0'</span>; <span class="comment">// scr: -------------------------------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">        assert(cont &lt;= (c-&gt;rcurr + c-&gt;rbytes));</span><br><span class="line"></span><br><span class="line">        c-&gt;last_cmd_time = current_time; <span class="comment">// scr: ----------------------&gt; 3)</span></span><br><span class="line">        process_command(c, c-&gt;rcurr); <span class="comment">// scr: -------------------------&gt; 4)</span></span><br><span class="line"></span><br><span class="line">        c-&gt;rbytes -= (cont - c-&gt;rcurr); <span class="comment">// scr: -----------------------&gt; 5)</span></span><br><span class="line">        c-&gt;rcurr = cont; <span class="comment">// scr: --------------------------------------&gt; 6)</span></span><br><span class="line"></span><br><span class="line">        assert(c-&gt;rcurr &lt;= (c-&gt;rbuf + c-&gt;rsize));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:try_read_command</text></center>
<p>1) Determine the protocol type, in this case is <code>ascii_prot</code>.</p>
<p>~) Verbose message we saw in the beginning.</p>
<p>2) Trim all the <code>&#39;\n&#39;</code> and <code>&#39;\r&#39;</code> in the end, store the position of the command last character to <code>el</code>, and store the command end to <code>cont</code>.</p>
<p>3) Update <code>last_cmd_time</code>.</p>
<p>4) Call <a href="#" onclick="return false;" data-toggle="collapse" data-target="#process_command">process_command</a> which locates the “get” command and call <code>process_get_command</code>. In <a href="#" onclick="return false;" data-toggle="collapse" data-target="#process_command">process_command</a>, a) <code>tokenize_command</code> is a string parsing method that stores command (i.e., “get”) in <code>tokens[COMMAND_TOKEN]</code> and key (i.e., test) in <code>tokens[KEY_TOKEN]</code>; b) initialization of <code>msgcurr</code>, <code>msgused</code>, <code>iovused</code>; c) initialization other fields in <a href="#add-msghdr">add_msghdr</a>; and d) <a href="#process-get-command">process_get_command</a> is the next step.</p>
<div id="process_command" class="collapse"><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">c-&gt;msgcurr = <span class="number">0</span>; <span class="comment">// scr: ---------------------------------------------&gt; b)</span></span><br><span class="line">c-&gt;msgused = <span class="number">0</span>;</span><br><span class="line">c-&gt;iovused = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (add_msghdr(c) != <span class="number">0</span>) &#123;</span><br><span class="line">    out_of_memory(c, <span class="string">"SERVER_ERROR out of memory preparing response"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ntokens = tokenize_command(command, tokens, MAX_TOKENS); <span class="comment">// scr: ----&gt; a)</span></span><br><span class="line"><span class="keyword">if</span> (ntokens &gt;= <span class="number">3</span> &amp;&amp;</span><br><span class="line">    ((<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"get"</span>) == <span class="number">0</span>) || </span><br><span class="line">     (<span class="built_in">strcmp</span>(tokens[COMMAND_TOKEN].value, <span class="string">"bget"</span>) == <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">    process_get_command(c, tokens, ntokens, <span class="literal">false</span>); <span class="comment">// scr: ---------&gt; c)</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:process_command</text></center><br></div>

<p>5) Update <code>rbytes</code> with the length of the command that has been processed (<code>cont - c-&gt;rcurr</code>).</p>
<p>6) Move the <code>rcurr</code> to the unprocessed data located at end of the command portion.</p>
<h3 id="add-msghdr"><a href="#add-msghdr" class="headerlink" title="add_msghdr"></a>add_msghdr</h3><p>Before the logic reaches <a href="#process-get-command">process_get_command</a>, an entry should be initialised in <code>msglist</code> for the current command.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_msghdr</span><span class="params">(conn *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;msgsize == c-&gt;msgused) &#123; <span class="comment">// scr: --------------------&gt; 1)</span></span><br><span class="line">        msg = <span class="built_in">realloc</span>(c-&gt;msglist, c-&gt;msgsize * <span class="number">2</span> * <span class="keyword">sizeof</span>(struct msghdr));</span><br><span class="line">        <span class="keyword">if</span> (! msg) &#123;</span><br><span class="line">            STATS_LOCK();</span><br><span class="line">            stats.malloc_fails++;</span><br><span class="line">            STATS_UNLOCK();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c-&gt;msglist = msg;</span><br><span class="line">        c-&gt;msgsize *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg = c-&gt;msglist + c-&gt;msgused; <span class="comment">// scr: ---------------------&gt; 2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this wipes msg_iovlen, msg_control, msg_controllen, and</span></span><br><span class="line"><span class="comment">       msg_flags, the last 3 of which aren't defined on solaris: */</span></span><br><span class="line">    <span class="built_in">memset</span>(msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct msghdr)); <span class="comment">// scr: -------------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    msg-&gt;msg_iov = &amp;c-&gt;iov[c-&gt;iovused]; <span class="comment">// scr: ----------------&gt; 3)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;request_addr_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;msgbytes = <span class="number">0</span>; <span class="comment">// scr: -----------------------------------&gt; 4)</span></span><br><span class="line">    c-&gt;msgused++; <span class="comment">// scr: --------------------------------------&gt; 5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_UDP(c-&gt;transport)) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">add_msghdr@memcached.c</text></center>
<p>1) Expand the <code>msglist</code> when required.</p>
<p>2) Point to the next empty entry in <code>msglist</code> with <code>msg</code>.</p>
<p>3) Initialise the entry pointed by <code>msg</code>. Here the critical operation is <code>msg-&gt;msg_iov = &amp;c-&gt;iov[c-&gt;iovused];</code> which links the <code>msglist</code> to the specific entry in <code>iov</code>. (<a href="#fig_core_ds">Figure - msglist &amp; iov</a>)</p>
<p>4) Initialise <code>msgbytes</code> to <code>0</code>.</p>
<p>5) Update <code>msgused</code> accordingly.</p>
<h3 id="process-get-command"><a href="#process-get-command" class="headerlink" title="process_get_command"></a>process_get_command</h3><p>We have seen this method in beginning of <a href="/understanding-memcached-source-code-VI/#process-get-command">LRU III</a>. This time, we will complete its pass through with the context of <strong>event driven</strong>.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">process_get_command</span><span class="params">(conn *c, <span class="keyword">token_t</span> *tokens, <span class="keyword">size_t</span> ntokens, <span class="keyword">bool</span> return_cas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *key;</span><br><span class="line">    <span class="keyword">size_t</span> nkey;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    item *it;</span><br><span class="line">    <span class="keyword">token_t</span> *key_token = &amp;tokens[KEY_TOKEN];</span><br><span class="line">    <span class="keyword">char</span> *suffix;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(key_token-&gt;length != <span class="number">0</span>) &#123; <span class="comment">// scr: -----------------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">            key = key_token-&gt;value;</span><br><span class="line">            nkey = key_token-&gt;length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nkey &gt; KEY_MAX_LENGTH) &#123;</span><br><span class="line">                out_string(c, <span class="string">"CLIENT_ERROR bad command line format"</span>);</span><br><span class="line">                <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    item_remove(*(c-&gt;ilist + i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            it = item_get(key, nkey, c); <span class="comment">// scr: ----------------&gt; 2)</span></span><br><span class="line">            <span class="keyword">if</span> (settings.detail_enabled) &#123;</span><br><span class="line">                stats_prefix_record_get(key, nkey, <span class="literal">NULL</span> != it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (it) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= c-&gt;isize) &#123; <span class="comment">// scr: --------------------&gt; 3)</span></span><br><span class="line">                    item **new_list = <span class="built_in">realloc</span>(c-&gt;ilist, <span class="keyword">sizeof</span>(item *) * c-&gt;isize * <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">if</span> (new_list) &#123;</span><br><span class="line">                        c-&gt;isize *= <span class="number">2</span>;</span><br><span class="line">                        c-&gt;ilist = new_list;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">                        item_remove(it);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (return_cas)</span><br><span class="line">                &#123;</span><br><span class="line">...<span class="comment">// scr: cas</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  MEMCACHED_COMMAND_GET(c-&gt;sfd, ITEM_key(it), it-&gt;nkey,</span><br><span class="line">                                        it-&gt;nbytes, ITEM_get_cas(it));</span><br><span class="line">                  <span class="keyword">if</span> (add_iov(c, <span class="string">"VALUE "</span>, <span class="number">6</span>) != <span class="number">0</span> || <span class="comment">// scr: ---&gt; 4)</span></span><br><span class="line">                      add_iov(c, ITEM_key(it), it-&gt;nkey) != <span class="number">0</span> ||</span><br><span class="line">                      add_iov(c, ITEM_suffix(it), it-&gt;nsuffix + it-&gt;nbytes) != <span class="number">0</span>)</span><br><span class="line">                      &#123;</span><br><span class="line">                          item_remove(it);</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: verbose &amp; stat</span></span><br><span class="line"></span><br><span class="line">                item_update(it); <span class="comment">// scr: ------------------------&gt; 5)</span></span><br><span class="line">                *(c-&gt;ilist + i) = it; <span class="comment">// scr: -------------------&gt; 6)</span></span><br><span class="line">                i++;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: stat</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key_token++; <span class="comment">// scr: --------------------------------&gt; 1)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the command string hasn't been fully processed, get the next set</span></span><br><span class="line"><span class="comment">         * of tokens.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(key_token-&gt;value != <span class="literal">NULL</span>) &#123; <span class="comment">// scr: ------------------&gt; 1)</span></span><br><span class="line">            ntokens = tokenize_command(key_token-&gt;value, tokens, MAX_TOKENS);</span><br><span class="line">            key_token = tokens;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span>(key_token-&gt;value != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    c-&gt;icurr = c-&gt;ilist; <span class="comment">// scr: --------------------------------&gt; 6)</span></span><br><span class="line">    c-&gt;ileft = i; scr: ------------------------------------------&gt; <span class="number">6</span>)</span><br><span class="line">...<span class="comment">// scr: cas &amp; verbose</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (key_token-&gt;value != <span class="literal">NULL</span> || add_iov(c, <span class="string">"END\r\n"</span>, <span class="number">5</span>) != <span class="number">0</span></span><br><span class="line">        || (IS_UDP(c-&gt;transport) &amp;&amp; build_udp_headers(c) != <span class="number">0</span>)) &#123;</span><br><span class="line">        out_of_memory(c, <span class="string">"SERVER_ERROR out of memory writing get response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// scr: ----------------------------------------------&gt; 7)</span></span><br><span class="line">        conn_set_state(c, conn_mwrite);</span><br><span class="line">        c-&gt;msgcurr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">process_get_command@memcached.c</text></center>
<p>1) Iterate through key token array. Here we got one key token ‘test’.</p>
<p>2) Call <a href="/understanding-memcached-source-code-VI/#do-item-get">item_get</a> for the <strong>item</strong> pointer.</p>
<p>3) Increase the <code>ilist</code> size if it is full, and . Here <code>ilist</code> stores the <strong>item</strong> being processed. In the <a href="#Finish-read">end of the current command processing</a>,  this list is used to batch release the <strong>item</strong>s reference counts.</p>
<p>4) <code>add_iov</code> prepares the output of this session.</p>
<p>5) Call <a href="/understanding-memcached-source-code-VI/#do-item-update">item_update</a> to manipulate the <em>LRU</em> lists.</p>
<p>6) Link the <strong>item</strong> currently being processed to <code>ilist</code>, and update the associated fields.</p>
<p>7) Move on to the next state <a href="#conn-mwrite">conn_mwrite</a>.</p>
<h3 id="add-iov"><a href="#add-iov" class="headerlink" title="add_iov"></a>add_iov</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add_iov</span><span class="params">(conn *c, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">m</span>;</span></span><br><span class="line">    <span class="keyword">int</span> leftover;</span><br><span class="line">    <span class="keyword">bool</span> limit_to_mtu;</span><br><span class="line"></span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        m = &amp;c-&gt;msglist[c-&gt;msgused - <span class="number">1</span>]; <span class="comment">// scr: -------------------&gt; 1)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Limit UDP packets, and the first payloads of TCP replies, to</span></span><br><span class="line"><span class="comment">         * UDP_MAX_PAYLOAD_SIZE bytes.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        limit_to_mtu = IS_UDP(c-&gt;transport) || (<span class="number">1</span> == c-&gt;msgused);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We may need to start a new msghdr if this one is full. */</span></span><br><span class="line">        <span class="keyword">if</span> (m-&gt;msg_iovlen == IOV_MAX ||</span><br><span class="line">            (limit_to_mtu &amp;&amp; c-&gt;msgbytes &gt;= UDP_MAX_PAYLOAD_SIZE)) &#123;</span><br><span class="line">            add_msghdr(c);</span><br><span class="line">            m = &amp;c-&gt;msglist[c-&gt;msgused - <span class="number">1</span>]; <span class="comment">// scr: ---------------&gt; 7)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ensure_iov_space(c) != <span class="number">0</span>) <span class="comment">// scr: ----------------------&gt; 2)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the fragment is too big to fit in the datagram, split it up */</span></span><br><span class="line">        <span class="keyword">if</span> (limit_to_mtu &amp;&amp; len + c-&gt;msgbytes &gt; UDP_MAX_PAYLOAD_SIZE) &#123;</span><br><span class="line">            leftover = len + c-&gt;msgbytes - UDP_MAX_PAYLOAD_SIZE; <span class="comment">//scr*)</span></span><br><span class="line">            len -= leftover;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftover = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m = &amp;c-&gt;msglist[c-&gt;msgused - <span class="number">1</span>]; <span class="comment">// scr: ------------------&gt; 1)</span></span><br><span class="line">        m-&gt;msg_iov[m-&gt;msg_iovlen].iov_base = (<span class="keyword">void</span> *)buf; <span class="comment">// scr: -&gt; 3)</span></span><br><span class="line">        m-&gt;msg_iov[m-&gt;msg_iovlen].iov_len = len;</span><br><span class="line"></span><br><span class="line">        c-&gt;msgbytes += len; <span class="comment">// scr: -------------------------------&gt; 4)</span></span><br><span class="line">        c-&gt;iovused++; <span class="comment">// scr: -------------------------------------&gt; 5)</span></span><br><span class="line">        m-&gt;msg_iovlen++; <span class="comment">// scr: ----------------------------------&gt; 6)</span></span><br><span class="line"></span><br><span class="line">        buf = ((<span class="keyword">char</span> *)buf) + len;</span><br><span class="line">        len = leftover;</span><br><span class="line">    &#125; <span class="keyword">while</span> (leftover &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">add_iov@memcached.c</text></center>
<p>This method initialised an entry on <code>iov</code> list and add it to the last in-use item in msglist (<a href="#fig_core_ds">Figure - msglist &amp; iov</a>).</p>
<p>1) Get the tail of the in use portion of <code>msglist</code>.</p>
<p>2) Expend <code>iov</code> if necessary.</p>
<p>3) Initialize the <code>iov_base</code> and <code>iov_len</code> fields within the <code>iov</code> entry. Note that the <code>msg_iov</code> has been linked to the position of specific entry in <code>iov</code>, hence operations on <code>msg_iov</code> change the content of <code>iov</code> as well.</p>
<p>4) Update <code>msgbytes</code> with the total <strong>item</strong> size.</p>
<p>5, 6) Update <code>iovused</code> and <code>msg_iovlen</code> accordingly.</p>
<p>7) Handle <strong>MTU</strong> with the assistance of <code>do while</code> loop.</p>
<h2 id="conn-mwrite"><a href="#conn-mwrite" class="headerlink" title="conn_mwrite"></a>conn_mwrite</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">          <span class="keyword">if</span> (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;msgcurr == <span class="number">0</span> &amp;&amp; build_udp_headers(c) != <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">switch</span> (transmit(c)) &#123;</span><br><span class="line">...<span class="comment">// scr: state processing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4521</text></center>
<p>Before explaining the logic <a href="#Back-to-state-processing">process of conn_mwrite state</a>, we look at the essential within first, which is</p>
<h3 id="transmit"><a href="#transmit" class="headerlink" title="transmit"></a>transmit</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">enum</span> transmit_result <span class="title">transmit</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;msgcurr &lt; c-&gt;msgused &amp;&amp;</span><br><span class="line">            c-&gt;msglist[c-&gt;msgcurr].msg_iovlen == <span class="number">0</span>) &#123; <span class="comment">// scr: ---------&gt; 1)</span></span><br><span class="line">        <span class="comment">/* Finished writing the current msg; advance to the next. */</span></span><br><span class="line">        c-&gt;msgcurr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;msgcurr &lt; c-&gt;msgused) &#123; <span class="comment">// scr: ----------------------------&gt; 2)</span></span><br><span class="line">        <span class="keyword">ssize_t</span> res;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> *<span class="title">m</span> = &amp;<span class="title">c</span>-&gt;<span class="title">msglist</span>[<span class="title">c</span>-&gt;<span class="title">msgcurr</span>];</span></span><br><span class="line">            </span><br><span class="line">        res = sendmsg(c-&gt;sfd, m, <span class="number">0</span>); </span><br><span class="line">        <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: state</span></span><br><span class="line">            <span class="comment">/* We've written some of the data. Remove the completed</span></span><br><span class="line"><span class="comment">               iovec entries from the list of pending writes. */</span></span><br><span class="line">            <span class="keyword">while</span> (m-&gt;msg_iovlen &gt; <span class="number">0</span> &amp;&amp; res &gt;= m-&gt;msg_iov-&gt;iov_len) &#123;</span><br><span class="line">                res -= m-&gt;msg_iov-&gt;iov_len;</span><br><span class="line">                m-&gt;msg_iovlen--;</span><br><span class="line">                m-&gt;msg_iov++;</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Might have written just part of the last iovec entry;</span></span><br><span class="line"><span class="comment">               adjust it so the next write will do the rest. */</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                m-&gt;msg_iov-&gt;iov_base = (<span class="keyword">caddr_t</span>)m-&gt;msg_iov-&gt;iov_base + res;</span><br><span class="line">                m-&gt;msg_iov-&gt;iov_len -= res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> TRANSMIT_INCOMPLETE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">-1</span> &amp;&amp; (errno == EAGAIN || errno == EWOULDBLOCK)) &#123; <span class="comment">// 3)</span></span><br><span class="line">            <span class="keyword">if</span> (!update_event(c, EV_WRITE | EV_PERSIST)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Couldn't update event\n"</span>);</span><br><span class="line">                conn_set_state(c, conn_closing);</span><br><span class="line">                <span class="keyword">return</span> TRANSMIT_HARD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> TRANSMIT_SOFT_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,</span></span><br><span class="line"><span class="comment">           we have a real error, on which we close the connection */</span></span><br><span class="line">        <span class="keyword">if</span> (settings.verbose &gt; <span class="number">0</span>)</span><br><span class="line">            perror(<span class="string">"Failed to write, and not due to blocking"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IS_UDP(c-&gt;transport))</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            conn_set_state(c, conn_closing);</span><br><span class="line">        <span class="keyword">return</span> TRANSMIT_HARD_ERROR; <span class="comment">// scr: --------------------------&gt; 4)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> TRANSMIT_COMPLETE; <span class="comment">// scr: ----------------------------&gt; 5)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">transmit@memcached.c</text></center>
<p>As the essential method of state <code>conn_mwrite</code> processing, <code>transmit</code> goes through the <code>msglist</code> (starting from <code>0</code>, the initial value) and tries its best to send out all the pending data accumulated in the current session. This is done within itself or in subsequent passes through the <em>event loop</em>. Only when blocking operation is indicated by <code>EAGAIN</code> or <code>EWOULDBLOCK</code>, the <strong>state machine</strong> stops the current <em>event loop</em> iteration, and the same session will be resumed when the buffer space becomes available again.</p>
<p>1) If the <code>msg_iovlen</code> is <code>0</code>, the writing of <code>msgcurr</code> slot has finished, hence move to the next slot.</p>
<p>2) Call <a href="http://man7.org/linux/man-pages/man3/sendmsg.3p.html" target="_blank" rel="noopener">sendmsg</a> and move <code>msg_iov</code>, <code>iov_base</code> and <code>iov_len</code> according to the data length (<code>res</code>) that has been written successfully. This leads to case b) of the <a href="#Back-to-state-processing">state processing</a>.</p>
<p>3) As mentioned, <code>EAGAIN</code> or <code>EWOULDBLOCK</code> returned by <a href="http://man7.org/linux/man-pages/man3/sendmsg.3p.html" target="_blank" rel="noopener">sendmsg</a> leads to case c) of <a href="#Back-to-state-processing">state processing</a>.</p>
<p>4) Errors other than the above two lead to case c) of <a href="#Back-to-state-processing">state processing</a>.</p>
<p>5) <code>c-&gt;msgcurr &gt;= c-&gt;msgused</code> means <code>write</code> of all data of the session finished, which leads to b) of the <a href="#Back-to-state-processing">state processing</a>.</p>
<h3 id="Back-to-state-processing"><a href="#Back-to-state-processing" class="headerlink" title="Back to state processing"></a>Back to state processing</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">case</span> conn_mwrite:</span><br><span class="line">          <span class="keyword">if</span> (IS_UDP(c-&gt;transport) &amp;&amp; c-&gt;msgcurr == <span class="number">0</span> &amp;&amp; build_udp_headers(c) != <span class="number">0</span>) &#123;</span><br><span class="line">...<span class="comment">// scr: UDP related</span></span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">switch</span> (transmit(c)) &#123;</span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_COMPLETE:</span><br><span class="line">                <span class="keyword">if</span> (c-&gt;state == conn_mwrite) &#123; <span class="comment">// scr: ------------&gt; a)</span></span><br><span class="line">                    conn_release_items(c);</span><br><span class="line">                    <span class="comment">/* <span class="doctag">XXX:</span>  I don't know why this wasn't the general case */</span></span><br><span class="line">                    <span class="keyword">if</span>(c-&gt;protocol == binary_prot) &#123;</span><br><span class="line">                        conn_set_state(c, c-&gt;write_and_go);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        conn_set_state(c, conn_new_cmd);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;state == conn_write) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_INCOMPLETE: <span class="comment">// scr: ---------------------&gt; b)</span></span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_HARD_ERROR:</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">/* Continue in state machine. */</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TRANSMIT_SOFT_ERROR: <span class="comment">// scr: ---------------------&gt; c)</span></span><br><span class="line">                stop = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">memcached.c:4521</text></center>
<p>According to the result of <code>transmit</code>, the logic flows to the following 3 branches,</p>
<p>a) If the result is <code>TRANSMIT_COMPLETE</code>, 1) finalise the current command processing with <a href="#Finish-read">conn_release_items</a>; 2) switch the <code>state</code> to <a href="#conn-new-cmd">conn_new_cmd</a> which 3) eventually falls to <code>conn_waiting</code> and, <a href="#conn-waiting">as discussed</a>, finishes the current <em>event loop</em>.</p>
<p>b) If the result is <code>TRANSMIT_INCOMPLETE</code> and <code>TRANSMIT_HARD_ERROR</code>, the <strong>state machine</strong> keeps the same <strong>state</strong>, and the subsequent passes through the <em>event loop</em> continues consuming more data in <code>msglist</code>. Unlike <code>read</code> operation, <code>TRANSMIT_INCOMPLETE</code> does not lead to immediate <em>event loop</em> finish because write operation does not block until buffer is full.</p>
<p>c) <code>TRANSMIT_SOFT_ERROR</code> means the buffer is full, hence finish the current <em>event loop</em> iteration straight away.</p>
<h3 id="Finish-read"><a href="#Finish-read" class="headerlink" title="Finish read"></a>Finish read</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conn_release_items</span><span class="params">(conn *c)</span> </span>&#123;</span><br><span class="line">    assert(c != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;item) &#123;</span><br><span class="line">...<span class="comment">// scr: not applicable</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (c-&gt;ileft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item *it = *(c-&gt;icurr);</span><br><span class="line">        assert((it-&gt;it_flags &amp; ITEM_SLABBED) == <span class="number">0</span>);</span><br><span class="line">        item_remove(it); <span class="comment">// scr: ---------------------&gt; 1)</span></span><br><span class="line">        c-&gt;icurr++;</span><br><span class="line">        c-&gt;ileft--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...<span class="comment">// scr: cas</span></span><br><span class="line"></span><br><span class="line">    c-&gt;icurr = c-&gt;ilist;</span><br><span class="line">...<span class="comment">// scr: cas</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center style="line-height:0.8;margin:0;"><text style="color:black;font-weight:bold;">conn_release_items@memcached.c</text></center>
<p>Not sure if you noticed or not, there is a subtle bug in the <a href="/understanding-memcached-source-code-VI/#Read">LRU III</a>, the <em>reference count</em> of the <strong>item</strong> in <a href="/understanding-memcached-source-code-VI/#Read">read</a> operation is not returned to 0 as in other operations. This is because </p>
<p>1) all <strong>item</strong>s ownership are batched released here at the end the (<code>read</code>) command processing.</p>

      
    </div>
    
    <p>
    <div>
        
          That's it. Did I make a serious mistake? or miss out on anything important? Or you simply like the read. Link me on <a class="ext-link" href='https://medium.com/source-code/understanding-the-memcached-source-code-event-driven-ii-8d6249d62943'>
            <i class="fa fa-medium" aria-hidden="true"></i>
          </a>  -- I'd be chuffed to hear your feedback.
        
    </div>
    
    <p>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Memcached-Source-Code/">Memcached Source Code</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/event-driven/">event driven</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/memcached/">memcached</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/multithreading/">multithreading</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/socket/">socket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/state-machine/">state machine</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/cn/understanding-memcached-source-code-I/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          理解 Memcached 源码- Slab I
        
      </div>
    </a>
  
  
    <a href="/understanding-memcached-source-code-VII/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Understanding The Memcached Source Code - Event Driven I</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">Contents</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Core-data-structure-conn"><span class="nav-number">1.</span> <span class="nav-text">Core data structure - conn</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Properties-in-discussion"><span class="nav-number">1.1.</span> <span class="nav-text">Properties in discussion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#State-switch"><span class="nav-number">1.2.</span> <span class="nav-text">State switch</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Read"><span class="nav-number">2.</span> <span class="nav-text">Read</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#conn-new-cmd"><span class="nav-number">2.1.</span> <span class="nav-text">conn_new_cmd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#conn-waiting"><span class="nav-number">2.2.</span> <span class="nav-text">conn_waiting</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#conn-read"><span class="nav-number">2.3.</span> <span class="nav-text">conn_read</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#try-read-network"><span class="nav-number">2.3.1.</span> <span class="nav-text">try_read_network</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#conn-parse-cmd"><span class="nav-number">2.4.</span> <span class="nav-text">conn_parse_cmd</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#try-read-command"><span class="nav-number">2.4.1.</span> <span class="nav-text">try_read_command</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add-msghdr"><span class="nav-number">2.4.2.</span> <span class="nav-text">add_msghdr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#process-get-command"><span class="nav-number">2.4.3.</span> <span class="nav-text">process_get_command</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#add-iov"><span class="nav-number">2.4.4.</span> <span class="nav-text">add_iov</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#conn-mwrite"><span class="nav-number">2.5.</span> <span class="nav-text">conn_mwrite</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#transmit"><span class="nav-number">2.5.1.</span> <span class="nav-text">transmit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Back-to-state-processing"><span class="nav-number">2.5.2.</span> <span class="nav-text">Back to state processing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Finish-read"><span class="nav-number">2.5.3.</span> <span class="nav-text">Finish read</span></a></li></ol></li></ol></li></ol>
    
    </div>
  </aside>

</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2020 Holmes He 
        
              <a class='ext-link' href="https://creativecommons.org/licenses/by-nd/4.0/">
                <img style="padding-bottom:4px" src="https://mirrors.creativecommons.org/presskit/buttons/80x15/svg/by-nd.svg"/>
              </a>
              <a class='ext-link' href="mailto:holmeshe@hotmail.com">
                <i style="color:#9ea6a6;" class="fas fa-envelope"></i>
              </a>
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>, icons by <a href="https://www.flaticon.com/authors/prettycons" title="prettycons">prettycons</a>, <a href="https://www.freepik.com/" title="Freepik">Freepik</a> and <a href="https://www.flaticon.com/authors/google" title="Google">Google</a> on <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>

    

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-104935393-1', 'auto');
ga('send', 'pageview');

</script>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-5381847417546942",
    enable_page_level_ads: true
  });
</script>
<!-- End Google Analytics -->
<!--<script type="text/javascript"> var infolinks_pid = 3169448; var infolinks_wsid = 0; </script> <script type="text/javascript" src="//resources.infolinks.com/js/infolinks_main.js"></script> -->





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  <script type="text/javascript" src="/js/cust.js" async=""></script>
</body>
</html>
